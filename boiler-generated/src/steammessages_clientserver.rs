// This file is generated. Do not edit
// @generated

#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(unused_imports)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,Default)]
pub struct CMsgClientHeartBeat {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientHeartBeat {}

impl CMsgClientHeartBeat {
    pub fn new() -> CMsgClientHeartBeat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientHeartBeat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientHeartBeat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientHeartBeat,
        };
        unsafe {
            instance.get(|| {
                CMsgClientHeartBeat {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CMsgClientHeartBeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientHeartBeat>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientHeartBeat {
    fn new() -> CMsgClientHeartBeat {
        CMsgClientHeartBeat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientHeartBeat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientHeartBeat>(
                    "CMsgClientHeartBeat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientHeartBeat {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientHeartBeat {
    fn eq(&self, other: &CMsgClientHeartBeat) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientHeartBeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUDSP2PSessionStarted {
    // message fields
    steamid_remote: ::std::option::Option<u64>,
    appid: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUDSP2PSessionStarted {}

impl CMsgClientUDSP2PSessionStarted {
    pub fn new() -> CMsgClientUDSP2PSessionStarted {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUDSP2PSessionStarted {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUDSP2PSessionStarted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUDSP2PSessionStarted,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUDSP2PSessionStarted {
                    steamid_remote: ::std::option::Option::None,
                    appid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_remote = 1;

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_remote<'a>(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    // optional int32 appid = 2;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> i32 {
        self.appid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionStarted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_remote = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_remote.is_some() {
            my_size += 9;
        };
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_remote {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.appid {
            try!(os.write_int32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUDSP2PSessionStarted>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUDSP2PSessionStarted {
    fn new() -> CMsgClientUDSP2PSessionStarted {
        CMsgClientUDSP2PSessionStarted::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUDSP2PSessionStarted>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_remote",
                    CMsgClientUDSP2PSessionStarted::has_steamid_remote,
                    CMsgClientUDSP2PSessionStarted::get_steamid_remote,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "appid",
                    CMsgClientUDSP2PSessionStarted::has_appid,
                    CMsgClientUDSP2PSessionStarted::get_appid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUDSP2PSessionStarted>(
                    "CMsgClientUDSP2PSessionStarted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUDSP2PSessionStarted {
    fn clear(&mut self) {
        self.clear_steamid_remote();
        self.clear_appid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUDSP2PSessionStarted {
    fn eq(&self, other: &CMsgClientUDSP2PSessionStarted) -> bool {
        self.steamid_remote == other.steamid_remote &&
        self.appid == other.appid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUDSP2PSessionStarted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUDSP2PSessionEnded {
    // message fields
    steamid_remote: ::std::option::Option<u64>,
    appid: ::std::option::Option<i32>,
    session_length_sec: ::std::option::Option<i32>,
    session_error: ::std::option::Option<i32>,
    nattype: ::std::option::Option<i32>,
    bytes_recv: ::std::option::Option<i32>,
    bytes_sent: ::std::option::Option<i32>,
    bytes_sent_relay: ::std::option::Option<i32>,
    bytes_recv_relay: ::std::option::Option<i32>,
    time_to_connect_ms: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUDSP2PSessionEnded {}

impl CMsgClientUDSP2PSessionEnded {
    pub fn new() -> CMsgClientUDSP2PSessionEnded {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUDSP2PSessionEnded {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUDSP2PSessionEnded> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUDSP2PSessionEnded,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUDSP2PSessionEnded {
                    steamid_remote: ::std::option::Option::None,
                    appid: ::std::option::Option::None,
                    session_length_sec: ::std::option::Option::None,
                    session_error: ::std::option::Option::None,
                    nattype: ::std::option::Option::None,
                    bytes_recv: ::std::option::Option::None,
                    bytes_sent: ::std::option::Option::None,
                    bytes_sent_relay: ::std::option::Option::None,
                    bytes_recv_relay: ::std::option::Option::None,
                    time_to_connect_ms: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_remote = 1;

    pub fn clear_steamid_remote(&mut self) {
        self.steamid_remote = ::std::option::Option::None;
    }

    pub fn has_steamid_remote(&self) -> bool {
        self.steamid_remote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_remote(&mut self, v: u64) {
        self.steamid_remote = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_remote<'a>(&self) -> u64 {
        self.steamid_remote.unwrap_or(0)
    }

    // optional int32 appid = 2;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: i32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> i32 {
        self.appid.unwrap_or(0)
    }

    // optional int32 session_length_sec = 3;

    pub fn clear_session_length_sec(&mut self) {
        self.session_length_sec = ::std::option::Option::None;
    }

    pub fn has_session_length_sec(&self) -> bool {
        self.session_length_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_length_sec(&mut self, v: i32) {
        self.session_length_sec = ::std::option::Option::Some(v);
    }

    pub fn get_session_length_sec<'a>(&self) -> i32 {
        self.session_length_sec.unwrap_or(0)
    }

    // optional int32 session_error = 4;

    pub fn clear_session_error(&mut self) {
        self.session_error = ::std::option::Option::None;
    }

    pub fn has_session_error(&self) -> bool {
        self.session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_error(&mut self, v: i32) {
        self.session_error = ::std::option::Option::Some(v);
    }

    pub fn get_session_error<'a>(&self) -> i32 {
        self.session_error.unwrap_or(0)
    }

    // optional int32 nattype = 5;

    pub fn clear_nattype(&mut self) {
        self.nattype = ::std::option::Option::None;
    }

    pub fn has_nattype(&self) -> bool {
        self.nattype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nattype(&mut self, v: i32) {
        self.nattype = ::std::option::Option::Some(v);
    }

    pub fn get_nattype<'a>(&self) -> i32 {
        self.nattype.unwrap_or(0)
    }

    // optional int32 bytes_recv = 6;

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: i32) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_recv<'a>(&self) -> i32 {
        self.bytes_recv.unwrap_or(0)
    }

    // optional int32 bytes_sent = 7;

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: i32) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_sent<'a>(&self) -> i32 {
        self.bytes_sent.unwrap_or(0)
    }

    // optional int32 bytes_sent_relay = 8;

    pub fn clear_bytes_sent_relay(&mut self) {
        self.bytes_sent_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_sent_relay(&self) -> bool {
        self.bytes_sent_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent_relay(&mut self, v: i32) {
        self.bytes_sent_relay = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_sent_relay<'a>(&self) -> i32 {
        self.bytes_sent_relay.unwrap_or(0)
    }

    // optional int32 bytes_recv_relay = 9;

    pub fn clear_bytes_recv_relay(&mut self) {
        self.bytes_recv_relay = ::std::option::Option::None;
    }

    pub fn has_bytes_recv_relay(&self) -> bool {
        self.bytes_recv_relay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv_relay(&mut self, v: i32) {
        self.bytes_recv_relay = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_recv_relay<'a>(&self) -> i32 {
        self.bytes_recv_relay.unwrap_or(0)
    }

    // optional int32 time_to_connect_ms = 10;

    pub fn clear_time_to_connect_ms(&mut self) {
        self.time_to_connect_ms = ::std::option::Option::None;
    }

    pub fn has_time_to_connect_ms(&self) -> bool {
        self.time_to_connect_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_to_connect_ms(&mut self, v: i32) {
        self.time_to_connect_ms = ::std::option::Option::Some(v);
    }

    pub fn get_time_to_connect_ms<'a>(&self) -> i32 {
        self.time_to_connect_ms.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientUDSP2PSessionEnded {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_remote = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.session_length_sec = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.session_error = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.nattype = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.bytes_recv = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.bytes_sent = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.bytes_sent_relay = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.bytes_recv_relay = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.time_to_connect_ms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_remote.is_some() {
            my_size += 9;
        };
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.session_length_sec.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.session_error.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.nattype.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_recv.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_sent.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_sent_relay.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_recv_relay.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.time_to_connect_ms.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_remote {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.appid {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.session_length_sec {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.session_error {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.nattype {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.bytes_recv {
            try!(os.write_int32(6, v));
        };
        if let Some(v) = self.bytes_sent {
            try!(os.write_int32(7, v));
        };
        if let Some(v) = self.bytes_sent_relay {
            try!(os.write_int32(8, v));
        };
        if let Some(v) = self.bytes_recv_relay {
            try!(os.write_int32(9, v));
        };
        if let Some(v) = self.time_to_connect_ms {
            try!(os.write_int32(10, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUDSP2PSessionEnded>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUDSP2PSessionEnded {
    fn new() -> CMsgClientUDSP2PSessionEnded {
        CMsgClientUDSP2PSessionEnded::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUDSP2PSessionEnded>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_remote",
                    CMsgClientUDSP2PSessionEnded::has_steamid_remote,
                    CMsgClientUDSP2PSessionEnded::get_steamid_remote,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "appid",
                    CMsgClientUDSP2PSessionEnded::has_appid,
                    CMsgClientUDSP2PSessionEnded::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "session_length_sec",
                    CMsgClientUDSP2PSessionEnded::has_session_length_sec,
                    CMsgClientUDSP2PSessionEnded::get_session_length_sec,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "session_error",
                    CMsgClientUDSP2PSessionEnded::has_session_error,
                    CMsgClientUDSP2PSessionEnded::get_session_error,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "nattype",
                    CMsgClientUDSP2PSessionEnded::has_nattype,
                    CMsgClientUDSP2PSessionEnded::get_nattype,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "bytes_recv",
                    CMsgClientUDSP2PSessionEnded::has_bytes_recv,
                    CMsgClientUDSP2PSessionEnded::get_bytes_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "bytes_sent",
                    CMsgClientUDSP2PSessionEnded::has_bytes_sent,
                    CMsgClientUDSP2PSessionEnded::get_bytes_sent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "bytes_sent_relay",
                    CMsgClientUDSP2PSessionEnded::has_bytes_sent_relay,
                    CMsgClientUDSP2PSessionEnded::get_bytes_sent_relay,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "bytes_recv_relay",
                    CMsgClientUDSP2PSessionEnded::has_bytes_recv_relay,
                    CMsgClientUDSP2PSessionEnded::get_bytes_recv_relay,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "time_to_connect_ms",
                    CMsgClientUDSP2PSessionEnded::has_time_to_connect_ms,
                    CMsgClientUDSP2PSessionEnded::get_time_to_connect_ms,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUDSP2PSessionEnded>(
                    "CMsgClientUDSP2PSessionEnded",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUDSP2PSessionEnded {
    fn clear(&mut self) {
        self.clear_steamid_remote();
        self.clear_appid();
        self.clear_session_length_sec();
        self.clear_session_error();
        self.clear_nattype();
        self.clear_bytes_recv();
        self.clear_bytes_sent();
        self.clear_bytes_sent_relay();
        self.clear_bytes_recv_relay();
        self.clear_time_to_connect_ms();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUDSP2PSessionEnded {
    fn eq(&self, other: &CMsgClientUDSP2PSessionEnded) -> bool {
        self.steamid_remote == other.steamid_remote &&
        self.appid == other.appid &&
        self.session_length_sec == other.session_length_sec &&
        self.session_error == other.session_error &&
        self.nattype == other.nattype &&
        self.bytes_recv == other.bytes_recv &&
        self.bytes_sent == other.bytes_sent &&
        self.bytes_sent_relay == other.bytes_sent_relay &&
        self.bytes_recv_relay == other.bytes_recv_relay &&
        self.time_to_connect_ms == other.time_to_connect_ms &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUDSP2PSessionEnded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRegisterAuthTicketWithCM {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    client_instance_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRegisterAuthTicketWithCM {}

impl CMsgClientRegisterAuthTicketWithCM {
    pub fn new() -> CMsgClientRegisterAuthTicketWithCM {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRegisterAuthTicketWithCM {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRegisterAuthTicketWithCM> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRegisterAuthTicketWithCM,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRegisterAuthTicketWithCM {
                    protocol_version: ::std::option::Option::None,
                    ticket: ::protobuf::SingularField::none(),
                    client_instance_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 protocol_version = 1;

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    pub fn get_protocol_version<'a>(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    // optional bytes ticket = 3;

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        };
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_ticket<'a>(&'a self) -> &'a [u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint64 client_instance_id = 4;

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    pub fn get_client_instance_id<'a>(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientRegisterAuthTicketWithCM {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.client_instance_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.protocol_version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ticket.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.client_instance_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.ticket.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.client_instance_id {
            try!(os.write_uint64(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRegisterAuthTicketWithCM>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRegisterAuthTicketWithCM {
    fn new() -> CMsgClientRegisterAuthTicketWithCM {
        CMsgClientRegisterAuthTicketWithCM::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRegisterAuthTicketWithCM>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "protocol_version",
                    CMsgClientRegisterAuthTicketWithCM::has_protocol_version,
                    CMsgClientRegisterAuthTicketWithCM::get_protocol_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "ticket",
                    CMsgClientRegisterAuthTicketWithCM::has_ticket,
                    CMsgClientRegisterAuthTicketWithCM::get_ticket,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "client_instance_id",
                    CMsgClientRegisterAuthTicketWithCM::has_client_instance_id,
                    CMsgClientRegisterAuthTicketWithCM::get_client_instance_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRegisterAuthTicketWithCM>(
                    "CMsgClientRegisterAuthTicketWithCM",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRegisterAuthTicketWithCM {
    fn clear(&mut self) {
        self.clear_protocol_version();
        self.clear_ticket();
        self.clear_client_instance_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRegisterAuthTicketWithCM {
    fn eq(&self, other: &CMsgClientRegisterAuthTicketWithCM) -> bool {
        self.protocol_version == other.protocol_version &&
        self.ticket == other.ticket &&
        self.client_instance_id == other.client_instance_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRegisterAuthTicketWithCM {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientTicketAuthComplete {
    // message fields
    steam_id: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    estate: ::std::option::Option<u32>,
    eauth_session_response: ::std::option::Option<u32>,
    DEPRECATED_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ticket_crc: ::std::option::Option<u32>,
    ticket_sequence: ::std::option::Option<u32>,
    owner_steam_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientTicketAuthComplete {}

impl CMsgClientTicketAuthComplete {
    pub fn new() -> CMsgClientTicketAuthComplete {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientTicketAuthComplete {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientTicketAuthComplete> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientTicketAuthComplete,
        };
        unsafe {
            instance.get(|| {
                CMsgClientTicketAuthComplete {
                    steam_id: ::std::option::Option::None,
                    game_id: ::std::option::Option::None,
                    estate: ::std::option::Option::None,
                    eauth_session_response: ::std::option::Option::None,
                    DEPRECATED_ticket: ::protobuf::SingularField::none(),
                    ticket_crc: ::std::option::Option::None,
                    ticket_sequence: ::std::option::Option::None,
                    owner_steam_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional fixed64 game_id = 2;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional uint32 estate = 3;

    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    pub fn get_estate<'a>(&self) -> u32 {
        self.estate.unwrap_or(0)
    }

    // optional uint32 eauth_session_response = 4;

    pub fn clear_eauth_session_response(&mut self) {
        self.eauth_session_response = ::std::option::Option::None;
    }

    pub fn has_eauth_session_response(&self) -> bool {
        self.eauth_session_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eauth_session_response(&mut self, v: u32) {
        self.eauth_session_response = ::std::option::Option::Some(v);
    }

    pub fn get_eauth_session_response<'a>(&self) -> u32 {
        self.eauth_session_response.unwrap_or(0)
    }

    // optional bytes DEPRECATED_ticket = 5;

    pub fn clear_DEPRECATED_ticket(&mut self) {
        self.DEPRECATED_ticket.clear();
    }

    pub fn has_DEPRECATED_ticket(&self) -> bool {
        self.DEPRECATED_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DEPRECATED_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.DEPRECATED_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DEPRECATED_ticket<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.DEPRECATED_ticket.is_none() {
            self.DEPRECATED_ticket.set_default();
        };
        self.DEPRECATED_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_DEPRECATED_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.DEPRECATED_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_DEPRECATED_ticket<'a>(&'a self) -> &'a [u8] {
        match self.DEPRECATED_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 ticket_crc = 6;

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    pub fn get_ticket_crc<'a>(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }

    // optional uint32 ticket_sequence = 7;

    pub fn clear_ticket_sequence(&mut self) {
        self.ticket_sequence = ::std::option::Option::None;
    }

    pub fn has_ticket_sequence(&self) -> bool {
        self.ticket_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_sequence(&mut self, v: u32) {
        self.ticket_sequence = ::std::option::Option::Some(v);
    }

    pub fn get_ticket_sequence<'a>(&self) -> u32 {
        self.ticket_sequence.unwrap_or(0)
    }

    // optional fixed64 owner_steam_id = 8;

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_steam_id<'a>(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientTicketAuthComplete {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.estate = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.eauth_session_response = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.DEPRECATED_ticket));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ticket_crc = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ticket_sequence = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.owner_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        if self.game_id.is_some() {
            my_size += 9;
        };
        for value in self.estate.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.eauth_session_response.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.DEPRECATED_ticket.iter() {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in self.ticket_crc.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ticket_sequence.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.owner_steam_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.estate {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.eauth_session_response {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.DEPRECATED_ticket.as_ref() {
            try!(os.write_bytes(5, &v));
        };
        if let Some(v) = self.ticket_crc {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.ticket_sequence {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.owner_steam_id {
            try!(os.write_fixed64(8, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientTicketAuthComplete>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientTicketAuthComplete {
    fn new() -> CMsgClientTicketAuthComplete {
        CMsgClientTicketAuthComplete::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientTicketAuthComplete>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgClientTicketAuthComplete::has_steam_id,
                    CMsgClientTicketAuthComplete::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientTicketAuthComplete::has_game_id,
                    CMsgClientTicketAuthComplete::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "estate",
                    CMsgClientTicketAuthComplete::has_estate,
                    CMsgClientTicketAuthComplete::get_estate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "eauth_session_response",
                    CMsgClientTicketAuthComplete::has_eauth_session_response,
                    CMsgClientTicketAuthComplete::get_eauth_session_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "DEPRECATED_ticket",
                    CMsgClientTicketAuthComplete::has_DEPRECATED_ticket,
                    CMsgClientTicketAuthComplete::get_DEPRECATED_ticket,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ticket_crc",
                    CMsgClientTicketAuthComplete::has_ticket_crc,
                    CMsgClientTicketAuthComplete::get_ticket_crc,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ticket_sequence",
                    CMsgClientTicketAuthComplete::has_ticket_sequence,
                    CMsgClientTicketAuthComplete::get_ticket_sequence,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "owner_steam_id",
                    CMsgClientTicketAuthComplete::has_owner_steam_id,
                    CMsgClientTicketAuthComplete::get_owner_steam_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientTicketAuthComplete>(
                    "CMsgClientTicketAuthComplete",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientTicketAuthComplete {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_game_id();
        self.clear_estate();
        self.clear_eauth_session_response();
        self.clear_DEPRECATED_ticket();
        self.clear_ticket_crc();
        self.clear_ticket_sequence();
        self.clear_owner_steam_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientTicketAuthComplete {
    fn eq(&self, other: &CMsgClientTicketAuthComplete) -> bool {
        self.steam_id == other.steam_id &&
        self.game_id == other.game_id &&
        self.estate == other.estate &&
        self.eauth_session_response == other.eauth_session_response &&
        self.DEPRECATED_ticket == other.DEPRECATED_ticket &&
        self.ticket_crc == other.ticket_crc &&
        self.ticket_sequence == other.ticket_sequence &&
        self.owner_steam_id == other.owner_steam_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientTicketAuthComplete {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLogon {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    obfustucated_private_ip: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    last_session_id: ::std::option::Option<u32>,
    client_package_version: ::std::option::Option<u32>,
    client_language: ::protobuf::SingularField<::std::string::String>,
    client_os_type: ::std::option::Option<u32>,
    should_remember_password: ::std::option::Option<bool>,
    wine_version: ::protobuf::SingularField<::std::string::String>,
    ping_ms_from_cell_search: ::std::option::Option<u32>,
    public_ip: ::std::option::Option<u32>,
    qos_level: ::std::option::Option<u32>,
    client_supplied_steam_id: ::std::option::Option<u64>,
    machine_id: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    launcher_type: ::std::option::Option<u32>,
    ui_mode: ::std::option::Option<u32>,
    steam2_auth_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    email_address: ::protobuf::SingularField<::std::string::String>,
    rtime32_account_creation: ::std::option::Option<u32>,
    account_name: ::protobuf::SingularField<::std::string::String>,
    password: ::protobuf::SingularField<::std::string::String>,
    game_server_token: ::protobuf::SingularField<::std::string::String>,
    login_key: ::protobuf::SingularField<::std::string::String>,
    was_converted_deprecated_msg: ::std::option::Option<bool>,
    anon_user_target_account_name: ::protobuf::SingularField<::std::string::String>,
    resolved_user_steam_id: ::std::option::Option<u64>,
    eresult_sentryfile: ::std::option::Option<i32>,
    sha_sentryfile: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    auth_code: ::protobuf::SingularField<::std::string::String>,
    otp_type: ::std::option::Option<i32>,
    otp_value: ::std::option::Option<u32>,
    otp_identifier: ::protobuf::SingularField<::std::string::String>,
    steam2_ticket_request: ::std::option::Option<bool>,
    sony_psn_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    sony_psn_service_id: ::protobuf::SingularField<::std::string::String>,
    create_new_psn_linked_account_if_needed: ::std::option::Option<bool>,
    sony_psn_name: ::protobuf::SingularField<::std::string::String>,
    game_server_app_id: ::std::option::Option<i32>,
    steamguard_dont_remember_computer: ::std::option::Option<bool>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    machine_name_userchosen: ::protobuf::SingularField<::std::string::String>,
    country_override: ::protobuf::SingularField<::std::string::String>,
    is_steam_box: ::std::option::Option<bool>,
    client_instance_id: ::std::option::Option<u64>,
    two_factor_code: ::protobuf::SingularField<::std::string::String>,
    supports_rate_limit_response: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLogon {}

impl CMsgClientLogon {
    pub fn new() -> CMsgClientLogon {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLogon {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLogon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLogon,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLogon {
                    protocol_version: ::std::option::Option::None,
                    obfustucated_private_ip: ::std::option::Option::None,
                    cell_id: ::std::option::Option::None,
                    last_session_id: ::std::option::Option::None,
                    client_package_version: ::std::option::Option::None,
                    client_language: ::protobuf::SingularField::none(),
                    client_os_type: ::std::option::Option::None,
                    should_remember_password: ::std::option::Option::None,
                    wine_version: ::protobuf::SingularField::none(),
                    ping_ms_from_cell_search: ::std::option::Option::None,
                    public_ip: ::std::option::Option::None,
                    qos_level: ::std::option::Option::None,
                    client_supplied_steam_id: ::std::option::Option::None,
                    machine_id: ::protobuf::SingularField::none(),
                    launcher_type: ::std::option::Option::None,
                    ui_mode: ::std::option::Option::None,
                    steam2_auth_ticket: ::protobuf::SingularField::none(),
                    email_address: ::protobuf::SingularField::none(),
                    rtime32_account_creation: ::std::option::Option::None,
                    account_name: ::protobuf::SingularField::none(),
                    password: ::protobuf::SingularField::none(),
                    game_server_token: ::protobuf::SingularField::none(),
                    login_key: ::protobuf::SingularField::none(),
                    was_converted_deprecated_msg: ::std::option::Option::None,
                    anon_user_target_account_name: ::protobuf::SingularField::none(),
                    resolved_user_steam_id: ::std::option::Option::None,
                    eresult_sentryfile: ::std::option::Option::None,
                    sha_sentryfile: ::protobuf::SingularField::none(),
                    auth_code: ::protobuf::SingularField::none(),
                    otp_type: ::std::option::Option::None,
                    otp_value: ::std::option::Option::None,
                    otp_identifier: ::protobuf::SingularField::none(),
                    steam2_ticket_request: ::std::option::Option::None,
                    sony_psn_ticket: ::protobuf::SingularField::none(),
                    sony_psn_service_id: ::protobuf::SingularField::none(),
                    create_new_psn_linked_account_if_needed: ::std::option::Option::None,
                    sony_psn_name: ::protobuf::SingularField::none(),
                    game_server_app_id: ::std::option::Option::None,
                    steamguard_dont_remember_computer: ::std::option::Option::None,
                    machine_name: ::protobuf::SingularField::none(),
                    machine_name_userchosen: ::protobuf::SingularField::none(),
                    country_override: ::protobuf::SingularField::none(),
                    is_steam_box: ::std::option::Option::None,
                    client_instance_id: ::std::option::Option::None,
                    two_factor_code: ::protobuf::SingularField::none(),
                    supports_rate_limit_response: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 protocol_version = 1;

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    pub fn get_protocol_version<'a>(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    // optional uint32 obfustucated_private_ip = 2;

    pub fn clear_obfustucated_private_ip(&mut self) {
        self.obfustucated_private_ip = ::std::option::Option::None;
    }

    pub fn has_obfustucated_private_ip(&self) -> bool {
        self.obfustucated_private_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obfustucated_private_ip(&mut self, v: u32) {
        self.obfustucated_private_ip = ::std::option::Option::Some(v);
    }

    pub fn get_obfustucated_private_ip<'a>(&self) -> u32 {
        self.obfustucated_private_ip.unwrap_or(0)
    }

    // optional uint32 cell_id = 3;

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id<'a>(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    // optional uint32 last_session_id = 4;

    pub fn clear_last_session_id(&mut self) {
        self.last_session_id = ::std::option::Option::None;
    }

    pub fn has_last_session_id(&self) -> bool {
        self.last_session_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_session_id(&mut self, v: u32) {
        self.last_session_id = ::std::option::Option::Some(v);
    }

    pub fn get_last_session_id<'a>(&self) -> u32 {
        self.last_session_id.unwrap_or(0)
    }

    // optional uint32 client_package_version = 5;

    pub fn clear_client_package_version(&mut self) {
        self.client_package_version = ::std::option::Option::None;
    }

    pub fn has_client_package_version(&self) -> bool {
        self.client_package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_package_version(&mut self, v: u32) {
        self.client_package_version = ::std::option::Option::Some(v);
    }

    pub fn get_client_package_version<'a>(&self) -> u32 {
        self.client_package_version.unwrap_or(0)
    }

    // optional string client_language = 6;

    pub fn clear_client_language(&mut self) {
        self.client_language.clear();
    }

    pub fn has_client_language(&self) -> bool {
        self.client_language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_language(&mut self, v: ::std::string::String) {
        self.client_language = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_language<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.client_language.is_none() {
            self.client_language.set_default();
        };
        self.client_language.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_language(&mut self) -> ::std::string::String {
        self.client_language.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_client_language<'a>(&'a self) -> &'a str {
        match self.client_language.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 client_os_type = 7;

    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }

    pub fn get_client_os_type<'a>(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }

    // optional bool should_remember_password = 8;

    pub fn clear_should_remember_password(&mut self) {
        self.should_remember_password = ::std::option::Option::None;
    }

    pub fn has_should_remember_password(&self) -> bool {
        self.should_remember_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_should_remember_password(&mut self, v: bool) {
        self.should_remember_password = ::std::option::Option::Some(v);
    }

    pub fn get_should_remember_password<'a>(&self) -> bool {
        self.should_remember_password.unwrap_or(false)
    }

    // optional string wine_version = 9;

    pub fn clear_wine_version(&mut self) {
        self.wine_version.clear();
    }

    pub fn has_wine_version(&self) -> bool {
        self.wine_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wine_version(&mut self, v: ::std::string::String) {
        self.wine_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wine_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.wine_version.is_none() {
            self.wine_version.set_default();
        };
        self.wine_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_wine_version(&mut self) -> ::std::string::String {
        self.wine_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_wine_version<'a>(&'a self) -> &'a str {
        match self.wine_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 ping_ms_from_cell_search = 10;

    pub fn clear_ping_ms_from_cell_search(&mut self) {
        self.ping_ms_from_cell_search = ::std::option::Option::None;
    }

    pub fn has_ping_ms_from_cell_search(&self) -> bool {
        self.ping_ms_from_cell_search.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping_ms_from_cell_search(&mut self, v: u32) {
        self.ping_ms_from_cell_search = ::std::option::Option::Some(v);
    }

    pub fn get_ping_ms_from_cell_search<'a>(&self) -> u32 {
        self.ping_ms_from_cell_search.unwrap_or(0)
    }

    // optional uint32 public_ip = 20;

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    pub fn get_public_ip<'a>(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    // optional uint32 qos_level = 21;

    pub fn clear_qos_level(&mut self) {
        self.qos_level = ::std::option::Option::None;
    }

    pub fn has_qos_level(&self) -> bool {
        self.qos_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qos_level(&mut self, v: u32) {
        self.qos_level = ::std::option::Option::Some(v);
    }

    pub fn get_qos_level<'a>(&self) -> u32 {
        self.qos_level.unwrap_or(0)
    }

    // optional fixed64 client_supplied_steam_id = 22;

    pub fn clear_client_supplied_steam_id(&mut self) {
        self.client_supplied_steam_id = ::std::option::Option::None;
    }

    pub fn has_client_supplied_steam_id(&self) -> bool {
        self.client_supplied_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_supplied_steam_id(&mut self, v: u64) {
        self.client_supplied_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_client_supplied_steam_id<'a>(&self) -> u64 {
        self.client_supplied_steam_id.unwrap_or(0)
    }

    // optional bytes machine_id = 30;

    pub fn clear_machine_id(&mut self) {
        self.machine_id.clear();
    }

    pub fn has_machine_id(&self) -> bool {
        self.machine_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.machine_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_id<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.machine_id.is_none() {
            self.machine_id.set_default();
        };
        self.machine_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_id(&mut self) -> ::std::vec::Vec<u8> {
        self.machine_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_machine_id<'a>(&'a self) -> &'a [u8] {
        match self.machine_id.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 launcher_type = 31;

    pub fn clear_launcher_type(&mut self) {
        self.launcher_type = ::std::option::Option::None;
    }

    pub fn has_launcher_type(&self) -> bool {
        self.launcher_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher_type(&mut self, v: u32) {
        self.launcher_type = ::std::option::Option::Some(v);
    }

    pub fn get_launcher_type<'a>(&self) -> u32 {
        self.launcher_type.unwrap_or(0u32)
    }

    // optional uint32 ui_mode = 32;

    pub fn clear_ui_mode(&mut self) {
        self.ui_mode = ::std::option::Option::None;
    }

    pub fn has_ui_mode(&self) -> bool {
        self.ui_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ui_mode(&mut self, v: u32) {
        self.ui_mode = ::std::option::Option::Some(v);
    }

    pub fn get_ui_mode<'a>(&self) -> u32 {
        self.ui_mode.unwrap_or(0u32)
    }

    // optional bytes steam2_auth_ticket = 41;

    pub fn clear_steam2_auth_ticket(&mut self) {
        self.steam2_auth_ticket.clear();
    }

    pub fn has_steam2_auth_ticket(&self) -> bool {
        self.steam2_auth_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam2_auth_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.steam2_auth_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steam2_auth_ticket<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.steam2_auth_ticket.is_none() {
            self.steam2_auth_ticket.set_default();
        };
        self.steam2_auth_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_steam2_auth_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.steam2_auth_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_steam2_auth_ticket<'a>(&'a self) -> &'a [u8] {
        match self.steam2_auth_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string email_address = 42;

    pub fn clear_email_address(&mut self) {
        self.email_address.clear();
    }

    pub fn has_email_address(&self) -> bool {
        self.email_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_address(&mut self, v: ::std::string::String) {
        self.email_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_address<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.email_address.is_none() {
            self.email_address.set_default();
        };
        self.email_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_address(&mut self) -> ::std::string::String {
        self.email_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_email_address<'a>(&'a self) -> &'a str {
        match self.email_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed32 rtime32_account_creation = 43;

    pub fn clear_rtime32_account_creation(&mut self) {
        self.rtime32_account_creation = ::std::option::Option::None;
    }

    pub fn has_rtime32_account_creation(&self) -> bool {
        self.rtime32_account_creation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_account_creation(&mut self, v: u32) {
        self.rtime32_account_creation = ::std::option::Option::Some(v);
    }

    pub fn get_rtime32_account_creation<'a>(&self) -> u32 {
        self.rtime32_account_creation.unwrap_or(0)
    }

    // optional string account_name = 50;

    pub fn clear_account_name(&mut self) {
        self.account_name.clear();
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name.set_default();
        };
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_account_name<'a>(&'a self) -> &'a str {
        match self.account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string password = 51;

    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.password.is_none() {
            self.password.set_default();
        };
        self.password.as_mut().unwrap()
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        self.password.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_password<'a>(&'a self) -> &'a str {
        match self.password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string game_server_token = 52;

    pub fn clear_game_server_token(&mut self) {
        self.game_server_token.clear();
    }

    pub fn has_game_server_token(&self) -> bool {
        self.game_server_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_token(&mut self, v: ::std::string::String) {
        self.game_server_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_token<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.game_server_token.is_none() {
            self.game_server_token.set_default();
        };
        self.game_server_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_token(&mut self) -> ::std::string::String {
        self.game_server_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_server_token<'a>(&'a self) -> &'a str {
        match self.game_server_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string login_key = 60;

    pub fn clear_login_key(&mut self) {
        self.login_key.clear();
    }

    pub fn has_login_key(&self) -> bool {
        self.login_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_login_key(&mut self, v: ::std::string::String) {
        self.login_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_login_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.login_key.is_none() {
            self.login_key.set_default();
        };
        self.login_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_login_key(&mut self) -> ::std::string::String {
        self.login_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_login_key<'a>(&'a self) -> &'a str {
        match self.login_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool was_converted_deprecated_msg = 70;

    pub fn clear_was_converted_deprecated_msg(&mut self) {
        self.was_converted_deprecated_msg = ::std::option::Option::None;
    }

    pub fn has_was_converted_deprecated_msg(&self) -> bool {
        self.was_converted_deprecated_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_converted_deprecated_msg(&mut self, v: bool) {
        self.was_converted_deprecated_msg = ::std::option::Option::Some(v);
    }

    pub fn get_was_converted_deprecated_msg<'a>(&self) -> bool {
        self.was_converted_deprecated_msg.unwrap_or(false)
    }

    // optional string anon_user_target_account_name = 80;

    pub fn clear_anon_user_target_account_name(&mut self) {
        self.anon_user_target_account_name.clear();
    }

    pub fn has_anon_user_target_account_name(&self) -> bool {
        self.anon_user_target_account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_anon_user_target_account_name(&mut self, v: ::std::string::String) {
        self.anon_user_target_account_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_anon_user_target_account_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.anon_user_target_account_name.is_none() {
            self.anon_user_target_account_name.set_default();
        };
        self.anon_user_target_account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_anon_user_target_account_name(&mut self) -> ::std::string::String {
        self.anon_user_target_account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_anon_user_target_account_name<'a>(&'a self) -> &'a str {
        match self.anon_user_target_account_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 resolved_user_steam_id = 81;

    pub fn clear_resolved_user_steam_id(&mut self) {
        self.resolved_user_steam_id = ::std::option::Option::None;
    }

    pub fn has_resolved_user_steam_id(&self) -> bool {
        self.resolved_user_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resolved_user_steam_id(&mut self, v: u64) {
        self.resolved_user_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_resolved_user_steam_id<'a>(&self) -> u64 {
        self.resolved_user_steam_id.unwrap_or(0)
    }

    // optional int32 eresult_sentryfile = 82;

    pub fn clear_eresult_sentryfile(&mut self) {
        self.eresult_sentryfile = ::std::option::Option::None;
    }

    pub fn has_eresult_sentryfile(&self) -> bool {
        self.eresult_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_sentryfile(&mut self, v: i32) {
        self.eresult_sentryfile = ::std::option::Option::Some(v);
    }

    pub fn get_eresult_sentryfile<'a>(&self) -> i32 {
        self.eresult_sentryfile.unwrap_or(0)
    }

    // optional bytes sha_sentryfile = 83;

    pub fn clear_sha_sentryfile(&mut self) {
        self.sha_sentryfile.clear();
    }

    pub fn has_sha_sentryfile(&self) -> bool {
        self.sha_sentryfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_sentryfile(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_sentryfile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_sentryfile<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_sentryfile.is_none() {
            self.sha_sentryfile.set_default();
        };
        self.sha_sentryfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_sentryfile(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_sentryfile.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_sentryfile<'a>(&'a self) -> &'a [u8] {
        match self.sha_sentryfile.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string auth_code = 84;

    pub fn clear_auth_code(&mut self) {
        self.auth_code.clear();
    }

    pub fn has_auth_code(&self) -> bool {
        self.auth_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_code(&mut self, v: ::std::string::String) {
        self.auth_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auth_code<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.auth_code.is_none() {
            self.auth_code.set_default();
        };
        self.auth_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_auth_code(&mut self) -> ::std::string::String {
        self.auth_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_auth_code<'a>(&'a self) -> &'a str {
        match self.auth_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 otp_type = 85;

    pub fn clear_otp_type(&mut self) {
        self.otp_type = ::std::option::Option::None;
    }

    pub fn has_otp_type(&self) -> bool {
        self.otp_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_type(&mut self, v: i32) {
        self.otp_type = ::std::option::Option::Some(v);
    }

    pub fn get_otp_type<'a>(&self) -> i32 {
        self.otp_type.unwrap_or(0)
    }

    // optional uint32 otp_value = 86;

    pub fn clear_otp_value(&mut self) {
        self.otp_value = ::std::option::Option::None;
    }

    pub fn has_otp_value(&self) -> bool {
        self.otp_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_value(&mut self, v: u32) {
        self.otp_value = ::std::option::Option::Some(v);
    }

    pub fn get_otp_value<'a>(&self) -> u32 {
        self.otp_value.unwrap_or(0)
    }

    // optional string otp_identifier = 87;

    pub fn clear_otp_identifier(&mut self) {
        self.otp_identifier.clear();
    }

    pub fn has_otp_identifier(&self) -> bool {
        self.otp_identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_otp_identifier(&mut self, v: ::std::string::String) {
        self.otp_identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_otp_identifier<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.otp_identifier.is_none() {
            self.otp_identifier.set_default();
        };
        self.otp_identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_otp_identifier(&mut self) -> ::std::string::String {
        self.otp_identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_otp_identifier<'a>(&'a self) -> &'a str {
        match self.otp_identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool steam2_ticket_request = 88;

    pub fn clear_steam2_ticket_request(&mut self) {
        self.steam2_ticket_request = ::std::option::Option::None;
    }

    pub fn has_steam2_ticket_request(&self) -> bool {
        self.steam2_ticket_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam2_ticket_request(&mut self, v: bool) {
        self.steam2_ticket_request = ::std::option::Option::Some(v);
    }

    pub fn get_steam2_ticket_request<'a>(&self) -> bool {
        self.steam2_ticket_request.unwrap_or(false)
    }

    // optional bytes sony_psn_ticket = 90;

    pub fn clear_sony_psn_ticket(&mut self) {
        self.sony_psn_ticket.clear();
    }

    pub fn has_sony_psn_ticket(&self) -> bool {
        self.sony_psn_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sony_psn_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.sony_psn_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sony_psn_ticket<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sony_psn_ticket.is_none() {
            self.sony_psn_ticket.set_default();
        };
        self.sony_psn_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_sony_psn_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.sony_psn_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sony_psn_ticket<'a>(&'a self) -> &'a [u8] {
        match self.sony_psn_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string sony_psn_service_id = 91;

    pub fn clear_sony_psn_service_id(&mut self) {
        self.sony_psn_service_id.clear();
    }

    pub fn has_sony_psn_service_id(&self) -> bool {
        self.sony_psn_service_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sony_psn_service_id(&mut self, v: ::std::string::String) {
        self.sony_psn_service_id = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sony_psn_service_id<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.sony_psn_service_id.is_none() {
            self.sony_psn_service_id.set_default();
        };
        self.sony_psn_service_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_sony_psn_service_id(&mut self) -> ::std::string::String {
        self.sony_psn_service_id.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sony_psn_service_id<'a>(&'a self) -> &'a str {
        match self.sony_psn_service_id.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool create_new_psn_linked_account_if_needed = 92;

    pub fn clear_create_new_psn_linked_account_if_needed(&mut self) {
        self.create_new_psn_linked_account_if_needed = ::std::option::Option::None;
    }

    pub fn has_create_new_psn_linked_account_if_needed(&self) -> bool {
        self.create_new_psn_linked_account_if_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_new_psn_linked_account_if_needed(&mut self, v: bool) {
        self.create_new_psn_linked_account_if_needed = ::std::option::Option::Some(v);
    }

    pub fn get_create_new_psn_linked_account_if_needed<'a>(&self) -> bool {
        self.create_new_psn_linked_account_if_needed.unwrap_or(false)
    }

    // optional string sony_psn_name = 93;

    pub fn clear_sony_psn_name(&mut self) {
        self.sony_psn_name.clear();
    }

    pub fn has_sony_psn_name(&self) -> bool {
        self.sony_psn_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sony_psn_name(&mut self, v: ::std::string::String) {
        self.sony_psn_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sony_psn_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.sony_psn_name.is_none() {
            self.sony_psn_name.set_default();
        };
        self.sony_psn_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sony_psn_name(&mut self) -> ::std::string::String {
        self.sony_psn_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_sony_psn_name<'a>(&'a self) -> &'a str {
        match self.sony_psn_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 game_server_app_id = 94;

    pub fn clear_game_server_app_id(&mut self) {
        self.game_server_app_id = ::std::option::Option::None;
    }

    pub fn has_game_server_app_id(&self) -> bool {
        self.game_server_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_app_id(&mut self, v: i32) {
        self.game_server_app_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_app_id<'a>(&self) -> i32 {
        self.game_server_app_id.unwrap_or(0)
    }

    // optional bool steamguard_dont_remember_computer = 95;

    pub fn clear_steamguard_dont_remember_computer(&mut self) {
        self.steamguard_dont_remember_computer = ::std::option::Option::None;
    }

    pub fn has_steamguard_dont_remember_computer(&self) -> bool {
        self.steamguard_dont_remember_computer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_dont_remember_computer(&mut self, v: bool) {
        self.steamguard_dont_remember_computer = ::std::option::Option::Some(v);
    }

    pub fn get_steamguard_dont_remember_computer<'a>(&self) -> bool {
        self.steamguard_dont_remember_computer.unwrap_or(false)
    }

    // optional string machine_name = 96;

    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        };
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_machine_name<'a>(&'a self) -> &'a str {
        match self.machine_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string machine_name_userchosen = 97;

    pub fn clear_machine_name_userchosen(&mut self) {
        self.machine_name_userchosen.clear();
    }

    pub fn has_machine_name_userchosen(&self) -> bool {
        self.machine_name_userchosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name_userchosen(&mut self, v: ::std::string::String) {
        self.machine_name_userchosen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name_userchosen<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.machine_name_userchosen.is_none() {
            self.machine_name_userchosen.set_default();
        };
        self.machine_name_userchosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name_userchosen(&mut self) -> ::std::string::String {
        self.machine_name_userchosen.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_machine_name_userchosen<'a>(&'a self) -> &'a str {
        match self.machine_name_userchosen.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string country_override = 98;

    pub fn clear_country_override(&mut self) {
        self.country_override.clear();
    }

    pub fn has_country_override(&self) -> bool {
        self.country_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_override(&mut self, v: ::std::string::String) {
        self.country_override = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_override<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.country_override.is_none() {
            self.country_override.set_default();
        };
        self.country_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_override(&mut self) -> ::std::string::String {
        self.country_override.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_override<'a>(&'a self) -> &'a str {
        match self.country_override.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool is_steam_box = 99;

    pub fn clear_is_steam_box(&mut self) {
        self.is_steam_box = ::std::option::Option::None;
    }

    pub fn has_is_steam_box(&self) -> bool {
        self.is_steam_box.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_steam_box(&mut self, v: bool) {
        self.is_steam_box = ::std::option::Option::Some(v);
    }

    pub fn get_is_steam_box<'a>(&self) -> bool {
        self.is_steam_box.unwrap_or(false)
    }

    // optional uint64 client_instance_id = 100;

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    pub fn get_client_instance_id<'a>(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }

    // optional string two_factor_code = 101;

    pub fn clear_two_factor_code(&mut self) {
        self.two_factor_code.clear();
    }

    pub fn has_two_factor_code(&self) -> bool {
        self.two_factor_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_two_factor_code(&mut self, v: ::std::string::String) {
        self.two_factor_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_two_factor_code<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.two_factor_code.is_none() {
            self.two_factor_code.set_default();
        };
        self.two_factor_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_two_factor_code(&mut self) -> ::std::string::String {
        self.two_factor_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_two_factor_code<'a>(&'a self) -> &'a str {
        match self.two_factor_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool supports_rate_limit_response = 102;

    pub fn clear_supports_rate_limit_response(&mut self) {
        self.supports_rate_limit_response = ::std::option::Option::None;
    }

    pub fn has_supports_rate_limit_response(&self) -> bool {
        self.supports_rate_limit_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_rate_limit_response(&mut self, v: bool) {
        self.supports_rate_limit_response = ::std::option::Option::Some(v);
    }

    pub fn get_supports_rate_limit_response<'a>(&self) -> bool {
        self.supports_rate_limit_response.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientLogon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.obfustucated_private_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_session_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.client_package_version = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.client_language));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.client_os_type = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.should_remember_password = ::std::option::Option::Some(tmp);
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.wine_version));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ping_ms_from_cell_search = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.qos_level = ::std::option::Option::Some(tmp);
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.client_supplied_steam_id = ::std::option::Option::Some(tmp);
                },
                30 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.machine_id));
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.launcher_type = ::std::option::Option::Some(tmp);
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ui_mode = ::std::option::Option::Some(tmp);
                },
                41 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.steam2_auth_ticket));
                },
                42 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email_address));
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.rtime32_account_creation = ::std::option::Option::Some(tmp);
                },
                50 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.account_name));
                },
                51 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.password));
                },
                52 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_server_token));
                },
                60 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.login_key));
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.was_converted_deprecated_msg = ::std::option::Option::Some(tmp);
                },
                80 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.anon_user_target_account_name));
                },
                81 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.resolved_user_steam_id = ::std::option::Option::Some(tmp);
                },
                82 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult_sentryfile = ::std::option::Option::Some(tmp);
                },
                83 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_sentryfile));
                },
                84 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.auth_code));
                },
                85 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.otp_type = ::std::option::Option::Some(tmp);
                },
                86 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.otp_value = ::std::option::Option::Some(tmp);
                },
                87 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.otp_identifier));
                },
                88 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.steam2_ticket_request = ::std::option::Option::Some(tmp);
                },
                90 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sony_psn_ticket));
                },
                91 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sony_psn_service_id));
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.create_new_psn_linked_account_if_needed = ::std::option::Option::Some(tmp);
                },
                93 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sony_psn_name));
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.game_server_app_id = ::std::option::Option::Some(tmp);
                },
                95 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.steamguard_dont_remember_computer = ::std::option::Option::Some(tmp);
                },
                96 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name));
                },
                97 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name_userchosen));
                },
                98 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_override));
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_steam_box = ::std::option::Option::Some(tmp);
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.client_instance_id = ::std::option::Option::Some(tmp);
                },
                101 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.two_factor_code));
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.supports_rate_limit_response = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.protocol_version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.obfustucated_private_ip.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cell_id.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.last_session_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.client_package_version.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.client_language.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.client_os_type.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.should_remember_password.is_some() {
            my_size += 2;
        };
        for value in self.wine_version.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.ping_ms_from_cell_search.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.public_ip.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.qos_level.iter() {
            my_size += ::protobuf::rt::value_size(21, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.client_supplied_steam_id.is_some() {
            my_size += 10;
        };
        for value in self.machine_id.iter() {
            my_size += ::protobuf::rt::bytes_size(30, &value);
        };
        for value in self.launcher_type.iter() {
            my_size += ::protobuf::rt::value_size(31, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ui_mode.iter() {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.steam2_auth_ticket.iter() {
            my_size += ::protobuf::rt::bytes_size(41, &value);
        };
        for value in self.email_address.iter() {
            my_size += ::protobuf::rt::string_size(42, &value);
        };
        if self.rtime32_account_creation.is_some() {
            my_size += 6;
        };
        for value in self.account_name.iter() {
            my_size += ::protobuf::rt::string_size(50, &value);
        };
        for value in self.password.iter() {
            my_size += ::protobuf::rt::string_size(51, &value);
        };
        for value in self.game_server_token.iter() {
            my_size += ::protobuf::rt::string_size(52, &value);
        };
        for value in self.login_key.iter() {
            my_size += ::protobuf::rt::string_size(60, &value);
        };
        if self.was_converted_deprecated_msg.is_some() {
            my_size += 3;
        };
        for value in self.anon_user_target_account_name.iter() {
            my_size += ::protobuf::rt::string_size(80, &value);
        };
        if self.resolved_user_steam_id.is_some() {
            my_size += 10;
        };
        for value in self.eresult_sentryfile.iter() {
            my_size += ::protobuf::rt::value_size(82, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_sentryfile.iter() {
            my_size += ::protobuf::rt::bytes_size(83, &value);
        };
        for value in self.auth_code.iter() {
            my_size += ::protobuf::rt::string_size(84, &value);
        };
        for value in self.otp_type.iter() {
            my_size += ::protobuf::rt::value_size(85, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.otp_value.iter() {
            my_size += ::protobuf::rt::value_size(86, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.otp_identifier.iter() {
            my_size += ::protobuf::rt::string_size(87, &value);
        };
        if self.steam2_ticket_request.is_some() {
            my_size += 3;
        };
        for value in self.sony_psn_ticket.iter() {
            my_size += ::protobuf::rt::bytes_size(90, &value);
        };
        for value in self.sony_psn_service_id.iter() {
            my_size += ::protobuf::rt::string_size(91, &value);
        };
        if self.create_new_psn_linked_account_if_needed.is_some() {
            my_size += 3;
        };
        for value in self.sony_psn_name.iter() {
            my_size += ::protobuf::rt::string_size(93, &value);
        };
        for value in self.game_server_app_id.iter() {
            my_size += ::protobuf::rt::value_size(94, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steamguard_dont_remember_computer.is_some() {
            my_size += 3;
        };
        for value in self.machine_name.iter() {
            my_size += ::protobuf::rt::string_size(96, &value);
        };
        for value in self.machine_name_userchosen.iter() {
            my_size += ::protobuf::rt::string_size(97, &value);
        };
        for value in self.country_override.iter() {
            my_size += ::protobuf::rt::string_size(98, &value);
        };
        if self.is_steam_box.is_some() {
            my_size += 3;
        };
        for value in self.client_instance_id.iter() {
            my_size += ::protobuf::rt::value_size(100, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.two_factor_code.iter() {
            my_size += ::protobuf::rt::string_size(101, &value);
        };
        if self.supports_rate_limit_response.is_some() {
            my_size += 3;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.obfustucated_private_ip {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.cell_id {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.last_session_id {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.client_package_version {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.client_language.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.client_os_type {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.should_remember_password {
            try!(os.write_bool(8, v));
        };
        if let Some(v) = self.wine_version.as_ref() {
            try!(os.write_string(9, &v));
        };
        if let Some(v) = self.ping_ms_from_cell_search {
            try!(os.write_uint32(10, v));
        };
        if let Some(v) = self.public_ip {
            try!(os.write_uint32(20, v));
        };
        if let Some(v) = self.qos_level {
            try!(os.write_uint32(21, v));
        };
        if let Some(v) = self.client_supplied_steam_id {
            try!(os.write_fixed64(22, v));
        };
        if let Some(v) = self.machine_id.as_ref() {
            try!(os.write_bytes(30, &v));
        };
        if let Some(v) = self.launcher_type {
            try!(os.write_uint32(31, v));
        };
        if let Some(v) = self.ui_mode {
            try!(os.write_uint32(32, v));
        };
        if let Some(v) = self.steam2_auth_ticket.as_ref() {
            try!(os.write_bytes(41, &v));
        };
        if let Some(v) = self.email_address.as_ref() {
            try!(os.write_string(42, &v));
        };
        if let Some(v) = self.rtime32_account_creation {
            try!(os.write_fixed32(43, v));
        };
        if let Some(v) = self.account_name.as_ref() {
            try!(os.write_string(50, &v));
        };
        if let Some(v) = self.password.as_ref() {
            try!(os.write_string(51, &v));
        };
        if let Some(v) = self.game_server_token.as_ref() {
            try!(os.write_string(52, &v));
        };
        if let Some(v) = self.login_key.as_ref() {
            try!(os.write_string(60, &v));
        };
        if let Some(v) = self.was_converted_deprecated_msg {
            try!(os.write_bool(70, v));
        };
        if let Some(v) = self.anon_user_target_account_name.as_ref() {
            try!(os.write_string(80, &v));
        };
        if let Some(v) = self.resolved_user_steam_id {
            try!(os.write_fixed64(81, v));
        };
        if let Some(v) = self.eresult_sentryfile {
            try!(os.write_int32(82, v));
        };
        if let Some(v) = self.sha_sentryfile.as_ref() {
            try!(os.write_bytes(83, &v));
        };
        if let Some(v) = self.auth_code.as_ref() {
            try!(os.write_string(84, &v));
        };
        if let Some(v) = self.otp_type {
            try!(os.write_int32(85, v));
        };
        if let Some(v) = self.otp_value {
            try!(os.write_uint32(86, v));
        };
        if let Some(v) = self.otp_identifier.as_ref() {
            try!(os.write_string(87, &v));
        };
        if let Some(v) = self.steam2_ticket_request {
            try!(os.write_bool(88, v));
        };
        if let Some(v) = self.sony_psn_ticket.as_ref() {
            try!(os.write_bytes(90, &v));
        };
        if let Some(v) = self.sony_psn_service_id.as_ref() {
            try!(os.write_string(91, &v));
        };
        if let Some(v) = self.create_new_psn_linked_account_if_needed {
            try!(os.write_bool(92, v));
        };
        if let Some(v) = self.sony_psn_name.as_ref() {
            try!(os.write_string(93, &v));
        };
        if let Some(v) = self.game_server_app_id {
            try!(os.write_int32(94, v));
        };
        if let Some(v) = self.steamguard_dont_remember_computer {
            try!(os.write_bool(95, v));
        };
        if let Some(v) = self.machine_name.as_ref() {
            try!(os.write_string(96, &v));
        };
        if let Some(v) = self.machine_name_userchosen.as_ref() {
            try!(os.write_string(97, &v));
        };
        if let Some(v) = self.country_override.as_ref() {
            try!(os.write_string(98, &v));
        };
        if let Some(v) = self.is_steam_box {
            try!(os.write_bool(99, v));
        };
        if let Some(v) = self.client_instance_id {
            try!(os.write_uint64(100, v));
        };
        if let Some(v) = self.two_factor_code.as_ref() {
            try!(os.write_string(101, &v));
        };
        if let Some(v) = self.supports_rate_limit_response {
            try!(os.write_bool(102, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLogon>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLogon {
    fn new() -> CMsgClientLogon {
        CMsgClientLogon::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLogon>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "protocol_version",
                    CMsgClientLogon::has_protocol_version,
                    CMsgClientLogon::get_protocol_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "obfustucated_private_ip",
                    CMsgClientLogon::has_obfustucated_private_ip,
                    CMsgClientLogon::get_obfustucated_private_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id",
                    CMsgClientLogon::has_cell_id,
                    CMsgClientLogon::get_cell_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_session_id",
                    CMsgClientLogon::has_last_session_id,
                    CMsgClientLogon::get_last_session_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "client_package_version",
                    CMsgClientLogon::has_client_package_version,
                    CMsgClientLogon::get_client_package_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "client_language",
                    CMsgClientLogon::has_client_language,
                    CMsgClientLogon::get_client_language,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "client_os_type",
                    CMsgClientLogon::has_client_os_type,
                    CMsgClientLogon::get_client_os_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "should_remember_password",
                    CMsgClientLogon::has_should_remember_password,
                    CMsgClientLogon::get_should_remember_password,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "wine_version",
                    CMsgClientLogon::has_wine_version,
                    CMsgClientLogon::get_wine_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ping_ms_from_cell_search",
                    CMsgClientLogon::has_ping_ms_from_cell_search,
                    CMsgClientLogon::get_ping_ms_from_cell_search,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "public_ip",
                    CMsgClientLogon::has_public_ip,
                    CMsgClientLogon::get_public_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "qos_level",
                    CMsgClientLogon::has_qos_level,
                    CMsgClientLogon::get_qos_level,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "client_supplied_steam_id",
                    CMsgClientLogon::has_client_supplied_steam_id,
                    CMsgClientLogon::get_client_supplied_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "machine_id",
                    CMsgClientLogon::has_machine_id,
                    CMsgClientLogon::get_machine_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "launcher_type",
                    CMsgClientLogon::has_launcher_type,
                    CMsgClientLogon::get_launcher_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ui_mode",
                    CMsgClientLogon::has_ui_mode,
                    CMsgClientLogon::get_ui_mode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "steam2_auth_ticket",
                    CMsgClientLogon::has_steam2_auth_ticket,
                    CMsgClientLogon::get_steam2_auth_ticket,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "email_address",
                    CMsgClientLogon::has_email_address,
                    CMsgClientLogon::get_email_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "rtime32_account_creation",
                    CMsgClientLogon::has_rtime32_account_creation,
                    CMsgClientLogon::get_rtime32_account_creation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "account_name",
                    CMsgClientLogon::has_account_name,
                    CMsgClientLogon::get_account_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "password",
                    CMsgClientLogon::has_password,
                    CMsgClientLogon::get_password,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "game_server_token",
                    CMsgClientLogon::has_game_server_token,
                    CMsgClientLogon::get_game_server_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "login_key",
                    CMsgClientLogon::has_login_key,
                    CMsgClientLogon::get_login_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "was_converted_deprecated_msg",
                    CMsgClientLogon::has_was_converted_deprecated_msg,
                    CMsgClientLogon::get_was_converted_deprecated_msg,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "anon_user_target_account_name",
                    CMsgClientLogon::has_anon_user_target_account_name,
                    CMsgClientLogon::get_anon_user_target_account_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "resolved_user_steam_id",
                    CMsgClientLogon::has_resolved_user_steam_id,
                    CMsgClientLogon::get_resolved_user_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult_sentryfile",
                    CMsgClientLogon::has_eresult_sentryfile,
                    CMsgClientLogon::get_eresult_sentryfile,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_sentryfile",
                    CMsgClientLogon::has_sha_sentryfile,
                    CMsgClientLogon::get_sha_sentryfile,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "auth_code",
                    CMsgClientLogon::has_auth_code,
                    CMsgClientLogon::get_auth_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "otp_type",
                    CMsgClientLogon::has_otp_type,
                    CMsgClientLogon::get_otp_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "otp_value",
                    CMsgClientLogon::has_otp_value,
                    CMsgClientLogon::get_otp_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "otp_identifier",
                    CMsgClientLogon::has_otp_identifier,
                    CMsgClientLogon::get_otp_identifier,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "steam2_ticket_request",
                    CMsgClientLogon::has_steam2_ticket_request,
                    CMsgClientLogon::get_steam2_ticket_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sony_psn_ticket",
                    CMsgClientLogon::has_sony_psn_ticket,
                    CMsgClientLogon::get_sony_psn_ticket,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "sony_psn_service_id",
                    CMsgClientLogon::has_sony_psn_service_id,
                    CMsgClientLogon::get_sony_psn_service_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "create_new_psn_linked_account_if_needed",
                    CMsgClientLogon::has_create_new_psn_linked_account_if_needed,
                    CMsgClientLogon::get_create_new_psn_linked_account_if_needed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "sony_psn_name",
                    CMsgClientLogon::has_sony_psn_name,
                    CMsgClientLogon::get_sony_psn_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "game_server_app_id",
                    CMsgClientLogon::has_game_server_app_id,
                    CMsgClientLogon::get_game_server_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "steamguard_dont_remember_computer",
                    CMsgClientLogon::has_steamguard_dont_remember_computer,
                    CMsgClientLogon::get_steamguard_dont_remember_computer,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "machine_name",
                    CMsgClientLogon::has_machine_name,
                    CMsgClientLogon::get_machine_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "machine_name_userchosen",
                    CMsgClientLogon::has_machine_name_userchosen,
                    CMsgClientLogon::get_machine_name_userchosen,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "country_override",
                    CMsgClientLogon::has_country_override,
                    CMsgClientLogon::get_country_override,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_steam_box",
                    CMsgClientLogon::has_is_steam_box,
                    CMsgClientLogon::get_is_steam_box,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "client_instance_id",
                    CMsgClientLogon::has_client_instance_id,
                    CMsgClientLogon::get_client_instance_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "two_factor_code",
                    CMsgClientLogon::has_two_factor_code,
                    CMsgClientLogon::get_two_factor_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "supports_rate_limit_response",
                    CMsgClientLogon::has_supports_rate_limit_response,
                    CMsgClientLogon::get_supports_rate_limit_response,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLogon>(
                    "CMsgClientLogon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLogon {
    fn clear(&mut self) {
        self.clear_protocol_version();
        self.clear_obfustucated_private_ip();
        self.clear_cell_id();
        self.clear_last_session_id();
        self.clear_client_package_version();
        self.clear_client_language();
        self.clear_client_os_type();
        self.clear_should_remember_password();
        self.clear_wine_version();
        self.clear_ping_ms_from_cell_search();
        self.clear_public_ip();
        self.clear_qos_level();
        self.clear_client_supplied_steam_id();
        self.clear_machine_id();
        self.clear_launcher_type();
        self.clear_ui_mode();
        self.clear_steam2_auth_ticket();
        self.clear_email_address();
        self.clear_rtime32_account_creation();
        self.clear_account_name();
        self.clear_password();
        self.clear_game_server_token();
        self.clear_login_key();
        self.clear_was_converted_deprecated_msg();
        self.clear_anon_user_target_account_name();
        self.clear_resolved_user_steam_id();
        self.clear_eresult_sentryfile();
        self.clear_sha_sentryfile();
        self.clear_auth_code();
        self.clear_otp_type();
        self.clear_otp_value();
        self.clear_otp_identifier();
        self.clear_steam2_ticket_request();
        self.clear_sony_psn_ticket();
        self.clear_sony_psn_service_id();
        self.clear_create_new_psn_linked_account_if_needed();
        self.clear_sony_psn_name();
        self.clear_game_server_app_id();
        self.clear_steamguard_dont_remember_computer();
        self.clear_machine_name();
        self.clear_machine_name_userchosen();
        self.clear_country_override();
        self.clear_is_steam_box();
        self.clear_client_instance_id();
        self.clear_two_factor_code();
        self.clear_supports_rate_limit_response();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLogon {
    fn eq(&self, other: &CMsgClientLogon) -> bool {
        self.protocol_version == other.protocol_version &&
        self.obfustucated_private_ip == other.obfustucated_private_ip &&
        self.cell_id == other.cell_id &&
        self.last_session_id == other.last_session_id &&
        self.client_package_version == other.client_package_version &&
        self.client_language == other.client_language &&
        self.client_os_type == other.client_os_type &&
        self.should_remember_password == other.should_remember_password &&
        self.wine_version == other.wine_version &&
        self.ping_ms_from_cell_search == other.ping_ms_from_cell_search &&
        self.public_ip == other.public_ip &&
        self.qos_level == other.qos_level &&
        self.client_supplied_steam_id == other.client_supplied_steam_id &&
        self.machine_id == other.machine_id &&
        self.launcher_type == other.launcher_type &&
        self.ui_mode == other.ui_mode &&
        self.steam2_auth_ticket == other.steam2_auth_ticket &&
        self.email_address == other.email_address &&
        self.rtime32_account_creation == other.rtime32_account_creation &&
        self.account_name == other.account_name &&
        self.password == other.password &&
        self.game_server_token == other.game_server_token &&
        self.login_key == other.login_key &&
        self.was_converted_deprecated_msg == other.was_converted_deprecated_msg &&
        self.anon_user_target_account_name == other.anon_user_target_account_name &&
        self.resolved_user_steam_id == other.resolved_user_steam_id &&
        self.eresult_sentryfile == other.eresult_sentryfile &&
        self.sha_sentryfile == other.sha_sentryfile &&
        self.auth_code == other.auth_code &&
        self.otp_type == other.otp_type &&
        self.otp_value == other.otp_value &&
        self.otp_identifier == other.otp_identifier &&
        self.steam2_ticket_request == other.steam2_ticket_request &&
        self.sony_psn_ticket == other.sony_psn_ticket &&
        self.sony_psn_service_id == other.sony_psn_service_id &&
        self.create_new_psn_linked_account_if_needed == other.create_new_psn_linked_account_if_needed &&
        self.sony_psn_name == other.sony_psn_name &&
        self.game_server_app_id == other.game_server_app_id &&
        self.steamguard_dont_remember_computer == other.steamguard_dont_remember_computer &&
        self.machine_name == other.machine_name &&
        self.machine_name_userchosen == other.machine_name_userchosen &&
        self.country_override == other.country_override &&
        self.is_steam_box == other.is_steam_box &&
        self.client_instance_id == other.client_instance_id &&
        self.two_factor_code == other.two_factor_code &&
        self.supports_rate_limit_response == other.supports_rate_limit_response &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLogon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLogonResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    out_of_game_heartbeat_seconds: ::std::option::Option<i32>,
    in_game_heartbeat_seconds: ::std::option::Option<i32>,
    public_ip: ::std::option::Option<u32>,
    rtime32_server_time: ::std::option::Option<u32>,
    account_flags: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    email_domain: ::protobuf::SingularField<::std::string::String>,
    steam2_ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    eresult_extended: ::std::option::Option<i32>,
    webapi_authenticate_user_nonce: ::protobuf::SingularField<::std::string::String>,
    cell_id_ping_threshold: ::std::option::Option<u32>,
    use_pics: ::std::option::Option<bool>,
    vanity_url: ::protobuf::SingularField<::std::string::String>,
    client_supplied_steamid: ::std::option::Option<u64>,
    ip_country_code: ::protobuf::SingularField<::std::string::String>,
    parental_settings: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    parental_setting_signature: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    count_loginfailures_to_migrate: ::std::option::Option<i32>,
    count_disconnects_to_migrate: ::std::option::Option<i32>,
    ogs_data_report_time_window: ::std::option::Option<i32>,
    client_instance_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLogonResponse {}

impl CMsgClientLogonResponse {
    pub fn new() -> CMsgClientLogonResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLogonResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLogonResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLogonResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLogonResponse {
                    eresult: ::std::option::Option::None,
                    out_of_game_heartbeat_seconds: ::std::option::Option::None,
                    in_game_heartbeat_seconds: ::std::option::Option::None,
                    public_ip: ::std::option::Option::None,
                    rtime32_server_time: ::std::option::Option::None,
                    account_flags: ::std::option::Option::None,
                    cell_id: ::std::option::Option::None,
                    email_domain: ::protobuf::SingularField::none(),
                    steam2_ticket: ::protobuf::SingularField::none(),
                    eresult_extended: ::std::option::Option::None,
                    webapi_authenticate_user_nonce: ::protobuf::SingularField::none(),
                    cell_id_ping_threshold: ::std::option::Option::None,
                    use_pics: ::std::option::Option::None,
                    vanity_url: ::protobuf::SingularField::none(),
                    client_supplied_steamid: ::std::option::Option::None,
                    ip_country_code: ::protobuf::SingularField::none(),
                    parental_settings: ::protobuf::SingularField::none(),
                    parental_setting_signature: ::protobuf::SingularField::none(),
                    count_loginfailures_to_migrate: ::std::option::Option::None,
                    count_disconnects_to_migrate: ::std::option::Option::None,
                    ogs_data_report_time_window: ::std::option::Option::None,
                    client_instance_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional int32 out_of_game_heartbeat_seconds = 2;

    pub fn clear_out_of_game_heartbeat_seconds(&mut self) {
        self.out_of_game_heartbeat_seconds = ::std::option::Option::None;
    }

    pub fn has_out_of_game_heartbeat_seconds(&self) -> bool {
        self.out_of_game_heartbeat_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_out_of_game_heartbeat_seconds(&mut self, v: i32) {
        self.out_of_game_heartbeat_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_out_of_game_heartbeat_seconds<'a>(&self) -> i32 {
        self.out_of_game_heartbeat_seconds.unwrap_or(0)
    }

    // optional int32 in_game_heartbeat_seconds = 3;

    pub fn clear_in_game_heartbeat_seconds(&mut self) {
        self.in_game_heartbeat_seconds = ::std::option::Option::None;
    }

    pub fn has_in_game_heartbeat_seconds(&self) -> bool {
        self.in_game_heartbeat_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game_heartbeat_seconds(&mut self, v: i32) {
        self.in_game_heartbeat_seconds = ::std::option::Option::Some(v);
    }

    pub fn get_in_game_heartbeat_seconds<'a>(&self) -> i32 {
        self.in_game_heartbeat_seconds.unwrap_or(0)
    }

    // optional uint32 public_ip = 4;

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    pub fn get_public_ip<'a>(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    // optional fixed32 rtime32_server_time = 5;

    pub fn clear_rtime32_server_time(&mut self) {
        self.rtime32_server_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_time(&self) -> bool {
        self.rtime32_server_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_time(&mut self, v: u32) {
        self.rtime32_server_time = ::std::option::Option::Some(v);
    }

    pub fn get_rtime32_server_time<'a>(&self) -> u32 {
        self.rtime32_server_time.unwrap_or(0)
    }

    // optional uint32 account_flags = 6;

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }

    pub fn get_account_flags<'a>(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    // optional uint32 cell_id = 7;

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id<'a>(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    // optional string email_domain = 8;

    pub fn clear_email_domain(&mut self) {
        self.email_domain.clear();
    }

    pub fn has_email_domain(&self) -> bool {
        self.email_domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_email_domain(&mut self, v: ::std::string::String) {
        self.email_domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_email_domain<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.email_domain.is_none() {
            self.email_domain.set_default();
        };
        self.email_domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_email_domain(&mut self) -> ::std::string::String {
        self.email_domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_email_domain<'a>(&'a self) -> &'a str {
        match self.email_domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes steam2_ticket = 9;

    pub fn clear_steam2_ticket(&mut self) {
        self.steam2_ticket.clear();
    }

    pub fn has_steam2_ticket(&self) -> bool {
        self.steam2_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam2_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.steam2_ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steam2_ticket<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.steam2_ticket.is_none() {
            self.steam2_ticket.set_default();
        };
        self.steam2_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_steam2_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.steam2_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_steam2_ticket<'a>(&'a self) -> &'a [u8] {
        match self.steam2_ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 eresult_extended = 10;

    pub fn clear_eresult_extended(&mut self) {
        self.eresult_extended = ::std::option::Option::None;
    }

    pub fn has_eresult_extended(&self) -> bool {
        self.eresult_extended.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult_extended(&mut self, v: i32) {
        self.eresult_extended = ::std::option::Option::Some(v);
    }

    pub fn get_eresult_extended<'a>(&self) -> i32 {
        self.eresult_extended.unwrap_or(0)
    }

    // optional string webapi_authenticate_user_nonce = 11;

    pub fn clear_webapi_authenticate_user_nonce(&mut self) {
        self.webapi_authenticate_user_nonce.clear();
    }

    pub fn has_webapi_authenticate_user_nonce(&self) -> bool {
        self.webapi_authenticate_user_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webapi_authenticate_user_nonce(&mut self, v: ::std::string::String) {
        self.webapi_authenticate_user_nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webapi_authenticate_user_nonce<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.webapi_authenticate_user_nonce.is_none() {
            self.webapi_authenticate_user_nonce.set_default();
        };
        self.webapi_authenticate_user_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_webapi_authenticate_user_nonce(&mut self) -> ::std::string::String {
        self.webapi_authenticate_user_nonce.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_webapi_authenticate_user_nonce<'a>(&'a self) -> &'a str {
        match self.webapi_authenticate_user_nonce.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 cell_id_ping_threshold = 12;

    pub fn clear_cell_id_ping_threshold(&mut self) {
        self.cell_id_ping_threshold = ::std::option::Option::None;
    }

    pub fn has_cell_id_ping_threshold(&self) -> bool {
        self.cell_id_ping_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id_ping_threshold(&mut self, v: u32) {
        self.cell_id_ping_threshold = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id_ping_threshold<'a>(&self) -> u32 {
        self.cell_id_ping_threshold.unwrap_or(0)
    }

    // optional bool use_pics = 13;

    pub fn clear_use_pics(&mut self) {
        self.use_pics = ::std::option::Option::None;
    }

    pub fn has_use_pics(&self) -> bool {
        self.use_pics.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_pics(&mut self, v: bool) {
        self.use_pics = ::std::option::Option::Some(v);
    }

    pub fn get_use_pics<'a>(&self) -> bool {
        self.use_pics.unwrap_or(false)
    }

    // optional string vanity_url = 14;

    pub fn clear_vanity_url(&mut self) {
        self.vanity_url.clear();
    }

    pub fn has_vanity_url(&self) -> bool {
        self.vanity_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vanity_url(&mut self, v: ::std::string::String) {
        self.vanity_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vanity_url<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.vanity_url.is_none() {
            self.vanity_url.set_default();
        };
        self.vanity_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_vanity_url(&mut self) -> ::std::string::String {
        self.vanity_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_vanity_url<'a>(&'a self) -> &'a str {
        match self.vanity_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 client_supplied_steamid = 20;

    pub fn clear_client_supplied_steamid(&mut self) {
        self.client_supplied_steamid = ::std::option::Option::None;
    }

    pub fn has_client_supplied_steamid(&self) -> bool {
        self.client_supplied_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_supplied_steamid(&mut self, v: u64) {
        self.client_supplied_steamid = ::std::option::Option::Some(v);
    }

    pub fn get_client_supplied_steamid<'a>(&self) -> u64 {
        self.client_supplied_steamid.unwrap_or(0)
    }

    // optional string ip_country_code = 21;

    pub fn clear_ip_country_code(&mut self) {
        self.ip_country_code.clear();
    }

    pub fn has_ip_country_code(&self) -> bool {
        self.ip_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_country_code(&mut self, v: ::std::string::String) {
        self.ip_country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_country_code<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip_country_code.is_none() {
            self.ip_country_code.set_default();
        };
        self.ip_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_country_code(&mut self) -> ::std::string::String {
        self.ip_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_country_code<'a>(&'a self) -> &'a str {
        match self.ip_country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes parental_settings = 22;

    pub fn clear_parental_settings(&mut self) {
        self.parental_settings.clear();
    }

    pub fn has_parental_settings(&self) -> bool {
        self.parental_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parental_settings(&mut self, v: ::std::vec::Vec<u8>) {
        self.parental_settings = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parental_settings<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.parental_settings.is_none() {
            self.parental_settings.set_default();
        };
        self.parental_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_parental_settings(&mut self) -> ::std::vec::Vec<u8> {
        self.parental_settings.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_parental_settings<'a>(&'a self) -> &'a [u8] {
        match self.parental_settings.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes parental_setting_signature = 23;

    pub fn clear_parental_setting_signature(&mut self) {
        self.parental_setting_signature.clear();
    }

    pub fn has_parental_setting_signature(&self) -> bool {
        self.parental_setting_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parental_setting_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.parental_setting_signature = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parental_setting_signature<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.parental_setting_signature.is_none() {
            self.parental_setting_signature.set_default();
        };
        self.parental_setting_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_parental_setting_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.parental_setting_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_parental_setting_signature<'a>(&'a self) -> &'a [u8] {
        match self.parental_setting_signature.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 count_loginfailures_to_migrate = 24;

    pub fn clear_count_loginfailures_to_migrate(&mut self) {
        self.count_loginfailures_to_migrate = ::std::option::Option::None;
    }

    pub fn has_count_loginfailures_to_migrate(&self) -> bool {
        self.count_loginfailures_to_migrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_loginfailures_to_migrate(&mut self, v: i32) {
        self.count_loginfailures_to_migrate = ::std::option::Option::Some(v);
    }

    pub fn get_count_loginfailures_to_migrate<'a>(&self) -> i32 {
        self.count_loginfailures_to_migrate.unwrap_or(0)
    }

    // optional int32 count_disconnects_to_migrate = 25;

    pub fn clear_count_disconnects_to_migrate(&mut self) {
        self.count_disconnects_to_migrate = ::std::option::Option::None;
    }

    pub fn has_count_disconnects_to_migrate(&self) -> bool {
        self.count_disconnects_to_migrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_disconnects_to_migrate(&mut self, v: i32) {
        self.count_disconnects_to_migrate = ::std::option::Option::Some(v);
    }

    pub fn get_count_disconnects_to_migrate<'a>(&self) -> i32 {
        self.count_disconnects_to_migrate.unwrap_or(0)
    }

    // optional int32 ogs_data_report_time_window = 26;

    pub fn clear_ogs_data_report_time_window(&mut self) {
        self.ogs_data_report_time_window = ::std::option::Option::None;
    }

    pub fn has_ogs_data_report_time_window(&self) -> bool {
        self.ogs_data_report_time_window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ogs_data_report_time_window(&mut self, v: i32) {
        self.ogs_data_report_time_window = ::std::option::Option::Some(v);
    }

    pub fn get_ogs_data_report_time_window<'a>(&self) -> i32 {
        self.ogs_data_report_time_window.unwrap_or(0)
    }

    // optional uint64 client_instance_id = 27;

    pub fn clear_client_instance_id(&mut self) {
        self.client_instance_id = ::std::option::Option::None;
    }

    pub fn has_client_instance_id(&self) -> bool {
        self.client_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_instance_id(&mut self, v: u64) {
        self.client_instance_id = ::std::option::Option::Some(v);
    }

    pub fn get_client_instance_id<'a>(&self) -> u64 {
        self.client_instance_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientLogonResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.out_of_game_heartbeat_seconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.in_game_heartbeat_seconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.rtime32_server_time = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.account_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.email_domain));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.steam2_ticket));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult_extended = ::std::option::Option::Some(tmp);
                },
                11 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.webapi_authenticate_user_nonce));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id_ping_threshold = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.use_pics = ::std::option::Option::Some(tmp);
                },
                14 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vanity_url));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.client_supplied_steamid = ::std::option::Option::Some(tmp);
                },
                21 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_country_code));
                },
                22 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parental_settings));
                },
                23 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.parental_setting_signature));
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.count_loginfailures_to_migrate = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.count_disconnects_to_migrate = ::std::option::Option::Some(tmp);
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.ogs_data_report_time_window = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.client_instance_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.out_of_game_heartbeat_seconds.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.in_game_heartbeat_seconds.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.public_ip.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.rtime32_server_time.is_some() {
            my_size += 5;
        };
        for value in self.account_flags.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cell_id.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.email_domain.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.steam2_ticket.iter() {
            my_size += ::protobuf::rt::bytes_size(9, &value);
        };
        for value in self.eresult_extended.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.webapi_authenticate_user_nonce.iter() {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        for value in self.cell_id_ping_threshold.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.use_pics.is_some() {
            my_size += 2;
        };
        for value in self.vanity_url.iter() {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if self.client_supplied_steamid.is_some() {
            my_size += 10;
        };
        for value in self.ip_country_code.iter() {
            my_size += ::protobuf::rt::string_size(21, &value);
        };
        for value in self.parental_settings.iter() {
            my_size += ::protobuf::rt::bytes_size(22, &value);
        };
        for value in self.parental_setting_signature.iter() {
            my_size += ::protobuf::rt::bytes_size(23, &value);
        };
        for value in self.count_loginfailures_to_migrate.iter() {
            my_size += ::protobuf::rt::value_size(24, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.count_disconnects_to_migrate.iter() {
            my_size += ::protobuf::rt::value_size(25, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ogs_data_report_time_window.iter() {
            my_size += ::protobuf::rt::value_size(26, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.client_instance_id.iter() {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.out_of_game_heartbeat_seconds {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.in_game_heartbeat_seconds {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.public_ip {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.rtime32_server_time {
            try!(os.write_fixed32(5, v));
        };
        if let Some(v) = self.account_flags {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.cell_id {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.email_domain.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.steam2_ticket.as_ref() {
            try!(os.write_bytes(9, &v));
        };
        if let Some(v) = self.eresult_extended {
            try!(os.write_int32(10, v));
        };
        if let Some(v) = self.webapi_authenticate_user_nonce.as_ref() {
            try!(os.write_string(11, &v));
        };
        if let Some(v) = self.cell_id_ping_threshold {
            try!(os.write_uint32(12, v));
        };
        if let Some(v) = self.use_pics {
            try!(os.write_bool(13, v));
        };
        if let Some(v) = self.vanity_url.as_ref() {
            try!(os.write_string(14, &v));
        };
        if let Some(v) = self.client_supplied_steamid {
            try!(os.write_fixed64(20, v));
        };
        if let Some(v) = self.ip_country_code.as_ref() {
            try!(os.write_string(21, &v));
        };
        if let Some(v) = self.parental_settings.as_ref() {
            try!(os.write_bytes(22, &v));
        };
        if let Some(v) = self.parental_setting_signature.as_ref() {
            try!(os.write_bytes(23, &v));
        };
        if let Some(v) = self.count_loginfailures_to_migrate {
            try!(os.write_int32(24, v));
        };
        if let Some(v) = self.count_disconnects_to_migrate {
            try!(os.write_int32(25, v));
        };
        if let Some(v) = self.ogs_data_report_time_window {
            try!(os.write_int32(26, v));
        };
        if let Some(v) = self.client_instance_id {
            try!(os.write_uint64(27, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLogonResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLogonResponse {
    fn new() -> CMsgClientLogonResponse {
        CMsgClientLogonResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLogonResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLogonResponse::has_eresult,
                    CMsgClientLogonResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "out_of_game_heartbeat_seconds",
                    CMsgClientLogonResponse::has_out_of_game_heartbeat_seconds,
                    CMsgClientLogonResponse::get_out_of_game_heartbeat_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "in_game_heartbeat_seconds",
                    CMsgClientLogonResponse::has_in_game_heartbeat_seconds,
                    CMsgClientLogonResponse::get_in_game_heartbeat_seconds,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "public_ip",
                    CMsgClientLogonResponse::has_public_ip,
                    CMsgClientLogonResponse::get_public_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "rtime32_server_time",
                    CMsgClientLogonResponse::has_rtime32_server_time,
                    CMsgClientLogonResponse::get_rtime32_server_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "account_flags",
                    CMsgClientLogonResponse::has_account_flags,
                    CMsgClientLogonResponse::get_account_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id",
                    CMsgClientLogonResponse::has_cell_id,
                    CMsgClientLogonResponse::get_cell_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "email_domain",
                    CMsgClientLogonResponse::has_email_domain,
                    CMsgClientLogonResponse::get_email_domain,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "steam2_ticket",
                    CMsgClientLogonResponse::has_steam2_ticket,
                    CMsgClientLogonResponse::get_steam2_ticket,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult_extended",
                    CMsgClientLogonResponse::has_eresult_extended,
                    CMsgClientLogonResponse::get_eresult_extended,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "webapi_authenticate_user_nonce",
                    CMsgClientLogonResponse::has_webapi_authenticate_user_nonce,
                    CMsgClientLogonResponse::get_webapi_authenticate_user_nonce,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id_ping_threshold",
                    CMsgClientLogonResponse::has_cell_id_ping_threshold,
                    CMsgClientLogonResponse::get_cell_id_ping_threshold,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "use_pics",
                    CMsgClientLogonResponse::has_use_pics,
                    CMsgClientLogonResponse::get_use_pics,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "vanity_url",
                    CMsgClientLogonResponse::has_vanity_url,
                    CMsgClientLogonResponse::get_vanity_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "client_supplied_steamid",
                    CMsgClientLogonResponse::has_client_supplied_steamid,
                    CMsgClientLogonResponse::get_client_supplied_steamid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip_country_code",
                    CMsgClientLogonResponse::has_ip_country_code,
                    CMsgClientLogonResponse::get_ip_country_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "parental_settings",
                    CMsgClientLogonResponse::has_parental_settings,
                    CMsgClientLogonResponse::get_parental_settings,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "parental_setting_signature",
                    CMsgClientLogonResponse::has_parental_setting_signature,
                    CMsgClientLogonResponse::get_parental_setting_signature,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "count_loginfailures_to_migrate",
                    CMsgClientLogonResponse::has_count_loginfailures_to_migrate,
                    CMsgClientLogonResponse::get_count_loginfailures_to_migrate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "count_disconnects_to_migrate",
                    CMsgClientLogonResponse::has_count_disconnects_to_migrate,
                    CMsgClientLogonResponse::get_count_disconnects_to_migrate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "ogs_data_report_time_window",
                    CMsgClientLogonResponse::has_ogs_data_report_time_window,
                    CMsgClientLogonResponse::get_ogs_data_report_time_window,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "client_instance_id",
                    CMsgClientLogonResponse::has_client_instance_id,
                    CMsgClientLogonResponse::get_client_instance_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLogonResponse>(
                    "CMsgClientLogonResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLogonResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_out_of_game_heartbeat_seconds();
        self.clear_in_game_heartbeat_seconds();
        self.clear_public_ip();
        self.clear_rtime32_server_time();
        self.clear_account_flags();
        self.clear_cell_id();
        self.clear_email_domain();
        self.clear_steam2_ticket();
        self.clear_eresult_extended();
        self.clear_webapi_authenticate_user_nonce();
        self.clear_cell_id_ping_threshold();
        self.clear_use_pics();
        self.clear_vanity_url();
        self.clear_client_supplied_steamid();
        self.clear_ip_country_code();
        self.clear_parental_settings();
        self.clear_parental_setting_signature();
        self.clear_count_loginfailures_to_migrate();
        self.clear_count_disconnects_to_migrate();
        self.clear_ogs_data_report_time_window();
        self.clear_client_instance_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLogonResponse {
    fn eq(&self, other: &CMsgClientLogonResponse) -> bool {
        self.eresult == other.eresult &&
        self.out_of_game_heartbeat_seconds == other.out_of_game_heartbeat_seconds &&
        self.in_game_heartbeat_seconds == other.in_game_heartbeat_seconds &&
        self.public_ip == other.public_ip &&
        self.rtime32_server_time == other.rtime32_server_time &&
        self.account_flags == other.account_flags &&
        self.cell_id == other.cell_id &&
        self.email_domain == other.email_domain &&
        self.steam2_ticket == other.steam2_ticket &&
        self.eresult_extended == other.eresult_extended &&
        self.webapi_authenticate_user_nonce == other.webapi_authenticate_user_nonce &&
        self.cell_id_ping_threshold == other.cell_id_ping_threshold &&
        self.use_pics == other.use_pics &&
        self.vanity_url == other.vanity_url &&
        self.client_supplied_steamid == other.client_supplied_steamid &&
        self.ip_country_code == other.ip_country_code &&
        self.parental_settings == other.parental_settings &&
        self.parental_setting_signature == other.parental_setting_signature &&
        self.count_loginfailures_to_migrate == other.count_loginfailures_to_migrate &&
        self.count_disconnects_to_migrate == other.count_disconnects_to_migrate &&
        self.ogs_data_report_time_window == other.ogs_data_report_time_window &&
        self.client_instance_id == other.client_instance_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLogonResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestWebAPIAuthenticateUserNonce {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestWebAPIAuthenticateUserNonce {}

impl CMsgClientRequestWebAPIAuthenticateUserNonce {
    pub fn new() -> CMsgClientRequestWebAPIAuthenticateUserNonce {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestWebAPIAuthenticateUserNonce {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestWebAPIAuthenticateUserNonce> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestWebAPIAuthenticateUserNonce,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestWebAPIAuthenticateUserNonce {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CMsgClientRequestWebAPIAuthenticateUserNonce {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestWebAPIAuthenticateUserNonce>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestWebAPIAuthenticateUserNonce {
    fn new() -> CMsgClientRequestWebAPIAuthenticateUserNonce {
        CMsgClientRequestWebAPIAuthenticateUserNonce::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestWebAPIAuthenticateUserNonce>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestWebAPIAuthenticateUserNonce>(
                    "CMsgClientRequestWebAPIAuthenticateUserNonce",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestWebAPIAuthenticateUserNonce {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestWebAPIAuthenticateUserNonce {
    fn eq(&self, other: &CMsgClientRequestWebAPIAuthenticateUserNonce) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestWebAPIAuthenticateUserNonce {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    webapi_authenticate_user_nonce: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestWebAPIAuthenticateUserNonceResponse {}

impl CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    pub fn new() -> CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestWebAPIAuthenticateUserNonceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestWebAPIAuthenticateUserNonceResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
                    eresult: ::std::option::Option::None,
                    webapi_authenticate_user_nonce: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional string webapi_authenticate_user_nonce = 11;

    pub fn clear_webapi_authenticate_user_nonce(&mut self) {
        self.webapi_authenticate_user_nonce.clear();
    }

    pub fn has_webapi_authenticate_user_nonce(&self) -> bool {
        self.webapi_authenticate_user_nonce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webapi_authenticate_user_nonce(&mut self, v: ::std::string::String) {
        self.webapi_authenticate_user_nonce = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_webapi_authenticate_user_nonce<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.webapi_authenticate_user_nonce.is_none() {
            self.webapi_authenticate_user_nonce.set_default();
        };
        self.webapi_authenticate_user_nonce.as_mut().unwrap()
    }

    // Take field
    pub fn take_webapi_authenticate_user_nonce(&mut self) -> ::std::string::String {
        self.webapi_authenticate_user_nonce.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_webapi_authenticate_user_nonce<'a>(&'a self) -> &'a str {
        match self.webapi_authenticate_user_nonce.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                11 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.webapi_authenticate_user_nonce));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.webapi_authenticate_user_nonce.iter() {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.webapi_authenticate_user_nonce.as_ref() {
            try!(os.write_string(11, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    fn new() -> CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
        CMsgClientRequestWebAPIAuthenticateUserNonceResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_eresult,
                    CMsgClientRequestWebAPIAuthenticateUserNonceResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "webapi_authenticate_user_nonce",
                    CMsgClientRequestWebAPIAuthenticateUserNonceResponse::has_webapi_authenticate_user_nonce,
                    CMsgClientRequestWebAPIAuthenticateUserNonceResponse::get_webapi_authenticate_user_nonce,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestWebAPIAuthenticateUserNonceResponse>(
                    "CMsgClientRequestWebAPIAuthenticateUserNonceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_webapi_authenticate_user_nonce();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    fn eq(&self, other: &CMsgClientRequestWebAPIAuthenticateUserNonceResponse) -> bool {
        self.eresult == other.eresult &&
        self.webapi_authenticate_user_nonce == other.webapi_authenticate_user_nonce &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestWebAPIAuthenticateUserNonceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLogOff {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLogOff {}

impl CMsgClientLogOff {
    pub fn new() -> CMsgClientLogOff {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLogOff {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLogOff> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLogOff,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLogOff {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CMsgClientLogOff {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLogOff>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLogOff {
    fn new() -> CMsgClientLogOff {
        CMsgClientLogOff::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLogOff>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLogOff>(
                    "CMsgClientLogOff",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLogOff {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLogOff {
    fn eq(&self, other: &CMsgClientLogOff) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLogOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLoggedOff {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLoggedOff {}

impl CMsgClientLoggedOff {
    pub fn new() -> CMsgClientLoggedOff {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLoggedOff {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLoggedOff> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLoggedOff,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLoggedOff {
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientLoggedOff {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLoggedOff>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLoggedOff {
    fn new() -> CMsgClientLoggedOff {
        CMsgClientLoggedOff::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLoggedOff>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLoggedOff::has_eresult,
                    CMsgClientLoggedOff::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLoggedOff>(
                    "CMsgClientLoggedOff",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLoggedOff {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLoggedOff {
    fn eq(&self, other: &CMsgClientLoggedOff) -> bool {
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLoggedOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientCMList {
    // message fields
    cm_addresses: ::std::vec::Vec<u32>,
    cm_ports: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientCMList {}

impl CMsgClientCMList {
    pub fn new() -> CMsgClientCMList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientCMList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientCMList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientCMList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientCMList {
                    cm_addresses: ::std::vec::Vec::new(),
                    cm_ports: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 cm_addresses = 1;

    pub fn clear_cm_addresses(&mut self) {
        self.cm_addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_addresses(&mut self, v: ::std::vec::Vec<u32>) {
        self.cm_addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_addresses<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.cm_addresses
    }

    // Take field
    pub fn take_cm_addresses(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.cm_addresses, ::std::vec::Vec::new())
    }

    pub fn get_cm_addresses<'a>(&'a self) -> &'a [u32] {
        &self.cm_addresses
    }

    // repeated uint32 cm_ports = 2;

    pub fn clear_cm_ports(&mut self) {
        self.cm_ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_cm_ports(&mut self, v: ::std::vec::Vec<u32>) {
        self.cm_ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cm_ports<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.cm_ports
    }

    // Take field
    pub fn take_cm_ports(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.cm_ports, ::std::vec::Vec::new())
    }

    pub fn get_cm_ports<'a>(&'a self) -> &'a [u32] {
        &self.cm_ports
    }
}

impl ::protobuf::Message for CMsgClientCMList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.cm_addresses));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.cm_ports));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.cm_addresses.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cm_ports.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.cm_addresses.iter() {
            try!(os.write_uint32(1, *v));
        };
        for v in self.cm_ports.iter() {
            try!(os.write_uint32(2, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientCMList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientCMList {
    fn new() -> CMsgClientCMList {
        CMsgClientCMList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientCMList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "cm_addresses",
                    CMsgClientCMList::get_cm_addresses,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "cm_ports",
                    CMsgClientCMList::get_cm_ports,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientCMList>(
                    "CMsgClientCMList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientCMList {
    fn clear(&mut self) {
        self.clear_cm_addresses();
        self.clear_cm_ports();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientCMList {
    fn eq(&self, other: &CMsgClientCMList) -> bool {
        self.cm_addresses == other.cm_addresses &&
        self.cm_ports == other.cm_ports &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientCMList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientP2PConnectionInfo {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    candidate: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientP2PConnectionInfo {}

impl CMsgClientP2PConnectionInfo {
    pub fn new() -> CMsgClientP2PConnectionInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientP2PConnectionInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientP2PConnectionInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientP2PConnectionInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientP2PConnectionInfo {
                    steam_id_dest: ::std::option::Option::None,
                    steam_id_src: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    candidate: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_dest<'a>(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    // optional fixed64 steam_id_src = 2;

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_src<'a>(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    // optional uint32 app_id = 3;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional bytes candidate = 4;

    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    pub fn has_candidate(&self) -> bool {
        self.candidate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::vec::Vec<u8>) {
        self.candidate = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.candidate.is_none() {
            self.candidate.set_default();
        };
        self.candidate.as_mut().unwrap()
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::vec::Vec<u8> {
        self.candidate.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_candidate<'a>(&'a self) -> &'a [u8] {
        match self.candidate.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_dest = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_src = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.candidate));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id_dest.is_some() {
            my_size += 9;
        };
        if self.steam_id_src.is_some() {
            my_size += 9;
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.candidate.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.steam_id_src {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.candidate.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientP2PConnectionInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientP2PConnectionInfo {
    fn new() -> CMsgClientP2PConnectionInfo {
        CMsgClientP2PConnectionInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientP2PConnectionInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_dest",
                    CMsgClientP2PConnectionInfo::has_steam_id_dest,
                    CMsgClientP2PConnectionInfo::get_steam_id_dest,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_src",
                    CMsgClientP2PConnectionInfo::has_steam_id_src,
                    CMsgClientP2PConnectionInfo::get_steam_id_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientP2PConnectionInfo::has_app_id,
                    CMsgClientP2PConnectionInfo::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "candidate",
                    CMsgClientP2PConnectionInfo::has_candidate,
                    CMsgClientP2PConnectionInfo::get_candidate,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientP2PConnectionInfo>(
                    "CMsgClientP2PConnectionInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientP2PConnectionInfo {
    fn clear(&mut self) {
        self.clear_steam_id_dest();
        self.clear_steam_id_src();
        self.clear_app_id();
        self.clear_candidate();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientP2PConnectionInfo {
    fn eq(&self, other: &CMsgClientP2PConnectionInfo) -> bool {
        self.steam_id_dest == other.steam_id_dest &&
        self.steam_id_src == other.steam_id_src &&
        self.app_id == other.app_id &&
        self.candidate == other.candidate &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientP2PConnectionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientP2PConnectionFailInfo {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    app_id: ::std::option::Option<u32>,
    ep2p_session_error: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientP2PConnectionFailInfo {}

impl CMsgClientP2PConnectionFailInfo {
    pub fn new() -> CMsgClientP2PConnectionFailInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientP2PConnectionFailInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientP2PConnectionFailInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientP2PConnectionFailInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientP2PConnectionFailInfo {
                    steam_id_dest: ::std::option::Option::None,
                    steam_id_src: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    ep2p_session_error: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_dest<'a>(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    // optional fixed64 steam_id_src = 2;

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_src<'a>(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    // optional uint32 app_id = 3;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional uint32 ep2p_session_error = 4;

    pub fn clear_ep2p_session_error(&mut self) {
        self.ep2p_session_error = ::std::option::Option::None;
    }

    pub fn has_ep2p_session_error(&self) -> bool {
        self.ep2p_session_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ep2p_session_error(&mut self, v: u32) {
        self.ep2p_session_error = ::std::option::Option::Some(v);
    }

    pub fn get_ep2p_session_error<'a>(&self) -> u32 {
        self.ep2p_session_error.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientP2PConnectionFailInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_dest = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_src = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.ep2p_session_error = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id_dest.is_some() {
            my_size += 9;
        };
        if self.steam_id_src.is_some() {
            my_size += 9;
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ep2p_session_error.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.steam_id_src {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.ep2p_session_error {
            try!(os.write_uint32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientP2PConnectionFailInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientP2PConnectionFailInfo {
    fn new() -> CMsgClientP2PConnectionFailInfo {
        CMsgClientP2PConnectionFailInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientP2PConnectionFailInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_dest",
                    CMsgClientP2PConnectionFailInfo::has_steam_id_dest,
                    CMsgClientP2PConnectionFailInfo::get_steam_id_dest,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_src",
                    CMsgClientP2PConnectionFailInfo::has_steam_id_src,
                    CMsgClientP2PConnectionFailInfo::get_steam_id_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientP2PConnectionFailInfo::has_app_id,
                    CMsgClientP2PConnectionFailInfo::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "ep2p_session_error",
                    CMsgClientP2PConnectionFailInfo::has_ep2p_session_error,
                    CMsgClientP2PConnectionFailInfo::get_ep2p_session_error,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientP2PConnectionFailInfo>(
                    "CMsgClientP2PConnectionFailInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientP2PConnectionFailInfo {
    fn clear(&mut self) {
        self.clear_steam_id_dest();
        self.clear_steam_id_src();
        self.clear_app_id();
        self.clear_ep2p_session_error();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientP2PConnectionFailInfo {
    fn eq(&self, other: &CMsgClientP2PConnectionFailInfo) -> bool {
        self.steam_id_dest == other.steam_id_dest &&
        self.steam_id_src == other.steam_id_src &&
        self.app_id == other.app_id &&
        self.ep2p_session_error == other.ep2p_session_error &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientP2PConnectionFailInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetAppOwnershipTicket {
    // message fields
    app_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetAppOwnershipTicket {}

impl CMsgClientGetAppOwnershipTicket {
    pub fn new() -> CMsgClientGetAppOwnershipTicket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetAppOwnershipTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetAppOwnershipTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetAppOwnershipTicket,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetAppOwnershipTicket {
                    app_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetAppOwnershipTicket>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetAppOwnershipTicket {
    fn new() -> CMsgClientGetAppOwnershipTicket {
        CMsgClientGetAppOwnershipTicket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetAppOwnershipTicket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientGetAppOwnershipTicket::has_app_id,
                    CMsgClientGetAppOwnershipTicket::get_app_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetAppOwnershipTicket>(
                    "CMsgClientGetAppOwnershipTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetAppOwnershipTicket {
    fn clear(&mut self) {
        self.clear_app_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetAppOwnershipTicket {
    fn eq(&self, other: &CMsgClientGetAppOwnershipTicket) -> bool {
        self.app_id == other.app_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetAppOwnershipTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetAppOwnershipTicketResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetAppOwnershipTicketResponse {}

impl CMsgClientGetAppOwnershipTicketResponse {
    pub fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetAppOwnershipTicketResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetAppOwnershipTicketResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetAppOwnershipTicketResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetAppOwnershipTicketResponse {
                    eresult: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    ticket: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    // optional uint32 app_id = 2;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional bytes ticket = 3;

    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        };
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_ticket<'a>(&'a self) -> &'a [u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientGetAppOwnershipTicketResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ticket.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.ticket.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetAppOwnershipTicketResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetAppOwnershipTicketResponse {
    fn new() -> CMsgClientGetAppOwnershipTicketResponse {
        CMsgClientGetAppOwnershipTicketResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetAppOwnershipTicketResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "eresult",
                    CMsgClientGetAppOwnershipTicketResponse::has_eresult,
                    CMsgClientGetAppOwnershipTicketResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientGetAppOwnershipTicketResponse::has_app_id,
                    CMsgClientGetAppOwnershipTicketResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "ticket",
                    CMsgClientGetAppOwnershipTicketResponse::has_ticket,
                    CMsgClientGetAppOwnershipTicketResponse::get_ticket,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetAppOwnershipTicketResponse>(
                    "CMsgClientGetAppOwnershipTicketResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetAppOwnershipTicketResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_app_id();
        self.clear_ticket();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetAppOwnershipTicketResponse {
    fn eq(&self, other: &CMsgClientGetAppOwnershipTicketResponse) -> bool {
        self.eresult == other.eresult &&
        self.app_id == other.app_id &&
        self.ticket == other.ticket &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetAppOwnershipTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientSessionToken {
    // message fields
    token: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientSessionToken {}

impl CMsgClientSessionToken {
    pub fn new() -> CMsgClientSessionToken {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientSessionToken {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientSessionToken> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientSessionToken,
        };
        unsafe {
            instance.get(|| {
                CMsgClientSessionToken {
                    token: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint64 token = 1;

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u64) {
        self.token = ::std::option::Option::Some(v);
    }

    pub fn get_token<'a>(&self) -> u64 {
        self.token.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientSessionToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.token.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.token {
            try!(os.write_uint64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientSessionToken>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientSessionToken {
    fn new() -> CMsgClientSessionToken {
        CMsgClientSessionToken::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientSessionToken>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "token",
                    CMsgClientSessionToken::has_token,
                    CMsgClientSessionToken::get_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSessionToken>(
                    "CMsgClientSessionToken",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientSessionToken {
    fn clear(&mut self) {
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientSessionToken {
    fn eq(&self, other: &CMsgClientSessionToken) -> bool {
        self.token == other.token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientSessionToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGameConnectTokens {
    // message fields
    max_tokens_to_keep: ::std::option::Option<u32>,
    tokens: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGameConnectTokens {}

impl CMsgClientGameConnectTokens {
    pub fn new() -> CMsgClientGameConnectTokens {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGameConnectTokens {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGameConnectTokens> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGameConnectTokens,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGameConnectTokens {
                    max_tokens_to_keep: ::std::option::Option::None,
                    tokens: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 max_tokens_to_keep = 1;

    pub fn clear_max_tokens_to_keep(&mut self) {
        self.max_tokens_to_keep = ::std::option::Option::None;
    }

    pub fn has_max_tokens_to_keep(&self) -> bool {
        self.max_tokens_to_keep.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_tokens_to_keep(&mut self, v: u32) {
        self.max_tokens_to_keep = ::std::option::Option::Some(v);
    }

    pub fn get_max_tokens_to_keep<'a>(&self) -> u32 {
        self.max_tokens_to_keep.unwrap_or(10u32)
    }

    // repeated bytes tokens = 2;

    pub fn clear_tokens(&mut self) {
        self.tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tokens<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.tokens
    }

    // Take field
    pub fn take_tokens(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.tokens, ::protobuf::RepeatedField::new())
    }

    pub fn get_tokens<'a>(&'a self) -> &'a [::std::vec::Vec<u8>] {
        &self.tokens
    }
}

impl ::protobuf::Message for CMsgClientGameConnectTokens {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.max_tokens_to_keep = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.tokens));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.max_tokens_to_keep.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tokens.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_tokens_to_keep {
            try!(os.write_uint32(1, v));
        };
        for v in self.tokens.iter() {
            try!(os.write_bytes(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGameConnectTokens>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGameConnectTokens {
    fn new() -> CMsgClientGameConnectTokens {
        CMsgClientGameConnectTokens::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGameConnectTokens>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "max_tokens_to_keep",
                    CMsgClientGameConnectTokens::has_max_tokens_to_keep,
                    CMsgClientGameConnectTokens::get_max_tokens_to_keep,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_bytes_accessor(
                    "tokens",
                    CMsgClientGameConnectTokens::get_tokens,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGameConnectTokens>(
                    "CMsgClientGameConnectTokens",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGameConnectTokens {
    fn clear(&mut self) {
        self.clear_max_tokens_to_keep();
        self.clear_tokens();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGameConnectTokens {
    fn eq(&self, other: &CMsgClientGameConnectTokens) -> bool {
        self.max_tokens_to_keep == other.max_tokens_to_keep &&
        self.tokens == other.tokens &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGameConnectTokens {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSServerType {
    // message fields
    app_id_served: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    game_ip_address: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    game_dir: ::protobuf::SingularField<::std::string::String>,
    game_version: ::protobuf::SingularField<::std::string::String>,
    game_query_port: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSServerType {}

impl CMsgGSServerType {
    pub fn new() -> CMsgGSServerType {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSServerType {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSServerType> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSServerType,
        };
        unsafe {
            instance.get(|| {
                CMsgGSServerType {
                    app_id_served: ::std::option::Option::None,
                    flags: ::std::option::Option::None,
                    game_ip_address: ::std::option::Option::None,
                    game_port: ::std::option::Option::None,
                    game_dir: ::protobuf::SingularField::none(),
                    game_version: ::protobuf::SingularField::none(),
                    game_query_port: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id_served = 1;

    pub fn clear_app_id_served(&mut self) {
        self.app_id_served = ::std::option::Option::None;
    }

    pub fn has_app_id_served(&self) -> bool {
        self.app_id_served.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id_served(&mut self, v: u32) {
        self.app_id_served = ::std::option::Option::Some(v);
    }

    pub fn get_app_id_served<'a>(&self) -> u32 {
        self.app_id_served.unwrap_or(0)
    }

    // optional uint32 flags = 2;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags<'a>(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    // optional uint32 game_ip_address = 3;

    pub fn clear_game_ip_address(&mut self) {
        self.game_ip_address = ::std::option::Option::None;
    }

    pub fn has_game_ip_address(&self) -> bool {
        self.game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip_address(&mut self, v: u32) {
        self.game_ip_address = ::std::option::Option::Some(v);
    }

    pub fn get_game_ip_address<'a>(&self) -> u32 {
        self.game_ip_address.unwrap_or(0)
    }

    // optional uint32 game_port = 4;

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    pub fn get_game_port<'a>(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    // optional string game_dir = 5;

    pub fn clear_game_dir(&mut self) {
        self.game_dir.clear();
    }

    pub fn has_game_dir(&self) -> bool {
        self.game_dir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_dir(&mut self, v: ::std::string::String) {
        self.game_dir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_dir<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.game_dir.is_none() {
            self.game_dir.set_default();
        };
        self.game_dir.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_dir(&mut self) -> ::std::string::String {
        self.game_dir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_dir<'a>(&'a self) -> &'a str {
        match self.game_dir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string game_version = 6;

    pub fn clear_game_version(&mut self) {
        self.game_version.clear();
    }

    pub fn has_game_version(&self) -> bool {
        self.game_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_version(&mut self, v: ::std::string::String) {
        self.game_version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_version<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.game_version.is_none() {
            self.game_version.set_default();
        };
        self.game_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_version(&mut self) -> ::std::string::String {
        self.game_version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_version<'a>(&'a self) -> &'a str {
        match self.game_version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 game_query_port = 7;

    pub fn clear_game_query_port(&mut self) {
        self.game_query_port = ::std::option::Option::None;
    }

    pub fn has_game_query_port(&self) -> bool {
        self.game_query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_query_port(&mut self, v: u32) {
        self.game_query_port = ::std::option::Option::Some(v);
    }

    pub fn get_game_query_port<'a>(&self) -> u32 {
        self.game_query_port.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgGSServerType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id_served = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_ip_address = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_dir));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_version));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_query_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id_served.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_ip_address.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_port.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_dir.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.game_version.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.game_query_port.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id_served {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.flags {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.game_ip_address {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.game_port {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.game_dir.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.game_version.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.game_query_port {
            try!(os.write_uint32(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSServerType>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSServerType {
    fn new() -> CMsgGSServerType {
        CMsgGSServerType::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSServerType>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id_served",
                    CMsgGSServerType::has_app_id_served,
                    CMsgGSServerType::get_app_id_served,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "flags",
                    CMsgGSServerType::has_flags,
                    CMsgGSServerType::get_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_ip_address",
                    CMsgGSServerType::has_game_ip_address,
                    CMsgGSServerType::get_game_ip_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_port",
                    CMsgGSServerType::has_game_port,
                    CMsgGSServerType::get_game_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "game_dir",
                    CMsgGSServerType::has_game_dir,
                    CMsgGSServerType::get_game_dir,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "game_version",
                    CMsgGSServerType::has_game_version,
                    CMsgGSServerType::get_game_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_query_port",
                    CMsgGSServerType::has_game_query_port,
                    CMsgGSServerType::get_game_query_port,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSServerType>(
                    "CMsgGSServerType",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSServerType {
    fn clear(&mut self) {
        self.clear_app_id_served();
        self.clear_flags();
        self.clear_game_ip_address();
        self.clear_game_port();
        self.clear_game_dir();
        self.clear_game_version();
        self.clear_game_query_port();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSServerType {
    fn eq(&self, other: &CMsgGSServerType) -> bool {
        self.app_id_served == other.app_id_served &&
        self.flags == other.flags &&
        self.game_ip_address == other.game_ip_address &&
        self.game_port == other.game_port &&
        self.game_dir == other.game_dir &&
        self.game_version == other.game_version &&
        self.game_query_port == other.game_query_port &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSServerType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSStatusReply {
    // message fields
    is_secure: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSStatusReply {}

impl CMsgGSStatusReply {
    pub fn new() -> CMsgGSStatusReply {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSStatusReply {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSStatusReply> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSStatusReply,
        };
        unsafe {
            instance.get(|| {
                CMsgGSStatusReply {
                    is_secure: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool is_secure = 1;

    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }

    pub fn get_is_secure<'a>(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgGSStatusReply {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_secure = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_secure.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.is_secure {
            try!(os.write_bool(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSStatusReply>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSStatusReply {
    fn new() -> CMsgGSStatusReply {
        CMsgGSStatusReply::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSStatusReply>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_secure",
                    CMsgGSStatusReply::has_is_secure,
                    CMsgGSStatusReply::get_is_secure,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSStatusReply>(
                    "CMsgGSStatusReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSStatusReply {
    fn clear(&mut self) {
        self.clear_is_secure();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSStatusReply {
    fn eq(&self, other: &CMsgGSStatusReply) -> bool {
        self.is_secure == other.is_secure &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSStatusReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSPlayerList {
    // message fields
    players: ::protobuf::RepeatedField<CMsgGSPlayerList_Player>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSPlayerList {}

impl CMsgGSPlayerList {
    pub fn new() -> CMsgGSPlayerList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSPlayerList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSPlayerList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSPlayerList,
        };
        unsafe {
            instance.get(|| {
                CMsgGSPlayerList {
                    players: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgGSPlayerList.Player players = 1;

    pub fn clear_players(&mut self) {
        self.players.clear();
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: ::protobuf::RepeatedField<CMsgGSPlayerList_Player>) {
        self.players = v;
    }

    // Mutable pointer to the field.
    pub fn mut_players<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgGSPlayerList_Player> {
        &mut self.players
    }

    // Take field
    pub fn take_players(&mut self) -> ::protobuf::RepeatedField<CMsgGSPlayerList_Player> {
        ::std::mem::replace(&mut self.players, ::protobuf::RepeatedField::new())
    }

    pub fn get_players<'a>(&'a self) -> &'a [CMsgGSPlayerList_Player] {
        &self.players
    }
}

impl ::protobuf::Message for CMsgGSPlayerList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.players));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.players.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.players.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSPlayerList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSPlayerList {
    fn new() -> CMsgGSPlayerList {
        CMsgGSPlayerList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSPlayerList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "players",
                    CMsgGSPlayerList::get_players,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSPlayerList>(
                    "CMsgGSPlayerList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSPlayerList {
    fn clear(&mut self) {
        self.clear_players();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSPlayerList {
    fn eq(&self, other: &CMsgGSPlayerList) -> bool {
        self.players == other.players &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSPlayerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSPlayerList_Player {
    // message fields
    steam_id: ::std::option::Option<u64>,
    public_ip: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSPlayerList_Player {}

impl CMsgGSPlayerList_Player {
    pub fn new() -> CMsgGSPlayerList_Player {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSPlayerList_Player {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSPlayerList_Player> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSPlayerList_Player,
        };
        unsafe {
            instance.get(|| {
                CMsgGSPlayerList_Player {
                    steam_id: ::std::option::Option::None,
                    public_ip: ::std::option::Option::None,
                    token: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional uint32 public_ip = 2;

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    pub fn get_public_ip<'a>(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    // optional bytes token = 3;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        };
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_token<'a>(&'a self) -> &'a [u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgGSPlayerList_Player {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.steam_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.public_ip.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.token.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.public_ip {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.token.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSPlayerList_Player>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSPlayerList_Player {
    fn new() -> CMsgGSPlayerList_Player {
        CMsgGSPlayerList_Player::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSPlayerList_Player>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgGSPlayerList_Player::has_steam_id,
                    CMsgGSPlayerList_Player::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "public_ip",
                    CMsgGSPlayerList_Player::has_public_ip,
                    CMsgGSPlayerList_Player::get_public_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "token",
                    CMsgGSPlayerList_Player::has_token,
                    CMsgGSPlayerList_Player::get_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSPlayerList_Player>(
                    "CMsgGSPlayerList_Player",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSPlayerList_Player {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_public_ip();
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSPlayerList_Player {
    fn eq(&self, other: &CMsgGSPlayerList_Player) -> bool {
        self.steam_id == other.steam_id &&
        self.public_ip == other.public_ip &&
        self.token == other.token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSPlayerList_Player {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSUserPlaying {
    // message fields
    steam_id: ::std::option::Option<u64>,
    public_ip: ::std::option::Option<u32>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSUserPlaying {}

impl CMsgGSUserPlaying {
    pub fn new() -> CMsgGSUserPlaying {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSUserPlaying {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSUserPlaying> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSUserPlaying,
        };
        unsafe {
            instance.get(|| {
                CMsgGSUserPlaying {
                    steam_id: ::std::option::Option::None,
                    public_ip: ::std::option::Option::None,
                    token: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional uint32 public_ip = 2;

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    pub fn get_public_ip<'a>(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    // optional bytes token = 3;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        };
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_token<'a>(&'a self) -> &'a [u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgGSUserPlaying {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        for value in self.public_ip.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.token.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.public_ip {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.token.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSUserPlaying>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSUserPlaying {
    fn new() -> CMsgGSUserPlaying {
        CMsgGSUserPlaying::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSUserPlaying>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgGSUserPlaying::has_steam_id,
                    CMsgGSUserPlaying::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "public_ip",
                    CMsgGSUserPlaying::has_public_ip,
                    CMsgGSUserPlaying::get_public_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "token",
                    CMsgGSUserPlaying::has_token,
                    CMsgGSUserPlaying::get_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSUserPlaying>(
                    "CMsgGSUserPlaying",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSUserPlaying {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_public_ip();
        self.clear_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSUserPlaying {
    fn eq(&self, other: &CMsgGSUserPlaying) -> bool {
        self.steam_id == other.steam_id &&
        self.public_ip == other.public_ip &&
        self.token == other.token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSUserPlaying {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSDisconnectNotice {
    // message fields
    steam_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSDisconnectNotice {}

impl CMsgGSDisconnectNotice {
    pub fn new() -> CMsgGSDisconnectNotice {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSDisconnectNotice {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSDisconnectNotice> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSDisconnectNotice,
        };
        unsafe {
            instance.get(|| {
                CMsgGSDisconnectNotice {
                    steam_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgGSDisconnectNotice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSDisconnectNotice>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSDisconnectNotice {
    fn new() -> CMsgGSDisconnectNotice {
        CMsgGSDisconnectNotice::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSDisconnectNotice>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgGSDisconnectNotice::has_steam_id,
                    CMsgGSDisconnectNotice::get_steam_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSDisconnectNotice>(
                    "CMsgGSDisconnectNotice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSDisconnectNotice {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSDisconnectNotice {
    fn eq(&self, other: &CMsgGSDisconnectNotice) -> bool {
        self.steam_id == other.steam_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSDisconnectNotice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGamesPlayed {
    // message fields
    games_played: ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed>,
    client_os_type: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGamesPlayed {}

impl CMsgClientGamesPlayed {
    pub fn new() -> CMsgClientGamesPlayed {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGamesPlayed {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGamesPlayed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGamesPlayed,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGamesPlayed {
                    games_played: ::protobuf::RepeatedField::new(),
                    client_os_type: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientGamesPlayed.GamePlayed games_played = 1;

    pub fn clear_games_played(&mut self) {
        self.games_played.clear();
    }

    // Param is passed by value, moved
    pub fn set_games_played(&mut self, v: ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed>) {
        self.games_played = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games_played<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed> {
        &mut self.games_played
    }

    // Take field
    pub fn take_games_played(&mut self) -> ::protobuf::RepeatedField<CMsgClientGamesPlayed_GamePlayed> {
        ::std::mem::replace(&mut self.games_played, ::protobuf::RepeatedField::new())
    }

    pub fn get_games_played<'a>(&'a self) -> &'a [CMsgClientGamesPlayed_GamePlayed] {
        &self.games_played
    }

    // optional uint32 client_os_type = 2;

    pub fn clear_client_os_type(&mut self) {
        self.client_os_type = ::std::option::Option::None;
    }

    pub fn has_client_os_type(&self) -> bool {
        self.client_os_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_os_type(&mut self, v: u32) {
        self.client_os_type = ::std::option::Option::Some(v);
    }

    pub fn get_client_os_type<'a>(&self) -> u32 {
        self.client_os_type.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games_played));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.client_os_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.games_played.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.client_os_type.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.games_played.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.client_os_type {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGamesPlayed>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGamesPlayed {
    fn new() -> CMsgClientGamesPlayed {
        CMsgClientGamesPlayed::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGamesPlayed>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "games_played",
                    CMsgClientGamesPlayed::get_games_played,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "client_os_type",
                    CMsgClientGamesPlayed::has_client_os_type,
                    CMsgClientGamesPlayed::get_client_os_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGamesPlayed>(
                    "CMsgClientGamesPlayed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGamesPlayed {
    fn clear(&mut self) {
        self.clear_games_played();
        self.clear_client_os_type();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGamesPlayed {
    fn eq(&self, other: &CMsgClientGamesPlayed) -> bool {
        self.games_played == other.games_played &&
        self.client_os_type == other.client_os_type &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGamesPlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGamesPlayed_GamePlayed {
    // message fields
    steam_id_gs: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    game_ip_address: ::std::option::Option<u32>,
    game_port: ::std::option::Option<u32>,
    is_secure: ::std::option::Option<bool>,
    token: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    game_extra_info: ::protobuf::SingularField<::std::string::String>,
    game_data_blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    process_id: ::std::option::Option<u32>,
    streaming_provider_id: ::std::option::Option<u32>,
    game_flags: ::std::option::Option<u32>,
    owner_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGamesPlayed_GamePlayed {}

impl CMsgClientGamesPlayed_GamePlayed {
    pub fn new() -> CMsgClientGamesPlayed_GamePlayed {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGamesPlayed_GamePlayed {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGamesPlayed_GamePlayed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGamesPlayed_GamePlayed,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGamesPlayed_GamePlayed {
                    steam_id_gs: ::std::option::Option::None,
                    game_id: ::std::option::Option::None,
                    game_ip_address: ::std::option::Option::None,
                    game_port: ::std::option::Option::None,
                    is_secure: ::std::option::Option::None,
                    token: ::protobuf::SingularField::none(),
                    game_extra_info: ::protobuf::SingularField::none(),
                    game_data_blob: ::protobuf::SingularField::none(),
                    process_id: ::std::option::Option::None,
                    streaming_provider_id: ::std::option::Option::None,
                    game_flags: ::std::option::Option::None,
                    owner_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint64 steam_id_gs = 1;

    pub fn clear_steam_id_gs(&mut self) {
        self.steam_id_gs = ::std::option::Option::None;
    }

    pub fn has_steam_id_gs(&self) -> bool {
        self.steam_id_gs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_gs(&mut self, v: u64) {
        self.steam_id_gs = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_gs<'a>(&self) -> u64 {
        self.steam_id_gs.unwrap_or(0)
    }

    // optional fixed64 game_id = 2;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional uint32 game_ip_address = 3;

    pub fn clear_game_ip_address(&mut self) {
        self.game_ip_address = ::std::option::Option::None;
    }

    pub fn has_game_ip_address(&self) -> bool {
        self.game_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_ip_address(&mut self, v: u32) {
        self.game_ip_address = ::std::option::Option::Some(v);
    }

    pub fn get_game_ip_address<'a>(&self) -> u32 {
        self.game_ip_address.unwrap_or(0)
    }

    // optional uint32 game_port = 4;

    pub fn clear_game_port(&mut self) {
        self.game_port = ::std::option::Option::None;
    }

    pub fn has_game_port(&self) -> bool {
        self.game_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_port(&mut self, v: u32) {
        self.game_port = ::std::option::Option::Some(v);
    }

    pub fn get_game_port<'a>(&self) -> u32 {
        self.game_port.unwrap_or(0)
    }

    // optional bool is_secure = 5;

    pub fn clear_is_secure(&mut self) {
        self.is_secure = ::std::option::Option::None;
    }

    pub fn has_is_secure(&self) -> bool {
        self.is_secure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_secure(&mut self, v: bool) {
        self.is_secure = ::std::option::Option::Some(v);
    }

    pub fn get_is_secure<'a>(&self) -> bool {
        self.is_secure.unwrap_or(false)
    }

    // optional bytes token = 6;

    pub fn clear_token(&mut self) {
        self.token.clear();
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: ::std::vec::Vec<u8>) {
        self.token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_token<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.token.is_none() {
            self.token.set_default();
        };
        self.token.as_mut().unwrap()
    }

    // Take field
    pub fn take_token(&mut self) -> ::std::vec::Vec<u8> {
        self.token.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_token<'a>(&'a self) -> &'a [u8] {
        match self.token.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string game_extra_info = 7;

    pub fn clear_game_extra_info(&mut self) {
        self.game_extra_info.clear();
    }

    pub fn has_game_extra_info(&self) -> bool {
        self.game_extra_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_extra_info(&mut self, v: ::std::string::String) {
        self.game_extra_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_extra_info<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.game_extra_info.is_none() {
            self.game_extra_info.set_default();
        };
        self.game_extra_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_extra_info(&mut self) -> ::std::string::String {
        self.game_extra_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_extra_info<'a>(&'a self) -> &'a str {
        match self.game_extra_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes game_data_blob = 8;

    pub fn clear_game_data_blob(&mut self) {
        self.game_data_blob.clear();
    }

    pub fn has_game_data_blob(&self) -> bool {
        self.game_data_blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data_blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data_blob<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.game_data_blob.is_none() {
            self.game_data_blob.set_default();
        };
        self.game_data_blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_game_data_blob<'a>(&'a self) -> &'a [u8] {
        match self.game_data_blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 process_id = 9;

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    pub fn get_process_id<'a>(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    // optional uint32 streaming_provider_id = 10;

    pub fn clear_streaming_provider_id(&mut self) {
        self.streaming_provider_id = ::std::option::Option::None;
    }

    pub fn has_streaming_provider_id(&self) -> bool {
        self.streaming_provider_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streaming_provider_id(&mut self, v: u32) {
        self.streaming_provider_id = ::std::option::Option::Some(v);
    }

    pub fn get_streaming_provider_id<'a>(&self) -> u32 {
        self.streaming_provider_id.unwrap_or(0)
    }

    // optional uint32 game_flags = 11;

    pub fn clear_game_flags(&mut self) {
        self.game_flags = ::std::option::Option::None;
    }

    pub fn has_game_flags(&self) -> bool {
        self.game_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_flags(&mut self, v: u32) {
        self.game_flags = ::std::option::Option::Some(v);
    }

    pub fn get_game_flags<'a>(&self) -> u32 {
        self.game_flags.unwrap_or(0)
    }

    // optional uint32 owner_id = 12;

    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: u32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_id<'a>(&self) -> u32 {
        self.owner_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGamesPlayed_GamePlayed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.steam_id_gs = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_ip_address = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_secure = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.token));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_extra_info));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data_blob));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.process_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.streaming_provider_id = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_flags = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.owner_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.steam_id_gs.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.game_id.is_some() {
            my_size += 9;
        };
        for value in self.game_ip_address.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_port.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_secure.is_some() {
            my_size += 2;
        };
        for value in self.token.iter() {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        for value in self.game_extra_info.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.game_data_blob.iter() {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        for value in self.process_id.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.streaming_provider_id.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_flags.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.owner_id.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_gs {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.game_ip_address {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.game_port {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.is_secure {
            try!(os.write_bool(5, v));
        };
        if let Some(v) = self.token.as_ref() {
            try!(os.write_bytes(6, &v));
        };
        if let Some(v) = self.game_extra_info.as_ref() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.game_data_blob.as_ref() {
            try!(os.write_bytes(8, &v));
        };
        if let Some(v) = self.process_id {
            try!(os.write_uint32(9, v));
        };
        if let Some(v) = self.streaming_provider_id {
            try!(os.write_uint32(10, v));
        };
        if let Some(v) = self.game_flags {
            try!(os.write_uint32(11, v));
        };
        if let Some(v) = self.owner_id {
            try!(os.write_uint32(12, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGamesPlayed_GamePlayed>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGamesPlayed_GamePlayed {
    fn new() -> CMsgClientGamesPlayed_GamePlayed {
        CMsgClientGamesPlayed_GamePlayed::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGamesPlayed_GamePlayed>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_gs",
                    CMsgClientGamesPlayed_GamePlayed::has_steam_id_gs,
                    CMsgClientGamesPlayed_GamePlayed::get_steam_id_gs,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientGamesPlayed_GamePlayed::has_game_id,
                    CMsgClientGamesPlayed_GamePlayed::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_ip_address",
                    CMsgClientGamesPlayed_GamePlayed::has_game_ip_address,
                    CMsgClientGamesPlayed_GamePlayed::get_game_ip_address,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_port",
                    CMsgClientGamesPlayed_GamePlayed::has_game_port,
                    CMsgClientGamesPlayed_GamePlayed::get_game_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_secure",
                    CMsgClientGamesPlayed_GamePlayed::has_is_secure,
                    CMsgClientGamesPlayed_GamePlayed::get_is_secure,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "token",
                    CMsgClientGamesPlayed_GamePlayed::has_token,
                    CMsgClientGamesPlayed_GamePlayed::get_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "game_extra_info",
                    CMsgClientGamesPlayed_GamePlayed::has_game_extra_info,
                    CMsgClientGamesPlayed_GamePlayed::get_game_extra_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "game_data_blob",
                    CMsgClientGamesPlayed_GamePlayed::has_game_data_blob,
                    CMsgClientGamesPlayed_GamePlayed::get_game_data_blob,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "process_id",
                    CMsgClientGamesPlayed_GamePlayed::has_process_id,
                    CMsgClientGamesPlayed_GamePlayed::get_process_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "streaming_provider_id",
                    CMsgClientGamesPlayed_GamePlayed::has_streaming_provider_id,
                    CMsgClientGamesPlayed_GamePlayed::get_streaming_provider_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_flags",
                    CMsgClientGamesPlayed_GamePlayed::has_game_flags,
                    CMsgClientGamesPlayed_GamePlayed::get_game_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "owner_id",
                    CMsgClientGamesPlayed_GamePlayed::has_owner_id,
                    CMsgClientGamesPlayed_GamePlayed::get_owner_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGamesPlayed_GamePlayed>(
                    "CMsgClientGamesPlayed_GamePlayed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGamesPlayed_GamePlayed {
    fn clear(&mut self) {
        self.clear_steam_id_gs();
        self.clear_game_id();
        self.clear_game_ip_address();
        self.clear_game_port();
        self.clear_is_secure();
        self.clear_token();
        self.clear_game_extra_info();
        self.clear_game_data_blob();
        self.clear_process_id();
        self.clear_streaming_provider_id();
        self.clear_game_flags();
        self.clear_owner_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGamesPlayed_GamePlayed {
    fn eq(&self, other: &CMsgClientGamesPlayed_GamePlayed) -> bool {
        self.steam_id_gs == other.steam_id_gs &&
        self.game_id == other.game_id &&
        self.game_ip_address == other.game_ip_address &&
        self.game_port == other.game_port &&
        self.is_secure == other.is_secure &&
        self.token == other.token &&
        self.game_extra_info == other.game_extra_info &&
        self.game_data_blob == other.game_data_blob &&
        self.process_id == other.process_id &&
        self.streaming_provider_id == other.streaming_provider_id &&
        self.game_flags == other.game_flags &&
        self.owner_id == other.owner_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGamesPlayed_GamePlayed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSApprove {
    // message fields
    steam_id: ::std::option::Option<u64>,
    owner_steam_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSApprove {}

impl CMsgGSApprove {
    pub fn new() -> CMsgGSApprove {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSApprove {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSApprove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSApprove,
        };
        unsafe {
            instance.get(|| {
                CMsgGSApprove {
                    steam_id: ::std::option::Option::None,
                    owner_steam_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional fixed64 owner_steam_id = 2;

    pub fn clear_owner_steam_id(&mut self) {
        self.owner_steam_id = ::std::option::Option::None;
    }

    pub fn has_owner_steam_id(&self) -> bool {
        self.owner_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_steam_id(&mut self, v: u64) {
        self.owner_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_steam_id<'a>(&self) -> u64 {
        self.owner_steam_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgGSApprove {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.owner_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        if self.owner_steam_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.owner_steam_id {
            try!(os.write_fixed64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSApprove>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSApprove {
    fn new() -> CMsgGSApprove {
        CMsgGSApprove::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSApprove>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgGSApprove::has_steam_id,
                    CMsgGSApprove::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "owner_steam_id",
                    CMsgGSApprove::has_owner_steam_id,
                    CMsgGSApprove::get_owner_steam_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSApprove>(
                    "CMsgGSApprove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSApprove {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_owner_steam_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSApprove {
    fn eq(&self, other: &CMsgGSApprove) -> bool {
        self.steam_id == other.steam_id &&
        self.owner_steam_id == other.owner_steam_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSApprove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSDeny {
    // message fields
    steam_id: ::std::option::Option<u64>,
    edeny_reason: ::std::option::Option<i32>,
    deny_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSDeny {}

impl CMsgGSDeny {
    pub fn new() -> CMsgGSDeny {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSDeny {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSDeny> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSDeny,
        };
        unsafe {
            instance.get(|| {
                CMsgGSDeny {
                    steam_id: ::std::option::Option::None,
                    edeny_reason: ::std::option::Option::None,
                    deny_string: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional int32 edeny_reason = 2;

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    pub fn get_edeny_reason<'a>(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }

    // optional string deny_string = 3;

    pub fn clear_deny_string(&mut self) {
        self.deny_string.clear();
    }

    pub fn has_deny_string(&self) -> bool {
        self.deny_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_string(&mut self, v: ::std::string::String) {
        self.deny_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_string<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.deny_string.is_none() {
            self.deny_string.set_default();
        };
        self.deny_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_string(&mut self) -> ::std::string::String {
        self.deny_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_deny_string<'a>(&'a self) -> &'a str {
        match self.deny_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgGSDeny {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.edeny_reason = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.deny_string));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        for value in self.edeny_reason.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.deny_string.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.edeny_reason {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.deny_string.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSDeny>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSDeny {
    fn new() -> CMsgGSDeny {
        CMsgGSDeny::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSDeny>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgGSDeny::has_steam_id,
                    CMsgGSDeny::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "edeny_reason",
                    CMsgGSDeny::has_edeny_reason,
                    CMsgGSDeny::get_edeny_reason,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "deny_string",
                    CMsgGSDeny::has_deny_string,
                    CMsgGSDeny::get_deny_string,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSDeny>(
                    "CMsgGSDeny",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSDeny {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_edeny_reason();
        self.clear_deny_string();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSDeny {
    fn eq(&self, other: &CMsgGSDeny) -> bool {
        self.steam_id == other.steam_id &&
        self.edeny_reason == other.edeny_reason &&
        self.deny_string == other.deny_string &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSDeny {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgGSKick {
    // message fields
    steam_id: ::std::option::Option<u64>,
    edeny_reason: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgGSKick {}

impl CMsgGSKick {
    pub fn new() -> CMsgGSKick {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgGSKick {
        static mut instance: ::protobuf::lazy::Lazy<CMsgGSKick> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgGSKick,
        };
        unsafe {
            instance.get(|| {
                CMsgGSKick {
                    steam_id: ::std::option::Option::None,
                    edeny_reason: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional int32 edeny_reason = 2;

    pub fn clear_edeny_reason(&mut self) {
        self.edeny_reason = ::std::option::Option::None;
    }

    pub fn has_edeny_reason(&self) -> bool {
        self.edeny_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edeny_reason(&mut self, v: i32) {
        self.edeny_reason = ::std::option::Option::Some(v);
    }

    pub fn get_edeny_reason<'a>(&self) -> i32 {
        self.edeny_reason.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgGSKick {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.edeny_reason = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        for value in self.edeny_reason.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.edeny_reason {
            try!(os.write_int32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgGSKick>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgGSKick {
    fn new() -> CMsgGSKick {
        CMsgGSKick::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgGSKick>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgGSKick::has_steam_id,
                    CMsgGSKick::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "edeny_reason",
                    CMsgGSKick::has_edeny_reason,
                    CMsgGSKick::get_edeny_reason,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgGSKick>(
                    "CMsgGSKick",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgGSKick {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_edeny_reason();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgGSKick {
    fn eq(&self, other: &CMsgGSKick) -> bool {
        self.steam_id == other.steam_id &&
        self.edeny_reason == other.edeny_reason &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgGSKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAuthList {
    // message fields
    tokens_left: ::std::option::Option<u32>,
    last_request_seq: ::std::option::Option<u32>,
    last_request_seq_from_server: ::std::option::Option<u32>,
    tickets: ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket>,
    app_ids: ::std::vec::Vec<u32>,
    message_sequence: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAuthList {}

impl CMsgClientAuthList {
    pub fn new() -> CMsgClientAuthList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAuthList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAuthList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAuthList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAuthList {
                    tokens_left: ::std::option::Option::None,
                    last_request_seq: ::std::option::Option::None,
                    last_request_seq_from_server: ::std::option::Option::None,
                    tickets: ::protobuf::RepeatedField::new(),
                    app_ids: ::std::vec::Vec::new(),
                    message_sequence: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 tokens_left = 1;

    pub fn clear_tokens_left(&mut self) {
        self.tokens_left = ::std::option::Option::None;
    }

    pub fn has_tokens_left(&self) -> bool {
        self.tokens_left.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens_left(&mut self, v: u32) {
        self.tokens_left = ::std::option::Option::Some(v);
    }

    pub fn get_tokens_left<'a>(&self) -> u32 {
        self.tokens_left.unwrap_or(0)
    }

    // optional uint32 last_request_seq = 2;

    pub fn clear_last_request_seq(&mut self) {
        self.last_request_seq = ::std::option::Option::None;
    }

    pub fn has_last_request_seq(&self) -> bool {
        self.last_request_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq(&mut self, v: u32) {
        self.last_request_seq = ::std::option::Option::Some(v);
    }

    pub fn get_last_request_seq<'a>(&self) -> u32 {
        self.last_request_seq.unwrap_or(0)
    }

    // optional uint32 last_request_seq_from_server = 3;

    pub fn clear_last_request_seq_from_server(&mut self) {
        self.last_request_seq_from_server = ::std::option::Option::None;
    }

    pub fn has_last_request_seq_from_server(&self) -> bool {
        self.last_request_seq_from_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_request_seq_from_server(&mut self, v: u32) {
        self.last_request_seq_from_server = ::std::option::Option::Some(v);
    }

    pub fn get_last_request_seq_from_server<'a>(&self) -> u32 {
        self.last_request_seq_from_server.unwrap_or(0)
    }

    // repeated .CMsgAuthTicket tickets = 4;

    pub fn clear_tickets(&mut self) {
        self.tickets.clear();
    }

    // Param is passed by value, moved
    pub fn set_tickets(&mut self, v: ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket>) {
        self.tickets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tickets<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket> {
        &mut self.tickets
    }

    // Take field
    pub fn take_tickets(&mut self) -> ::protobuf::RepeatedField<super::steammessages_base::CMsgAuthTicket> {
        ::std::mem::replace(&mut self.tickets, ::protobuf::RepeatedField::new())
    }

    pub fn get_tickets<'a>(&'a self) -> &'a [super::steammessages_base::CMsgAuthTicket] {
        &self.tickets
    }

    // repeated uint32 app_ids = 5;

    pub fn clear_app_ids(&mut self) {
        self.app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_ids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.app_ids
    }

    // Take field
    pub fn take_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_ids, ::std::vec::Vec::new())
    }

    pub fn get_app_ids<'a>(&'a self) -> &'a [u32] {
        &self.app_ids
    }

    // optional uint32 message_sequence = 6;

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    pub fn get_message_sequence<'a>(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAuthList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.tokens_left = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_request_seq = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_request_seq_from_server = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tickets));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_ids));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.message_sequence = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.tokens_left.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.last_request_seq.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.last_request_seq_from_server.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.tickets.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.app_ids.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.message_sequence.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.tokens_left {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.last_request_seq {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.last_request_seq_from_server {
            try!(os.write_uint32(3, v));
        };
        for v in self.tickets.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.app_ids.iter() {
            try!(os.write_uint32(5, *v));
        };
        if let Some(v) = self.message_sequence {
            try!(os.write_uint32(6, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAuthList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAuthList {
    fn new() -> CMsgClientAuthList {
        CMsgClientAuthList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAuthList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "tokens_left",
                    CMsgClientAuthList::has_tokens_left,
                    CMsgClientAuthList::get_tokens_left,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_request_seq",
                    CMsgClientAuthList::has_last_request_seq,
                    CMsgClientAuthList::get_last_request_seq,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_request_seq_from_server",
                    CMsgClientAuthList::has_last_request_seq_from_server,
                    CMsgClientAuthList::get_last_request_seq_from_server,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "tickets",
                    CMsgClientAuthList::get_tickets,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "app_ids",
                    CMsgClientAuthList::get_app_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "message_sequence",
                    CMsgClientAuthList::has_message_sequence,
                    CMsgClientAuthList::get_message_sequence,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthList>(
                    "CMsgClientAuthList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAuthList {
    fn clear(&mut self) {
        self.clear_tokens_left();
        self.clear_last_request_seq();
        self.clear_last_request_seq_from_server();
        self.clear_tickets();
        self.clear_app_ids();
        self.clear_message_sequence();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAuthList {
    fn eq(&self, other: &CMsgClientAuthList) -> bool {
        self.tokens_left == other.tokens_left &&
        self.last_request_seq == other.last_request_seq &&
        self.last_request_seq_from_server == other.last_request_seq_from_server &&
        self.tickets == other.tickets &&
        self.app_ids == other.app_ids &&
        self.message_sequence == other.message_sequence &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAuthList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAuthListAck {
    // message fields
    ticket_crc: ::std::vec::Vec<u32>,
    app_ids: ::std::vec::Vec<u32>,
    message_sequence: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAuthListAck {}

impl CMsgClientAuthListAck {
    pub fn new() -> CMsgClientAuthListAck {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAuthListAck {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAuthListAck> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAuthListAck,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAuthListAck {
                    ticket_crc: ::std::vec::Vec::new(),
                    app_ids: ::std::vec::Vec::new(),
                    message_sequence: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 ticket_crc = 1;

    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc.clear();
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: ::std::vec::Vec<u32>) {
        self.ticket_crc = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ticket_crc<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.ticket_crc
    }

    // Take field
    pub fn take_ticket_crc(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.ticket_crc, ::std::vec::Vec::new())
    }

    pub fn get_ticket_crc<'a>(&'a self) -> &'a [u32] {
        &self.ticket_crc
    }

    // repeated uint32 app_ids = 2;

    pub fn clear_app_ids(&mut self) {
        self.app_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_ids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.app_ids
    }

    // Take field
    pub fn take_app_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_ids, ::std::vec::Vec::new())
    }

    pub fn get_app_ids<'a>(&'a self) -> &'a [u32] {
        &self.app_ids
    }

    // optional uint32 message_sequence = 3;

    pub fn clear_message_sequence(&mut self) {
        self.message_sequence = ::std::option::Option::None;
    }

    pub fn has_message_sequence(&self) -> bool {
        self.message_sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_sequence(&mut self, v: u32) {
        self.message_sequence = ::std::option::Option::Some(v);
    }

    pub fn get_message_sequence<'a>(&self) -> u32 {
        self.message_sequence.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAuthListAck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.ticket_crc));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_ids));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.message_sequence = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.ticket_crc.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_ids.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.message_sequence.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.ticket_crc.iter() {
            try!(os.write_uint32(1, *v));
        };
        for v in self.app_ids.iter() {
            try!(os.write_uint32(2, *v));
        };
        if let Some(v) = self.message_sequence {
            try!(os.write_uint32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAuthListAck>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAuthListAck {
    fn new() -> CMsgClientAuthListAck {
        CMsgClientAuthListAck::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAuthListAck>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "ticket_crc",
                    CMsgClientAuthListAck::get_ticket_crc,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "app_ids",
                    CMsgClientAuthListAck::get_app_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "message_sequence",
                    CMsgClientAuthListAck::has_message_sequence,
                    CMsgClientAuthListAck::get_message_sequence,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAuthListAck>(
                    "CMsgClientAuthListAck",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAuthListAck {
    fn clear(&mut self) {
        self.clear_ticket_crc();
        self.clear_app_ids();
        self.clear_message_sequence();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAuthListAck {
    fn eq(&self, other: &CMsgClientAuthListAck) -> bool {
        self.ticket_crc == other.ticket_crc &&
        self.app_ids == other.app_ids &&
        self.message_sequence == other.message_sequence &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAuthListAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendsList {
    // message fields
    bincremental: ::std::option::Option<bool>,
    friends: ::protobuf::RepeatedField<CMsgClientFriendsList_Friend>,
    max_friend_count: ::std::option::Option<u32>,
    active_friend_count: ::std::option::Option<u32>,
    friends_limit_hit: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendsList {}

impl CMsgClientFriendsList {
    pub fn new() -> CMsgClientFriendsList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendsList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendsList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendsList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendsList {
                    bincremental: ::std::option::Option::None,
                    friends: ::protobuf::RepeatedField::new(),
                    max_friend_count: ::std::option::Option::None,
                    active_friend_count: ::std::option::Option::None,
                    friends_limit_hit: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool bincremental = 1;

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    pub fn get_bincremental<'a>(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    // repeated .CMsgClientFriendsList.Friend friends = 2;

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CMsgClientFriendsList_Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientFriendsList_Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CMsgClientFriendsList_Friend> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }

    pub fn get_friends<'a>(&'a self) -> &'a [CMsgClientFriendsList_Friend] {
        &self.friends
    }

    // optional uint32 max_friend_count = 3;

    pub fn clear_max_friend_count(&mut self) {
        self.max_friend_count = ::std::option::Option::None;
    }

    pub fn has_max_friend_count(&self) -> bool {
        self.max_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_friend_count(&mut self, v: u32) {
        self.max_friend_count = ::std::option::Option::Some(v);
    }

    pub fn get_max_friend_count<'a>(&self) -> u32 {
        self.max_friend_count.unwrap_or(0)
    }

    // optional uint32 active_friend_count = 4;

    pub fn clear_active_friend_count(&mut self) {
        self.active_friend_count = ::std::option::Option::None;
    }

    pub fn has_active_friend_count(&self) -> bool {
        self.active_friend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_friend_count(&mut self, v: u32) {
        self.active_friend_count = ::std::option::Option::Some(v);
    }

    pub fn get_active_friend_count<'a>(&self) -> u32 {
        self.active_friend_count.unwrap_or(0)
    }

    // optional bool friends_limit_hit = 5;

    pub fn clear_friends_limit_hit(&mut self) {
        self.friends_limit_hit = ::std::option::Option::None;
    }

    pub fn has_friends_limit_hit(&self) -> bool {
        self.friends_limit_hit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friends_limit_hit(&mut self, v: bool) {
        self.friends_limit_hit = ::std::option::Option::Some(v);
    }

    pub fn get_friends_limit_hit<'a>(&self) -> bool {
        self.friends_limit_hit.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientFriendsList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bincremental = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.max_friend_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.active_friend_count = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.friends_limit_hit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bincremental.is_some() {
            my_size += 2;
        };
        for value in self.friends.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.max_friend_count.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.active_friend_count.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.friends_limit_hit.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bincremental {
            try!(os.write_bool(1, v));
        };
        for v in self.friends.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.max_friend_count {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.active_friend_count {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.friends_limit_hit {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendsList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendsList {
    fn new() -> CMsgClientFriendsList {
        CMsgClientFriendsList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendsList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bincremental",
                    CMsgClientFriendsList::has_bincremental,
                    CMsgClientFriendsList::get_bincremental,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "friends",
                    CMsgClientFriendsList::get_friends,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "max_friend_count",
                    CMsgClientFriendsList::has_max_friend_count,
                    CMsgClientFriendsList::get_max_friend_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "active_friend_count",
                    CMsgClientFriendsList::has_active_friend_count,
                    CMsgClientFriendsList::get_active_friend_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "friends_limit_hit",
                    CMsgClientFriendsList::has_friends_limit_hit,
                    CMsgClientFriendsList::get_friends_limit_hit,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsList>(
                    "CMsgClientFriendsList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendsList {
    fn clear(&mut self) {
        self.clear_bincremental();
        self.clear_friends();
        self.clear_max_friend_count();
        self.clear_active_friend_count();
        self.clear_friends_limit_hit();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendsList {
    fn eq(&self, other: &CMsgClientFriendsList) -> bool {
        self.bincremental == other.bincremental &&
        self.friends == other.friends &&
        self.max_friend_count == other.max_friend_count &&
        self.active_friend_count == other.active_friend_count &&
        self.friends_limit_hit == other.friends_limit_hit &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendsList_Friend {
    // message fields
    ulfriendid: ::std::option::Option<u64>,
    efriendrelationship: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendsList_Friend {}

impl CMsgClientFriendsList_Friend {
    pub fn new() -> CMsgClientFriendsList_Friend {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendsList_Friend {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendsList_Friend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendsList_Friend,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendsList_Friend {
                    ulfriendid: ::std::option::Option::None,
                    efriendrelationship: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 ulfriendid = 1;

    pub fn clear_ulfriendid(&mut self) {
        self.ulfriendid = ::std::option::Option::None;
    }

    pub fn has_ulfriendid(&self) -> bool {
        self.ulfriendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ulfriendid(&mut self, v: u64) {
        self.ulfriendid = ::std::option::Option::Some(v);
    }

    pub fn get_ulfriendid<'a>(&self) -> u64 {
        self.ulfriendid.unwrap_or(0)
    }

    // optional uint32 efriendrelationship = 2;

    pub fn clear_efriendrelationship(&mut self) {
        self.efriendrelationship = ::std::option::Option::None;
    }

    pub fn has_efriendrelationship(&self) -> bool {
        self.efriendrelationship.is_some()
    }

    // Param is passed by value, moved
    pub fn set_efriendrelationship(&mut self, v: u32) {
        self.efriendrelationship = ::std::option::Option::Some(v);
    }

    pub fn get_efriendrelationship<'a>(&self) -> u32 {
        self.efriendrelationship.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientFriendsList_Friend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.ulfriendid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.efriendrelationship = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ulfriendid.is_some() {
            my_size += 9;
        };
        for value in self.efriendrelationship.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ulfriendid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.efriendrelationship {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendsList_Friend>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendsList_Friend {
    fn new() -> CMsgClientFriendsList_Friend {
        CMsgClientFriendsList_Friend::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendsList_Friend>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ulfriendid",
                    CMsgClientFriendsList_Friend::has_ulfriendid,
                    CMsgClientFriendsList_Friend::get_ulfriendid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "efriendrelationship",
                    CMsgClientFriendsList_Friend::has_efriendrelationship,
                    CMsgClientFriendsList_Friend::get_efriendrelationship,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsList_Friend>(
                    "CMsgClientFriendsList_Friend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendsList_Friend {
    fn clear(&mut self) {
        self.clear_ulfriendid();
        self.clear_efriendrelationship();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendsList_Friend {
    fn eq(&self, other: &CMsgClientFriendsList_Friend) -> bool {
        self.ulfriendid == other.ulfriendid &&
        self.efriendrelationship == other.efriendrelationship &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsList_Friend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendsGroupsList {
    // message fields
    bremoval: ::std::option::Option<bool>,
    bincremental: ::std::option::Option<bool>,
    friendGroups: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup>,
    memberships: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendsGroupsList {}

impl CMsgClientFriendsGroupsList {
    pub fn new() -> CMsgClientFriendsGroupsList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendsGroupsList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendsGroupsList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendsGroupsList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendsGroupsList {
                    bremoval: ::std::option::Option::None,
                    bincremental: ::std::option::Option::None,
                    friendGroups: ::protobuf::RepeatedField::new(),
                    memberships: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool bremoval = 1;

    pub fn clear_bremoval(&mut self) {
        self.bremoval = ::std::option::Option::None;
    }

    pub fn has_bremoval(&self) -> bool {
        self.bremoval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bremoval(&mut self, v: bool) {
        self.bremoval = ::std::option::Option::Some(v);
    }

    pub fn get_bremoval<'a>(&self) -> bool {
        self.bremoval.unwrap_or(false)
    }

    // optional bool bincremental = 2;

    pub fn clear_bincremental(&mut self) {
        self.bincremental = ::std::option::Option::None;
    }

    pub fn has_bincremental(&self) -> bool {
        self.bincremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bincremental(&mut self, v: bool) {
        self.bincremental = ::std::option::Option::Some(v);
    }

    pub fn get_bincremental<'a>(&self) -> bool {
        self.bincremental.unwrap_or(false)
    }

    // repeated .CMsgClientFriendsGroupsList.FriendGroup friendGroups = 3;

    pub fn clear_friendGroups(&mut self) {
        self.friendGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_friendGroups(&mut self, v: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup>) {
        self.friendGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friendGroups<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup> {
        &mut self.friendGroups
    }

    // Take field
    pub fn take_friendGroups(&mut self) -> ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroup> {
        ::std::mem::replace(&mut self.friendGroups, ::protobuf::RepeatedField::new())
    }

    pub fn get_friendGroups<'a>(&'a self) -> &'a [CMsgClientFriendsGroupsList_FriendGroup] {
        &self.friendGroups
    }

    // repeated .CMsgClientFriendsGroupsList.FriendGroupsMembership memberships = 4;

    pub fn clear_memberships(&mut self) {
        self.memberships.clear();
    }

    // Param is passed by value, moved
    pub fn set_memberships(&mut self, v: ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership>) {
        self.memberships = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memberships<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership> {
        &mut self.memberships
    }

    // Take field
    pub fn take_memberships(&mut self) -> ::protobuf::RepeatedField<CMsgClientFriendsGroupsList_FriendGroupsMembership> {
        ::std::mem::replace(&mut self.memberships, ::protobuf::RepeatedField::new())
    }

    pub fn get_memberships<'a>(&'a self) -> &'a [CMsgClientFriendsGroupsList_FriendGroupsMembership] {
        &self.memberships
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bremoval = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bincremental = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friendGroups));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.memberships));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bremoval.is_some() {
            my_size += 2;
        };
        if self.bincremental.is_some() {
            my_size += 2;
        };
        for value in self.friendGroups.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.memberships.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bremoval {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.bincremental {
            try!(os.write_bool(2, v));
        };
        for v in self.friendGroups.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.memberships.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendsGroupsList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendsGroupsList {
    fn new() -> CMsgClientFriendsGroupsList {
        CMsgClientFriendsGroupsList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendsGroupsList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bremoval",
                    CMsgClientFriendsGroupsList::has_bremoval,
                    CMsgClientFriendsGroupsList::get_bremoval,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bincremental",
                    CMsgClientFriendsGroupsList::has_bincremental,
                    CMsgClientFriendsGroupsList::get_bincremental,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "friendGroups",
                    CMsgClientFriendsGroupsList::get_friendGroups,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "memberships",
                    CMsgClientFriendsGroupsList::get_memberships,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsGroupsList>(
                    "CMsgClientFriendsGroupsList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList {
    fn clear(&mut self) {
        self.clear_bremoval();
        self.clear_bincremental();
        self.clear_friendGroups();
        self.clear_memberships();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendsGroupsList {
    fn eq(&self, other: &CMsgClientFriendsGroupsList) -> bool {
        self.bremoval == other.bremoval &&
        self.bincremental == other.bincremental &&
        self.friendGroups == other.friendGroups &&
        self.memberships == other.memberships &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendsGroupsList_FriendGroup {
    // message fields
    nGroupID: ::std::option::Option<i32>,
    strGroupName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendsGroupsList_FriendGroup {}

impl CMsgClientFriendsGroupsList_FriendGroup {
    pub fn new() -> CMsgClientFriendsGroupsList_FriendGroup {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendsGroupsList_FriendGroup {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendsGroupsList_FriendGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendsGroupsList_FriendGroup,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendsGroupsList_FriendGroup {
                    nGroupID: ::std::option::Option::None,
                    strGroupName: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 nGroupID = 1;

    pub fn clear_nGroupID(&mut self) {
        self.nGroupID = ::std::option::Option::None;
    }

    pub fn has_nGroupID(&self) -> bool {
        self.nGroupID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nGroupID(&mut self, v: i32) {
        self.nGroupID = ::std::option::Option::Some(v);
    }

    pub fn get_nGroupID<'a>(&self) -> i32 {
        self.nGroupID.unwrap_or(0)
    }

    // optional string strGroupName = 2;

    pub fn clear_strGroupName(&mut self) {
        self.strGroupName.clear();
    }

    pub fn has_strGroupName(&self) -> bool {
        self.strGroupName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strGroupName(&mut self, v: ::std::string::String) {
        self.strGroupName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_strGroupName<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.strGroupName.is_none() {
            self.strGroupName.set_default();
        };
        self.strGroupName.as_mut().unwrap()
    }

    // Take field
    pub fn take_strGroupName(&mut self) -> ::std::string::String {
        self.strGroupName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_strGroupName<'a>(&'a self) -> &'a str {
        match self.strGroupName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList_FriendGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.nGroupID = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.strGroupName));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.nGroupID.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.strGroupName.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.nGroupID {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.strGroupName.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendsGroupsList_FriendGroup>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendsGroupsList_FriendGroup {
    fn new() -> CMsgClientFriendsGroupsList_FriendGroup {
        CMsgClientFriendsGroupsList_FriendGroup::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendsGroupsList_FriendGroup>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "nGroupID",
                    CMsgClientFriendsGroupsList_FriendGroup::has_nGroupID,
                    CMsgClientFriendsGroupsList_FriendGroup::get_nGroupID,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "strGroupName",
                    CMsgClientFriendsGroupsList_FriendGroup::has_strGroupName,
                    CMsgClientFriendsGroupsList_FriendGroup::get_strGroupName,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsGroupsList_FriendGroup>(
                    "CMsgClientFriendsGroupsList_FriendGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList_FriendGroup {
    fn clear(&mut self) {
        self.clear_nGroupID();
        self.clear_strGroupName();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendsGroupsList_FriendGroup {
    fn eq(&self, other: &CMsgClientFriendsGroupsList_FriendGroup) -> bool {
        self.nGroupID == other.nGroupID &&
        self.strGroupName == other.strGroupName &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList_FriendGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendsGroupsList_FriendGroupsMembership {
    // message fields
    ulSteamID: ::std::option::Option<u64>,
    nGroupID: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendsGroupsList_FriendGroupsMembership {}

impl CMsgClientFriendsGroupsList_FriendGroupsMembership {
    pub fn new() -> CMsgClientFriendsGroupsList_FriendGroupsMembership {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendsGroupsList_FriendGroupsMembership {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendsGroupsList_FriendGroupsMembership> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendsGroupsList_FriendGroupsMembership,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendsGroupsList_FriendGroupsMembership {
                    ulSteamID: ::std::option::Option::None,
                    nGroupID: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 ulSteamID = 1;

    pub fn clear_ulSteamID(&mut self) {
        self.ulSteamID = ::std::option::Option::None;
    }

    pub fn has_ulSteamID(&self) -> bool {
        self.ulSteamID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ulSteamID(&mut self, v: u64) {
        self.ulSteamID = ::std::option::Option::Some(v);
    }

    pub fn get_ulSteamID<'a>(&self) -> u64 {
        self.ulSteamID.unwrap_or(0)
    }

    // optional int32 nGroupID = 2;

    pub fn clear_nGroupID(&mut self) {
        self.nGroupID = ::std::option::Option::None;
    }

    pub fn has_nGroupID(&self) -> bool {
        self.nGroupID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nGroupID(&mut self, v: i32) {
        self.nGroupID = ::std::option::Option::Some(v);
    }

    pub fn get_nGroupID<'a>(&self) -> i32 {
        self.nGroupID.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.ulSteamID = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.nGroupID = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ulSteamID.is_some() {
            my_size += 9;
        };
        for value in self.nGroupID.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.ulSteamID {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.nGroupID {
            try!(os.write_int32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendsGroupsList_FriendGroupsMembership>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn new() -> CMsgClientFriendsGroupsList_FriendGroupsMembership {
        CMsgClientFriendsGroupsList_FriendGroupsMembership::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendsGroupsList_FriendGroupsMembership>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ulSteamID",
                    CMsgClientFriendsGroupsList_FriendGroupsMembership::has_ulSteamID,
                    CMsgClientFriendsGroupsList_FriendGroupsMembership::get_ulSteamID,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "nGroupID",
                    CMsgClientFriendsGroupsList_FriendGroupsMembership::has_nGroupID,
                    CMsgClientFriendsGroupsList_FriendGroupsMembership::get_nGroupID,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendsGroupsList_FriendGroupsMembership>(
                    "CMsgClientFriendsGroupsList_FriendGroupsMembership",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn clear(&mut self) {
        self.clear_ulSteamID();
        self.clear_nGroupID();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn eq(&self, other: &CMsgClientFriendsGroupsList_FriendGroupsMembership) -> bool {
        self.ulSteamID == other.ulSteamID &&
        self.nGroupID == other.nGroupID &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendsGroupsList_FriendGroupsMembership {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPlayerNicknameList {
    // message fields
    removal: ::std::option::Option<bool>,
    incremental: ::std::option::Option<bool>,
    nicknames: ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPlayerNicknameList {}

impl CMsgClientPlayerNicknameList {
    pub fn new() -> CMsgClientPlayerNicknameList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPlayerNicknameList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPlayerNicknameList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPlayerNicknameList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPlayerNicknameList {
                    removal: ::std::option::Option::None,
                    incremental: ::std::option::Option::None,
                    nicknames: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool removal = 1;

    pub fn clear_removal(&mut self) {
        self.removal = ::std::option::Option::None;
    }

    pub fn has_removal(&self) -> bool {
        self.removal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removal(&mut self, v: bool) {
        self.removal = ::std::option::Option::Some(v);
    }

    pub fn get_removal<'a>(&self) -> bool {
        self.removal.unwrap_or(false)
    }

    // optional bool incremental = 2;

    pub fn clear_incremental(&mut self) {
        self.incremental = ::std::option::Option::None;
    }

    pub fn has_incremental(&self) -> bool {
        self.incremental.is_some()
    }

    // Param is passed by value, moved
    pub fn set_incremental(&mut self, v: bool) {
        self.incremental = ::std::option::Option::Some(v);
    }

    pub fn get_incremental<'a>(&self) -> bool {
        self.incremental.unwrap_or(false)
    }

    // repeated .CMsgClientPlayerNicknameList.PlayerNickname nicknames = 3;

    pub fn clear_nicknames(&mut self) {
        self.nicknames.clear();
    }

    // Param is passed by value, moved
    pub fn set_nicknames(&mut self, v: ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname>) {
        self.nicknames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nicknames<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname> {
        &mut self.nicknames
    }

    // Take field
    pub fn take_nicknames(&mut self) -> ::protobuf::RepeatedField<CMsgClientPlayerNicknameList_PlayerNickname> {
        ::std::mem::replace(&mut self.nicknames, ::protobuf::RepeatedField::new())
    }

    pub fn get_nicknames<'a>(&'a self) -> &'a [CMsgClientPlayerNicknameList_PlayerNickname] {
        &self.nicknames
    }
}

impl ::protobuf::Message for CMsgClientPlayerNicknameList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.removal = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.incremental = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nicknames));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.removal.is_some() {
            my_size += 2;
        };
        if self.incremental.is_some() {
            my_size += 2;
        };
        for value in self.nicknames.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.removal {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.incremental {
            try!(os.write_bool(2, v));
        };
        for v in self.nicknames.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPlayerNicknameList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPlayerNicknameList {
    fn new() -> CMsgClientPlayerNicknameList {
        CMsgClientPlayerNicknameList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPlayerNicknameList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "removal",
                    CMsgClientPlayerNicknameList::has_removal,
                    CMsgClientPlayerNicknameList::get_removal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "incremental",
                    CMsgClientPlayerNicknameList::has_incremental,
                    CMsgClientPlayerNicknameList::get_incremental,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "nicknames",
                    CMsgClientPlayerNicknameList::get_nicknames,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPlayerNicknameList>(
                    "CMsgClientPlayerNicknameList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPlayerNicknameList {
    fn clear(&mut self) {
        self.clear_removal();
        self.clear_incremental();
        self.clear_nicknames();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPlayerNicknameList {
    fn eq(&self, other: &CMsgClientPlayerNicknameList) -> bool {
        self.removal == other.removal &&
        self.incremental == other.incremental &&
        self.nicknames == other.nicknames &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPlayerNicknameList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPlayerNicknameList_PlayerNickname {
    // message fields
    steamid: ::std::option::Option<u64>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPlayerNicknameList_PlayerNickname {}

impl CMsgClientPlayerNicknameList_PlayerNickname {
    pub fn new() -> CMsgClientPlayerNicknameList_PlayerNickname {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPlayerNicknameList_PlayerNickname {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPlayerNicknameList_PlayerNickname> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPlayerNicknameList_PlayerNickname,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPlayerNicknameList_PlayerNickname {
                    steamid: ::std::option::Option::None,
                    nickname: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid = 1;

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    pub fn get_steamid<'a>(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    // optional string nickname = 3;

    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        };
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_nickname<'a>(&'a self) -> &'a str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientPlayerNicknameList_PlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid.is_some() {
            my_size += 9;
        };
        for value in self.nickname.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.nickname.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPlayerNicknameList_PlayerNickname>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPlayerNicknameList_PlayerNickname {
    fn new() -> CMsgClientPlayerNicknameList_PlayerNickname {
        CMsgClientPlayerNicknameList_PlayerNickname::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPlayerNicknameList_PlayerNickname>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid",
                    CMsgClientPlayerNicknameList_PlayerNickname::has_steamid,
                    CMsgClientPlayerNicknameList_PlayerNickname::get_steamid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "nickname",
                    CMsgClientPlayerNicknameList_PlayerNickname::has_nickname,
                    CMsgClientPlayerNicknameList_PlayerNickname::get_nickname,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPlayerNicknameList_PlayerNickname>(
                    "CMsgClientPlayerNicknameList_PlayerNickname",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPlayerNicknameList_PlayerNickname {
    fn clear(&mut self) {
        self.clear_steamid();
        self.clear_nickname();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPlayerNicknameList_PlayerNickname {
    fn eq(&self, other: &CMsgClientPlayerNicknameList_PlayerNickname) -> bool {
        self.steamid == other.steamid &&
        self.nickname == other.nickname &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPlayerNicknameList_PlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientSetPlayerNickname {
    // message fields
    steamid: ::std::option::Option<u64>,
    nickname: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientSetPlayerNickname {}

impl CMsgClientSetPlayerNickname {
    pub fn new() -> CMsgClientSetPlayerNickname {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientSetPlayerNickname {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientSetPlayerNickname> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientSetPlayerNickname,
        };
        unsafe {
            instance.get(|| {
                CMsgClientSetPlayerNickname {
                    steamid: ::std::option::Option::None,
                    nickname: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid = 1;

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    pub fn get_steamid<'a>(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    // optional string nickname = 2;

    pub fn clear_nickname(&mut self) {
        self.nickname.clear();
    }

    pub fn has_nickname(&self) -> bool {
        self.nickname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nickname(&mut self, v: ::std::string::String) {
        self.nickname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nickname<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.nickname.is_none() {
            self.nickname.set_default();
        };
        self.nickname.as_mut().unwrap()
    }

    // Take field
    pub fn take_nickname(&mut self) -> ::std::string::String {
        self.nickname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_nickname<'a>(&'a self) -> &'a str {
        match self.nickname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNickname {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nickname));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid.is_some() {
            my_size += 9;
        };
        for value in self.nickname.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.nickname.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientSetPlayerNickname>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientSetPlayerNickname {
    fn new() -> CMsgClientSetPlayerNickname {
        CMsgClientSetPlayerNickname::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientSetPlayerNickname>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid",
                    CMsgClientSetPlayerNickname::has_steamid,
                    CMsgClientSetPlayerNickname::get_steamid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "nickname",
                    CMsgClientSetPlayerNickname::has_nickname,
                    CMsgClientSetPlayerNickname::get_nickname,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetPlayerNickname>(
                    "CMsgClientSetPlayerNickname",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientSetPlayerNickname {
    fn clear(&mut self) {
        self.clear_steamid();
        self.clear_nickname();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientSetPlayerNickname {
    fn eq(&self, other: &CMsgClientSetPlayerNickname) -> bool {
        self.steamid == other.steamid &&
        self.nickname == other.nickname &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientSetPlayerNickname {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientSetPlayerNicknameResponse {
    // message fields
    eresult: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientSetPlayerNicknameResponse {}

impl CMsgClientSetPlayerNicknameResponse {
    pub fn new() -> CMsgClientSetPlayerNicknameResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientSetPlayerNicknameResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientSetPlayerNicknameResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientSetPlayerNicknameResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientSetPlayerNicknameResponse {
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientSetPlayerNicknameResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientSetPlayerNicknameResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientSetPlayerNicknameResponse {
    fn new() -> CMsgClientSetPlayerNicknameResponse {
        CMsgClientSetPlayerNicknameResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientSetPlayerNicknameResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "eresult",
                    CMsgClientSetPlayerNicknameResponse::has_eresult,
                    CMsgClientSetPlayerNicknameResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetPlayerNicknameResponse>(
                    "CMsgClientSetPlayerNicknameResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientSetPlayerNicknameResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientSetPlayerNicknameResponse {
    fn eq(&self, other: &CMsgClientSetPlayerNicknameResponse) -> bool {
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientSetPlayerNicknameResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLicenseList {
    // message fields
    eresult: ::std::option::Option<i32>,
    licenses: ::protobuf::RepeatedField<CMsgClientLicenseList_License>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLicenseList {}

impl CMsgClientLicenseList {
    pub fn new() -> CMsgClientLicenseList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLicenseList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLicenseList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLicenseList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLicenseList {
                    eresult: ::std::option::Option::None,
                    licenses: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // repeated .CMsgClientLicenseList.License licenses = 2;

    pub fn clear_licenses(&mut self) {
        self.licenses.clear();
    }

    // Param is passed by value, moved
    pub fn set_licenses(&mut self, v: ::protobuf::RepeatedField<CMsgClientLicenseList_License>) {
        self.licenses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_licenses<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientLicenseList_License> {
        &mut self.licenses
    }

    // Take field
    pub fn take_licenses(&mut self) -> ::protobuf::RepeatedField<CMsgClientLicenseList_License> {
        ::std::mem::replace(&mut self.licenses, ::protobuf::RepeatedField::new())
    }

    pub fn get_licenses<'a>(&'a self) -> &'a [CMsgClientLicenseList_License] {
        &self.licenses
    }
}

impl ::protobuf::Message for CMsgClientLicenseList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.licenses));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.licenses.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        for v in self.licenses.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLicenseList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLicenseList {
    fn new() -> CMsgClientLicenseList {
        CMsgClientLicenseList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLicenseList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLicenseList::has_eresult,
                    CMsgClientLicenseList::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "licenses",
                    CMsgClientLicenseList::get_licenses,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLicenseList>(
                    "CMsgClientLicenseList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLicenseList {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_licenses();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLicenseList {
    fn eq(&self, other: &CMsgClientLicenseList) -> bool {
        self.eresult == other.eresult &&
        self.licenses == other.licenses &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLicenseList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLicenseList_License {
    // message fields
    package_id: ::std::option::Option<u32>,
    time_created: ::std::option::Option<u32>,
    time_next_process: ::std::option::Option<u32>,
    minute_limit: ::std::option::Option<i32>,
    minutes_used: ::std::option::Option<i32>,
    payment_method: ::std::option::Option<u32>,
    flags: ::std::option::Option<u32>,
    purchase_country_code: ::protobuf::SingularField<::std::string::String>,
    license_type: ::std::option::Option<u32>,
    territory_code: ::std::option::Option<i32>,
    change_number: ::std::option::Option<i32>,
    owner_id: ::std::option::Option<u32>,
    initial_period: ::std::option::Option<u32>,
    initial_time_unit: ::std::option::Option<u32>,
    renewal_period: ::std::option::Option<u32>,
    renewal_time_unit: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLicenseList_License {}

impl CMsgClientLicenseList_License {
    pub fn new() -> CMsgClientLicenseList_License {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLicenseList_License {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLicenseList_License> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLicenseList_License,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLicenseList_License {
                    package_id: ::std::option::Option::None,
                    time_created: ::std::option::Option::None,
                    time_next_process: ::std::option::Option::None,
                    minute_limit: ::std::option::Option::None,
                    minutes_used: ::std::option::Option::None,
                    payment_method: ::std::option::Option::None,
                    flags: ::std::option::Option::None,
                    purchase_country_code: ::protobuf::SingularField::none(),
                    license_type: ::std::option::Option::None,
                    territory_code: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    owner_id: ::std::option::Option::None,
                    initial_period: ::std::option::Option::None,
                    initial_time_unit: ::std::option::Option::None,
                    renewal_period: ::std::option::Option::None,
                    renewal_time_unit: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 package_id = 1;

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    pub fn get_package_id<'a>(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    // optional fixed32 time_created = 2;

    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    pub fn get_time_created<'a>(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }

    // optional fixed32 time_next_process = 3;

    pub fn clear_time_next_process(&mut self) {
        self.time_next_process = ::std::option::Option::None;
    }

    pub fn has_time_next_process(&self) -> bool {
        self.time_next_process.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_next_process(&mut self, v: u32) {
        self.time_next_process = ::std::option::Option::Some(v);
    }

    pub fn get_time_next_process<'a>(&self) -> u32 {
        self.time_next_process.unwrap_or(0)
    }

    // optional int32 minute_limit = 4;

    pub fn clear_minute_limit(&mut self) {
        self.minute_limit = ::std::option::Option::None;
    }

    pub fn has_minute_limit(&self) -> bool {
        self.minute_limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minute_limit(&mut self, v: i32) {
        self.minute_limit = ::std::option::Option::Some(v);
    }

    pub fn get_minute_limit<'a>(&self) -> i32 {
        self.minute_limit.unwrap_or(0)
    }

    // optional int32 minutes_used = 5;

    pub fn clear_minutes_used(&mut self) {
        self.minutes_used = ::std::option::Option::None;
    }

    pub fn has_minutes_used(&self) -> bool {
        self.minutes_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minutes_used(&mut self, v: i32) {
        self.minutes_used = ::std::option::Option::Some(v);
    }

    pub fn get_minutes_used<'a>(&self) -> i32 {
        self.minutes_used.unwrap_or(0)
    }

    // optional uint32 payment_method = 6;

    pub fn clear_payment_method(&mut self) {
        self.payment_method = ::std::option::Option::None;
    }

    pub fn has_payment_method(&self) -> bool {
        self.payment_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_method(&mut self, v: u32) {
        self.payment_method = ::std::option::Option::Some(v);
    }

    pub fn get_payment_method<'a>(&self) -> u32 {
        self.payment_method.unwrap_or(0)
    }

    // optional uint32 flags = 7;

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    pub fn get_flags<'a>(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    // optional string purchase_country_code = 8;

    pub fn clear_purchase_country_code(&mut self) {
        self.purchase_country_code.clear();
    }

    pub fn has_purchase_country_code(&self) -> bool {
        self.purchase_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_country_code(&mut self, v: ::std::string::String) {
        self.purchase_country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_purchase_country_code<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.purchase_country_code.is_none() {
            self.purchase_country_code.set_default();
        };
        self.purchase_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_purchase_country_code(&mut self) -> ::std::string::String {
        self.purchase_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_purchase_country_code<'a>(&'a self) -> &'a str {
        match self.purchase_country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 license_type = 9;

    pub fn clear_license_type(&mut self) {
        self.license_type = ::std::option::Option::None;
    }

    pub fn has_license_type(&self) -> bool {
        self.license_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_license_type(&mut self, v: u32) {
        self.license_type = ::std::option::Option::Some(v);
    }

    pub fn get_license_type<'a>(&self) -> u32 {
        self.license_type.unwrap_or(0)
    }

    // optional int32 territory_code = 10;

    pub fn clear_territory_code(&mut self) {
        self.territory_code = ::std::option::Option::None;
    }

    pub fn has_territory_code(&self) -> bool {
        self.territory_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_territory_code(&mut self, v: i32) {
        self.territory_code = ::std::option::Option::Some(v);
    }

    pub fn get_territory_code<'a>(&self) -> i32 {
        self.territory_code.unwrap_or(0)
    }

    // optional int32 change_number = 11;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: i32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> i32 {
        self.change_number.unwrap_or(0)
    }

    // optional uint32 owner_id = 12;

    pub fn clear_owner_id(&mut self) {
        self.owner_id = ::std::option::Option::None;
    }

    pub fn has_owner_id(&self) -> bool {
        self.owner_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_id(&mut self, v: u32) {
        self.owner_id = ::std::option::Option::Some(v);
    }

    pub fn get_owner_id<'a>(&self) -> u32 {
        self.owner_id.unwrap_or(0)
    }

    // optional uint32 initial_period = 13;

    pub fn clear_initial_period(&mut self) {
        self.initial_period = ::std::option::Option::None;
    }

    pub fn has_initial_period(&self) -> bool {
        self.initial_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_period(&mut self, v: u32) {
        self.initial_period = ::std::option::Option::Some(v);
    }

    pub fn get_initial_period<'a>(&self) -> u32 {
        self.initial_period.unwrap_or(0)
    }

    // optional uint32 initial_time_unit = 14;

    pub fn clear_initial_time_unit(&mut self) {
        self.initial_time_unit = ::std::option::Option::None;
    }

    pub fn has_initial_time_unit(&self) -> bool {
        self.initial_time_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_time_unit(&mut self, v: u32) {
        self.initial_time_unit = ::std::option::Option::Some(v);
    }

    pub fn get_initial_time_unit<'a>(&self) -> u32 {
        self.initial_time_unit.unwrap_or(0)
    }

    // optional uint32 renewal_period = 15;

    pub fn clear_renewal_period(&mut self) {
        self.renewal_period = ::std::option::Option::None;
    }

    pub fn has_renewal_period(&self) -> bool {
        self.renewal_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_renewal_period(&mut self, v: u32) {
        self.renewal_period = ::std::option::Option::Some(v);
    }

    pub fn get_renewal_period<'a>(&self) -> u32 {
        self.renewal_period.unwrap_or(0)
    }

    // optional uint32 renewal_time_unit = 16;

    pub fn clear_renewal_time_unit(&mut self) {
        self.renewal_time_unit = ::std::option::Option::None;
    }

    pub fn has_renewal_time_unit(&self) -> bool {
        self.renewal_time_unit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_renewal_time_unit(&mut self, v: u32) {
        self.renewal_time_unit = ::std::option::Option::Some(v);
    }

    pub fn get_renewal_time_unit<'a>(&self) -> u32 {
        self.renewal_time_unit.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientLicenseList_License {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.package_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.time_created = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.time_next_process = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.minute_limit = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.minutes_used = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.payment_method = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.purchase_country_code));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.license_type = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.territory_code = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.owner_id = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.initial_period = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.initial_time_unit = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.renewal_period = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.renewal_time_unit = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.package_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.time_created.is_some() {
            my_size += 5;
        };
        if self.time_next_process.is_some() {
            my_size += 5;
        };
        for value in self.minute_limit.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.minutes_used.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.payment_method.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.flags.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.purchase_country_code.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.license_type.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.territory_code.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.owner_id.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.initial_period.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.initial_time_unit.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.renewal_period.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.renewal_time_unit.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.time_created {
            try!(os.write_fixed32(2, v));
        };
        if let Some(v) = self.time_next_process {
            try!(os.write_fixed32(3, v));
        };
        if let Some(v) = self.minute_limit {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.minutes_used {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.payment_method {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.flags {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.purchase_country_code.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.license_type {
            try!(os.write_uint32(9, v));
        };
        if let Some(v) = self.territory_code {
            try!(os.write_int32(10, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_int32(11, v));
        };
        if let Some(v) = self.owner_id {
            try!(os.write_uint32(12, v));
        };
        if let Some(v) = self.initial_period {
            try!(os.write_uint32(13, v));
        };
        if let Some(v) = self.initial_time_unit {
            try!(os.write_uint32(14, v));
        };
        if let Some(v) = self.renewal_period {
            try!(os.write_uint32(15, v));
        };
        if let Some(v) = self.renewal_time_unit {
            try!(os.write_uint32(16, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLicenseList_License>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLicenseList_License {
    fn new() -> CMsgClientLicenseList_License {
        CMsgClientLicenseList_License::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLicenseList_License>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "package_id",
                    CMsgClientLicenseList_License::has_package_id,
                    CMsgClientLicenseList_License::get_package_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "time_created",
                    CMsgClientLicenseList_License::has_time_created,
                    CMsgClientLicenseList_License::get_time_created,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "time_next_process",
                    CMsgClientLicenseList_License::has_time_next_process,
                    CMsgClientLicenseList_License::get_time_next_process,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "minute_limit",
                    CMsgClientLicenseList_License::has_minute_limit,
                    CMsgClientLicenseList_License::get_minute_limit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "minutes_used",
                    CMsgClientLicenseList_License::has_minutes_used,
                    CMsgClientLicenseList_License::get_minutes_used,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "payment_method",
                    CMsgClientLicenseList_License::has_payment_method,
                    CMsgClientLicenseList_License::get_payment_method,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "flags",
                    CMsgClientLicenseList_License::has_flags,
                    CMsgClientLicenseList_License::get_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "purchase_country_code",
                    CMsgClientLicenseList_License::has_purchase_country_code,
                    CMsgClientLicenseList_License::get_purchase_country_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "license_type",
                    CMsgClientLicenseList_License::has_license_type,
                    CMsgClientLicenseList_License::get_license_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "territory_code",
                    CMsgClientLicenseList_License::has_territory_code,
                    CMsgClientLicenseList_License::get_territory_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "change_number",
                    CMsgClientLicenseList_License::has_change_number,
                    CMsgClientLicenseList_License::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "owner_id",
                    CMsgClientLicenseList_License::has_owner_id,
                    CMsgClientLicenseList_License::get_owner_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "initial_period",
                    CMsgClientLicenseList_License::has_initial_period,
                    CMsgClientLicenseList_License::get_initial_period,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "initial_time_unit",
                    CMsgClientLicenseList_License::has_initial_time_unit,
                    CMsgClientLicenseList_License::get_initial_time_unit,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "renewal_period",
                    CMsgClientLicenseList_License::has_renewal_period,
                    CMsgClientLicenseList_License::get_renewal_period,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "renewal_time_unit",
                    CMsgClientLicenseList_License::has_renewal_time_unit,
                    CMsgClientLicenseList_License::get_renewal_time_unit,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLicenseList_License>(
                    "CMsgClientLicenseList_License",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLicenseList_License {
    fn clear(&mut self) {
        self.clear_package_id();
        self.clear_time_created();
        self.clear_time_next_process();
        self.clear_minute_limit();
        self.clear_minutes_used();
        self.clear_payment_method();
        self.clear_flags();
        self.clear_purchase_country_code();
        self.clear_license_type();
        self.clear_territory_code();
        self.clear_change_number();
        self.clear_owner_id();
        self.clear_initial_period();
        self.clear_initial_time_unit();
        self.clear_renewal_period();
        self.clear_renewal_time_unit();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLicenseList_License {
    fn eq(&self, other: &CMsgClientLicenseList_License) -> bool {
        self.package_id == other.package_id &&
        self.time_created == other.time_created &&
        self.time_next_process == other.time_next_process &&
        self.minute_limit == other.minute_limit &&
        self.minutes_used == other.minutes_used &&
        self.payment_method == other.payment_method &&
        self.flags == other.flags &&
        self.purchase_country_code == other.purchase_country_code &&
        self.license_type == other.license_type &&
        self.territory_code == other.territory_code &&
        self.change_number == other.change_number &&
        self.owner_id == other.owner_id &&
        self.initial_period == other.initial_period &&
        self.initial_time_unit == other.initial_time_unit &&
        self.renewal_period == other.renewal_period &&
        self.renewal_time_unit == other.renewal_time_unit &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLicenseList_License {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSSetScore {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_id: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    details: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    upload_score_method: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSSetScore {}

impl CMsgClientLBSSetScore {
    pub fn new() -> CMsgClientLBSSetScore {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSSetScore {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSSetScore> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSSetScore,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSSetScore {
                    app_id: ::std::option::Option::None,
                    leaderboard_id: ::std::option::Option::None,
                    score: ::std::option::Option::None,
                    details: ::protobuf::SingularField::none(),
                    upload_score_method: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 leaderboard_id = 2;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_id<'a>(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    // optional int32 score = 3;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score<'a>(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    // optional bytes details = 4;

    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details.set_default();
        };
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_details<'a>(&'a self) -> &'a [u8] {
        match self.details.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 upload_score_method = 5;

    pub fn clear_upload_score_method(&mut self) {
        self.upload_score_method = ::std::option::Option::None;
    }

    pub fn has_upload_score_method(&self) -> bool {
        self.upload_score_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_score_method(&mut self, v: i32) {
        self.upload_score_method = ::std::option::Option::Some(v);
    }

    pub fn get_upload_score_method<'a>(&self) -> i32 {
        self.upload_score_method.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScore {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.details));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.upload_score_method = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.score.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.details.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.upload_score_method.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.leaderboard_id {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.score {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.details.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.upload_score_method {
            try!(os.write_int32(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSSetScore>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSSetScore {
    fn new() -> CMsgClientLBSSetScore {
        CMsgClientLBSSetScore::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSSetScore>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientLBSSetScore::has_app_id,
                    CMsgClientLBSSetScore::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_id",
                    CMsgClientLBSSetScore::has_leaderboard_id,
                    CMsgClientLBSSetScore::get_leaderboard_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "score",
                    CMsgClientLBSSetScore::has_score,
                    CMsgClientLBSSetScore::get_score,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "details",
                    CMsgClientLBSSetScore::has_details,
                    CMsgClientLBSSetScore::get_details,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "upload_score_method",
                    CMsgClientLBSSetScore::has_upload_score_method,
                    CMsgClientLBSSetScore::get_upload_score_method,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetScore>(
                    "CMsgClientLBSSetScore",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetScore {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_leaderboard_id();
        self.clear_score();
        self.clear_details();
        self.clear_upload_score_method();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSSetScore {
    fn eq(&self, other: &CMsgClientLBSSetScore) -> bool {
        self.app_id == other.app_id &&
        self.leaderboard_id == other.leaderboard_id &&
        self.score == other.score &&
        self.details == other.details &&
        self.upload_score_method == other.upload_score_method &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetScore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSSetScoreResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    score_changed: ::std::option::Option<bool>,
    global_rank_previous: ::std::option::Option<i32>,
    global_rank_new: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSSetScoreResponse {}

impl CMsgClientLBSSetScoreResponse {
    pub fn new() -> CMsgClientLBSSetScoreResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSSetScoreResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSSetScoreResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSSetScoreResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSSetScoreResponse {
                    eresult: ::std::option::Option::None,
                    leaderboard_entry_count: ::std::option::Option::None,
                    score_changed: ::std::option::Option::None,
                    global_rank_previous: ::std::option::Option::None,
                    global_rank_new: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional int32 leaderboard_entry_count = 2;

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_entry_count<'a>(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    // optional bool score_changed = 3;

    pub fn clear_score_changed(&mut self) {
        self.score_changed = ::std::option::Option::None;
    }

    pub fn has_score_changed(&self) -> bool {
        self.score_changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_changed(&mut self, v: bool) {
        self.score_changed = ::std::option::Option::Some(v);
    }

    pub fn get_score_changed<'a>(&self) -> bool {
        self.score_changed.unwrap_or(false)
    }

    // optional int32 global_rank_previous = 4;

    pub fn clear_global_rank_previous(&mut self) {
        self.global_rank_previous = ::std::option::Option::None;
    }

    pub fn has_global_rank_previous(&self) -> bool {
        self.global_rank_previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_previous(&mut self, v: i32) {
        self.global_rank_previous = ::std::option::Option::Some(v);
    }

    pub fn get_global_rank_previous<'a>(&self) -> i32 {
        self.global_rank_previous.unwrap_or(0)
    }

    // optional int32 global_rank_new = 5;

    pub fn clear_global_rank_new(&mut self) {
        self.global_rank_new = ::std::option::Option::None;
    }

    pub fn has_global_rank_new(&self) -> bool {
        self.global_rank_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank_new(&mut self, v: i32) {
        self.global_rank_new = ::std::option::Option::Some(v);
    }

    pub fn get_global_rank_new<'a>(&self) -> i32 {
        self.global_rank_new.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientLBSSetScoreResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_entry_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.score_changed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.global_rank_previous = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.global_rank_new = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_entry_count.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.score_changed.is_some() {
            my_size += 2;
        };
        for value in self.global_rank_previous.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.global_rank_new.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.leaderboard_entry_count {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.score_changed {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.global_rank_previous {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.global_rank_new {
            try!(os.write_int32(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSSetScoreResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSSetScoreResponse {
    fn new() -> CMsgClientLBSSetScoreResponse {
        CMsgClientLBSSetScoreResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSSetScoreResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLBSSetScoreResponse::has_eresult,
                    CMsgClientLBSSetScoreResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_entry_count",
                    CMsgClientLBSSetScoreResponse::has_leaderboard_entry_count,
                    CMsgClientLBSSetScoreResponse::get_leaderboard_entry_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "score_changed",
                    CMsgClientLBSSetScoreResponse::has_score_changed,
                    CMsgClientLBSSetScoreResponse::get_score_changed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "global_rank_previous",
                    CMsgClientLBSSetScoreResponse::has_global_rank_previous,
                    CMsgClientLBSSetScoreResponse::get_global_rank_previous,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "global_rank_new",
                    CMsgClientLBSSetScoreResponse::has_global_rank_new,
                    CMsgClientLBSSetScoreResponse::get_global_rank_new,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetScoreResponse>(
                    "CMsgClientLBSSetScoreResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetScoreResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_leaderboard_entry_count();
        self.clear_score_changed();
        self.clear_global_rank_previous();
        self.clear_global_rank_new();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSSetScoreResponse {
    fn eq(&self, other: &CMsgClientLBSSetScoreResponse) -> bool {
        self.eresult == other.eresult &&
        self.leaderboard_entry_count == other.leaderboard_entry_count &&
        self.score_changed == other.score_changed &&
        self.global_rank_previous == other.global_rank_previous &&
        self.global_rank_new == other.global_rank_new &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetScoreResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSSetUGC {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_id: ::std::option::Option<i32>,
    ugc_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSSetUGC {}

impl CMsgClientLBSSetUGC {
    pub fn new() -> CMsgClientLBSSetUGC {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSSetUGC {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSSetUGC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSSetUGC,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSSetUGC {
                    app_id: ::std::option::Option::None,
                    leaderboard_id: ::std::option::Option::None,
                    ugc_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 leaderboard_id = 2;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_id<'a>(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    // optional fixed64 ugc_id = 3;

    pub fn clear_ugc_id(&mut self) {
        self.ugc_id = ::std::option::Option::None;
    }

    pub fn has_ugc_id(&self) -> bool {
        self.ugc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_id(&mut self, v: u64) {
        self.ugc_id = ::std::option::Option::Some(v);
    }

    pub fn get_ugc_id<'a>(&self) -> u64 {
        self.ugc_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.ugc_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.ugc_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.leaderboard_id {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.ugc_id {
            try!(os.write_fixed64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSSetUGC>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSSetUGC {
    fn new() -> CMsgClientLBSSetUGC {
        CMsgClientLBSSetUGC::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSSetUGC>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientLBSSetUGC::has_app_id,
                    CMsgClientLBSSetUGC::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_id",
                    CMsgClientLBSSetUGC::has_leaderboard_id,
                    CMsgClientLBSSetUGC::get_leaderboard_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ugc_id",
                    CMsgClientLBSSetUGC::has_ugc_id,
                    CMsgClientLBSSetUGC::get_ugc_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetUGC>(
                    "CMsgClientLBSSetUGC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetUGC {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_leaderboard_id();
        self.clear_ugc_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSSetUGC {
    fn eq(&self, other: &CMsgClientLBSSetUGC) -> bool {
        self.app_id == other.app_id &&
        self.leaderboard_id == other.leaderboard_id &&
        self.ugc_id == other.ugc_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetUGC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSSetUGCResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSSetUGCResponse {}

impl CMsgClientLBSSetUGCResponse {
    pub fn new() -> CMsgClientLBSSetUGCResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSSetUGCResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSSetUGCResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSSetUGCResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSSetUGCResponse {
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientLBSSetUGCResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSSetUGCResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSSetUGCResponse {
    fn new() -> CMsgClientLBSSetUGCResponse {
        CMsgClientLBSSetUGCResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSSetUGCResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLBSSetUGCResponse::has_eresult,
                    CMsgClientLBSSetUGCResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSSetUGCResponse>(
                    "CMsgClientLBSSetUGCResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSSetUGCResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSSetUGCResponse {
    fn eq(&self, other: &CMsgClientLBSSetUGCResponse) -> bool {
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSSetUGCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSFindOrCreateLB {
    // message fields
    app_id: ::std::option::Option<u32>,
    leaderboard_sort_method: ::std::option::Option<i32>,
    leaderboard_display_type: ::std::option::Option<i32>,
    create_if_not_found: ::std::option::Option<bool>,
    leaderboard_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSFindOrCreateLB {}

impl CMsgClientLBSFindOrCreateLB {
    pub fn new() -> CMsgClientLBSFindOrCreateLB {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSFindOrCreateLB {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSFindOrCreateLB> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSFindOrCreateLB,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSFindOrCreateLB {
                    app_id: ::std::option::Option::None,
                    leaderboard_sort_method: ::std::option::Option::None,
                    leaderboard_display_type: ::std::option::Option::None,
                    create_if_not_found: ::std::option::Option::None,
                    leaderboard_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 leaderboard_sort_method = 2;

    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_sort_method<'a>(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0)
    }

    // optional int32 leaderboard_display_type = 3;

    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_display_type<'a>(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0)
    }

    // optional bool create_if_not_found = 4;

    pub fn clear_create_if_not_found(&mut self) {
        self.create_if_not_found = ::std::option::Option::None;
    }

    pub fn has_create_if_not_found(&self) -> bool {
        self.create_if_not_found.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_if_not_found(&mut self, v: bool) {
        self.create_if_not_found = ::std::option::Option::Some(v);
    }

    pub fn get_create_if_not_found<'a>(&self) -> bool {
        self.create_if_not_found.unwrap_or(false)
    }

    // optional string leaderboard_name = 5;

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name.clear();
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name.set_default();
        };
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_leaderboard_name<'a>(&'a self) -> &'a str {
        match self.leaderboard_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLB {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_sort_method = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_display_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.create_if_not_found = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.leaderboard_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_sort_method.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_display_type.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.create_if_not_found.is_some() {
            my_size += 2;
        };
        for value in self.leaderboard_name.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.leaderboard_sort_method {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.leaderboard_display_type {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.create_if_not_found {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.leaderboard_name.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSFindOrCreateLB>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSFindOrCreateLB {
    fn new() -> CMsgClientLBSFindOrCreateLB {
        CMsgClientLBSFindOrCreateLB::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSFindOrCreateLB>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientLBSFindOrCreateLB::has_app_id,
                    CMsgClientLBSFindOrCreateLB::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_sort_method",
                    CMsgClientLBSFindOrCreateLB::has_leaderboard_sort_method,
                    CMsgClientLBSFindOrCreateLB::get_leaderboard_sort_method,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_display_type",
                    CMsgClientLBSFindOrCreateLB::has_leaderboard_display_type,
                    CMsgClientLBSFindOrCreateLB::get_leaderboard_display_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "create_if_not_found",
                    CMsgClientLBSFindOrCreateLB::has_create_if_not_found,
                    CMsgClientLBSFindOrCreateLB::get_create_if_not_found,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "leaderboard_name",
                    CMsgClientLBSFindOrCreateLB::has_leaderboard_name,
                    CMsgClientLBSFindOrCreateLB::get_leaderboard_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSFindOrCreateLB>(
                    "CMsgClientLBSFindOrCreateLB",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSFindOrCreateLB {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_leaderboard_sort_method();
        self.clear_leaderboard_display_type();
        self.clear_create_if_not_found();
        self.clear_leaderboard_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSFindOrCreateLB {
    fn eq(&self, other: &CMsgClientLBSFindOrCreateLB) -> bool {
        self.app_id == other.app_id &&
        self.leaderboard_sort_method == other.leaderboard_sort_method &&
        self.leaderboard_display_type == other.leaderboard_display_type &&
        self.create_if_not_found == other.create_if_not_found &&
        self.leaderboard_name == other.leaderboard_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSFindOrCreateLB {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSFindOrCreateLBResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_id: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    leaderboard_sort_method: ::std::option::Option<i32>,
    leaderboard_display_type: ::std::option::Option<i32>,
    leaderboard_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSFindOrCreateLBResponse {}

impl CMsgClientLBSFindOrCreateLBResponse {
    pub fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSFindOrCreateLBResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSFindOrCreateLBResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSFindOrCreateLBResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSFindOrCreateLBResponse {
                    eresult: ::std::option::Option::None,
                    leaderboard_id: ::std::option::Option::None,
                    leaderboard_entry_count: ::std::option::Option::None,
                    leaderboard_sort_method: ::std::option::Option::None,
                    leaderboard_display_type: ::std::option::Option::None,
                    leaderboard_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional int32 leaderboard_id = 2;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_id<'a>(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    // optional int32 leaderboard_entry_count = 3;

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_entry_count<'a>(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    // optional int32 leaderboard_sort_method = 4;

    pub fn clear_leaderboard_sort_method(&mut self) {
        self.leaderboard_sort_method = ::std::option::Option::None;
    }

    pub fn has_leaderboard_sort_method(&self) -> bool {
        self.leaderboard_sort_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_sort_method(&mut self, v: i32) {
        self.leaderboard_sort_method = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_sort_method<'a>(&self) -> i32 {
        self.leaderboard_sort_method.unwrap_or(0i32)
    }

    // optional int32 leaderboard_display_type = 5;

    pub fn clear_leaderboard_display_type(&mut self) {
        self.leaderboard_display_type = ::std::option::Option::None;
    }

    pub fn has_leaderboard_display_type(&self) -> bool {
        self.leaderboard_display_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_display_type(&mut self, v: i32) {
        self.leaderboard_display_type = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_display_type<'a>(&self) -> i32 {
        self.leaderboard_display_type.unwrap_or(0i32)
    }

    // optional string leaderboard_name = 6;

    pub fn clear_leaderboard_name(&mut self) {
        self.leaderboard_name.clear();
    }

    pub fn has_leaderboard_name(&self) -> bool {
        self.leaderboard_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_name(&mut self, v: ::std::string::String) {
        self.leaderboard_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leaderboard_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.leaderboard_name.is_none() {
            self.leaderboard_name.set_default();
        };
        self.leaderboard_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leaderboard_name(&mut self) -> ::std::string::String {
        self.leaderboard_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_leaderboard_name<'a>(&'a self) -> &'a str {
        match self.leaderboard_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientLBSFindOrCreateLBResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_entry_count = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_sort_method = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_display_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.leaderboard_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_entry_count.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_sort_method.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_display_type.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_name.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.leaderboard_id {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.leaderboard_entry_count {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.leaderboard_sort_method {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.leaderboard_display_type {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.leaderboard_name.as_ref() {
            try!(os.write_string(6, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSFindOrCreateLBResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSFindOrCreateLBResponse {
    fn new() -> CMsgClientLBSFindOrCreateLBResponse {
        CMsgClientLBSFindOrCreateLBResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSFindOrCreateLBResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLBSFindOrCreateLBResponse::has_eresult,
                    CMsgClientLBSFindOrCreateLBResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_id",
                    CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_id,
                    CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_entry_count",
                    CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_entry_count,
                    CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_entry_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_sort_method",
                    CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_sort_method,
                    CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_sort_method,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_display_type",
                    CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_display_type,
                    CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_display_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "leaderboard_name",
                    CMsgClientLBSFindOrCreateLBResponse::has_leaderboard_name,
                    CMsgClientLBSFindOrCreateLBResponse::get_leaderboard_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSFindOrCreateLBResponse>(
                    "CMsgClientLBSFindOrCreateLBResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSFindOrCreateLBResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_leaderboard_id();
        self.clear_leaderboard_entry_count();
        self.clear_leaderboard_sort_method();
        self.clear_leaderboard_display_type();
        self.clear_leaderboard_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSFindOrCreateLBResponse {
    fn eq(&self, other: &CMsgClientLBSFindOrCreateLBResponse) -> bool {
        self.eresult == other.eresult &&
        self.leaderboard_id == other.leaderboard_id &&
        self.leaderboard_entry_count == other.leaderboard_entry_count &&
        self.leaderboard_sort_method == other.leaderboard_sort_method &&
        self.leaderboard_display_type == other.leaderboard_display_type &&
        self.leaderboard_name == other.leaderboard_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSFindOrCreateLBResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSGetLBEntries {
    // message fields
    app_id: ::std::option::Option<i32>,
    leaderboard_id: ::std::option::Option<i32>,
    range_start: ::std::option::Option<i32>,
    range_end: ::std::option::Option<i32>,
    leaderboard_data_request: ::std::option::Option<i32>,
    steamids: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSGetLBEntries {}

impl CMsgClientLBSGetLBEntries {
    pub fn new() -> CMsgClientLBSGetLBEntries {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSGetLBEntries {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSGetLBEntries> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSGetLBEntries,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSGetLBEntries {
                    app_id: ::std::option::Option::None,
                    leaderboard_id: ::std::option::Option::None,
                    range_start: ::std::option::Option::None,
                    range_end: ::std::option::Option::None,
                    leaderboard_data_request: ::std::option::Option::None,
                    steamids: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: i32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> i32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 leaderboard_id = 2;

    pub fn clear_leaderboard_id(&mut self) {
        self.leaderboard_id = ::std::option::Option::None;
    }

    pub fn has_leaderboard_id(&self) -> bool {
        self.leaderboard_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_id(&mut self, v: i32) {
        self.leaderboard_id = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_id<'a>(&self) -> i32 {
        self.leaderboard_id.unwrap_or(0)
    }

    // optional int32 range_start = 3;

    pub fn clear_range_start(&mut self) {
        self.range_start = ::std::option::Option::None;
    }

    pub fn has_range_start(&self) -> bool {
        self.range_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_start(&mut self, v: i32) {
        self.range_start = ::std::option::Option::Some(v);
    }

    pub fn get_range_start<'a>(&self) -> i32 {
        self.range_start.unwrap_or(0)
    }

    // optional int32 range_end = 4;

    pub fn clear_range_end(&mut self) {
        self.range_end = ::std::option::Option::None;
    }

    pub fn has_range_end(&self) -> bool {
        self.range_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range_end(&mut self, v: i32) {
        self.range_end = ::std::option::Option::Some(v);
    }

    pub fn get_range_end<'a>(&self) -> i32 {
        self.range_end.unwrap_or(0)
    }

    // optional int32 leaderboard_data_request = 5;

    pub fn clear_leaderboard_data_request(&mut self) {
        self.leaderboard_data_request = ::std::option::Option::None;
    }

    pub fn has_leaderboard_data_request(&self) -> bool {
        self.leaderboard_data_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_data_request(&mut self, v: i32) {
        self.leaderboard_data_request = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_data_request<'a>(&self) -> i32 {
        self.leaderboard_data_request.unwrap_or(0)
    }

    // repeated fixed64 steamids = 6;

    pub fn clear_steamids(&mut self) {
        self.steamids.clear();
    }

    // Param is passed by value, moved
    pub fn set_steamids(&mut self, v: ::std::vec::Vec<u64>) {
        self.steamids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steamids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u64> {
        &mut self.steamids
    }

    // Take field
    pub fn take_steamids(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.steamids, ::std::vec::Vec::new())
    }

    pub fn get_steamids<'a>(&'a self) -> &'a [u64] {
        &self.steamids
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntries {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.range_start = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.range_end = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_data_request = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.steamids));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.range_start.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.range_end.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_data_request.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 9 * self.steamids.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.leaderboard_id {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.range_start {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.range_end {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.leaderboard_data_request {
            try!(os.write_int32(5, v));
        };
        for v in self.steamids.iter() {
            try!(os.write_fixed64(6, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSGetLBEntries>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSGetLBEntries {
    fn new() -> CMsgClientLBSGetLBEntries {
        CMsgClientLBSGetLBEntries::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSGetLBEntries>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "app_id",
                    CMsgClientLBSGetLBEntries::has_app_id,
                    CMsgClientLBSGetLBEntries::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_id",
                    CMsgClientLBSGetLBEntries::has_leaderboard_id,
                    CMsgClientLBSGetLBEntries::get_leaderboard_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "range_start",
                    CMsgClientLBSGetLBEntries::has_range_start,
                    CMsgClientLBSGetLBEntries::get_range_start,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "range_end",
                    CMsgClientLBSGetLBEntries::has_range_end,
                    CMsgClientLBSGetLBEntries::get_range_end,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_data_request",
                    CMsgClientLBSGetLBEntries::has_leaderboard_data_request,
                    CMsgClientLBSGetLBEntries::get_leaderboard_data_request,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u64_accessor(
                    "steamids",
                    CMsgClientLBSGetLBEntries::get_steamids,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSGetLBEntries>(
                    "CMsgClientLBSGetLBEntries",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntries {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_leaderboard_id();
        self.clear_range_start();
        self.clear_range_end();
        self.clear_leaderboard_data_request();
        self.clear_steamids();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSGetLBEntries {
    fn eq(&self, other: &CMsgClientLBSGetLBEntries) -> bool {
        self.app_id == other.app_id &&
        self.leaderboard_id == other.leaderboard_id &&
        self.range_start == other.range_start &&
        self.range_end == other.range_end &&
        self.leaderboard_data_request == other.leaderboard_data_request &&
        self.steamids == other.steamids &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSGetLBEntriesResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    leaderboard_entry_count: ::std::option::Option<i32>,
    entries: ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSGetLBEntriesResponse {}

impl CMsgClientLBSGetLBEntriesResponse {
    pub fn new() -> CMsgClientLBSGetLBEntriesResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSGetLBEntriesResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSGetLBEntriesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSGetLBEntriesResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSGetLBEntriesResponse {
                    eresult: ::std::option::Option::None,
                    leaderboard_entry_count: ::std::option::Option::None,
                    entries: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional int32 leaderboard_entry_count = 2;

    pub fn clear_leaderboard_entry_count(&mut self) {
        self.leaderboard_entry_count = ::std::option::Option::None;
    }

    pub fn has_leaderboard_entry_count(&self) -> bool {
        self.leaderboard_entry_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaderboard_entry_count(&mut self, v: i32) {
        self.leaderboard_entry_count = ::std::option::Option::Some(v);
    }

    pub fn get_leaderboard_entry_count<'a>(&self) -> i32 {
        self.leaderboard_entry_count.unwrap_or(0)
    }

    // repeated .CMsgClientLBSGetLBEntriesResponse.Entry entries = 3;

    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<CMsgClientLBSGetLBEntriesResponse_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }

    pub fn get_entries<'a>(&'a self) -> &'a [CMsgClientLBSGetLBEntriesResponse_Entry] {
        &self.entries
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntriesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.leaderboard_entry_count = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.leaderboard_entry_count.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.entries.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.leaderboard_entry_count {
            try!(os.write_int32(2, v));
        };
        for v in self.entries.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSGetLBEntriesResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSGetLBEntriesResponse {
    fn new() -> CMsgClientLBSGetLBEntriesResponse {
        CMsgClientLBSGetLBEntriesResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSGetLBEntriesResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientLBSGetLBEntriesResponse::has_eresult,
                    CMsgClientLBSGetLBEntriesResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "leaderboard_entry_count",
                    CMsgClientLBSGetLBEntriesResponse::has_leaderboard_entry_count,
                    CMsgClientLBSGetLBEntriesResponse::get_leaderboard_entry_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "entries",
                    CMsgClientLBSGetLBEntriesResponse::get_entries,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSGetLBEntriesResponse>(
                    "CMsgClientLBSGetLBEntriesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntriesResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_leaderboard_entry_count();
        self.clear_entries();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSGetLBEntriesResponse {
    fn eq(&self, other: &CMsgClientLBSGetLBEntriesResponse) -> bool {
        self.eresult == other.eresult &&
        self.leaderboard_entry_count == other.leaderboard_entry_count &&
        self.entries == other.entries &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientLBSGetLBEntriesResponse_Entry {
    // message fields
    steam_id_user: ::std::option::Option<u64>,
    global_rank: ::std::option::Option<i32>,
    score: ::std::option::Option<i32>,
    details: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    ugc_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientLBSGetLBEntriesResponse_Entry {}

impl CMsgClientLBSGetLBEntriesResponse_Entry {
    pub fn new() -> CMsgClientLBSGetLBEntriesResponse_Entry {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientLBSGetLBEntriesResponse_Entry {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientLBSGetLBEntriesResponse_Entry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientLBSGetLBEntriesResponse_Entry,
        };
        unsafe {
            instance.get(|| {
                CMsgClientLBSGetLBEntriesResponse_Entry {
                    steam_id_user: ::std::option::Option::None,
                    global_rank: ::std::option::Option::None,
                    score: ::std::option::Option::None,
                    details: ::protobuf::SingularField::none(),
                    ugc_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id_user = 1;

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_user<'a>(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    // optional int32 global_rank = 2;

    pub fn clear_global_rank(&mut self) {
        self.global_rank = ::std::option::Option::None;
    }

    pub fn has_global_rank(&self) -> bool {
        self.global_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_global_rank(&mut self, v: i32) {
        self.global_rank = ::std::option::Option::Some(v);
    }

    pub fn get_global_rank<'a>(&self) -> i32 {
        self.global_rank.unwrap_or(0)
    }

    // optional int32 score = 3;

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    pub fn get_score<'a>(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    // optional bytes details = 4;

    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::vec::Vec<u8>) {
        self.details = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.details.is_none() {
            self.details.set_default();
        };
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::vec::Vec<u8> {
        self.details.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_details<'a>(&'a self) -> &'a [u8] {
        match self.details.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional fixed64 ugc_id = 5;

    pub fn clear_ugc_id(&mut self) {
        self.ugc_id = ::std::option::Option::None;
    }

    pub fn has_ugc_id(&self) -> bool {
        self.ugc_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_id(&mut self, v: u64) {
        self.ugc_id = ::std::option::Option::Some(v);
    }

    pub fn get_ugc_id<'a>(&self) -> u64 {
        self.ugc_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_user = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.global_rank = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.score = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.details));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.ugc_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id_user.is_some() {
            my_size += 9;
        };
        for value in self.global_rank.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.score.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.details.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if self.ugc_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_user {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.global_rank {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.score {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.details.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.ugc_id {
            try!(os.write_fixed64(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientLBSGetLBEntriesResponse_Entry>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn new() -> CMsgClientLBSGetLBEntriesResponse_Entry {
        CMsgClientLBSGetLBEntriesResponse_Entry::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientLBSGetLBEntriesResponse_Entry>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_user",
                    CMsgClientLBSGetLBEntriesResponse_Entry::has_steam_id_user,
                    CMsgClientLBSGetLBEntriesResponse_Entry::get_steam_id_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "global_rank",
                    CMsgClientLBSGetLBEntriesResponse_Entry::has_global_rank,
                    CMsgClientLBSGetLBEntriesResponse_Entry::get_global_rank,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "score",
                    CMsgClientLBSGetLBEntriesResponse_Entry::has_score,
                    CMsgClientLBSGetLBEntriesResponse_Entry::get_score,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "details",
                    CMsgClientLBSGetLBEntriesResponse_Entry::has_details,
                    CMsgClientLBSGetLBEntriesResponse_Entry::get_details,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "ugc_id",
                    CMsgClientLBSGetLBEntriesResponse_Entry::has_ugc_id,
                    CMsgClientLBSGetLBEntriesResponse_Entry::get_ugc_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientLBSGetLBEntriesResponse_Entry>(
                    "CMsgClientLBSGetLBEntriesResponse_Entry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn clear(&mut self) {
        self.clear_steam_id_user();
        self.clear_global_rank();
        self.clear_score();
        self.clear_details();
        self.clear_ugc_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn eq(&self, other: &CMsgClientLBSGetLBEntriesResponse_Entry) -> bool {
        self.steam_id_user == other.steam_id_user &&
        self.global_rank == other.global_rank &&
        self.score == other.score &&
        self.details == other.details &&
        self.ugc_id == other.ugc_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientLBSGetLBEntriesResponse_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAccountInfo {
    // message fields
    persona_name: ::protobuf::SingularField<::std::string::String>,
    ip_country: ::protobuf::SingularField<::std::string::String>,
    count_authed_computers: ::std::option::Option<i32>,
    account_flags: ::std::option::Option<u32>,
    facebook_id: ::std::option::Option<u64>,
    facebook_name: ::protobuf::SingularField<::std::string::String>,
    steamguard_notify_newmachines: ::std::option::Option<bool>,
    steamguard_machine_name_user_chosen: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAccountInfo {}

impl CMsgClientAccountInfo {
    pub fn new() -> CMsgClientAccountInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAccountInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAccountInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAccountInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAccountInfo {
                    persona_name: ::protobuf::SingularField::none(),
                    ip_country: ::protobuf::SingularField::none(),
                    count_authed_computers: ::std::option::Option::None,
                    account_flags: ::std::option::Option::None,
                    facebook_id: ::std::option::Option::None,
                    facebook_name: ::protobuf::SingularField::none(),
                    steamguard_notify_newmachines: ::std::option::Option::None,
                    steamguard_machine_name_user_chosen: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string persona_name = 1;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        };
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name<'a>(&'a self) -> &'a str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ip_country = 2;

    pub fn clear_ip_country(&mut self) {
        self.ip_country.clear();
    }

    pub fn has_ip_country(&self) -> bool {
        self.ip_country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_country(&mut self, v: ::std::string::String) {
        self.ip_country = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_country<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip_country.is_none() {
            self.ip_country.set_default();
        };
        self.ip_country.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_country(&mut self) -> ::std::string::String {
        self.ip_country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_country<'a>(&'a self) -> &'a str {
        match self.ip_country.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 count_authed_computers = 5;

    pub fn clear_count_authed_computers(&mut self) {
        self.count_authed_computers = ::std::option::Option::None;
    }

    pub fn has_count_authed_computers(&self) -> bool {
        self.count_authed_computers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_authed_computers(&mut self, v: i32) {
        self.count_authed_computers = ::std::option::Option::Some(v);
    }

    pub fn get_count_authed_computers<'a>(&self) -> i32 {
        self.count_authed_computers.unwrap_or(0)
    }

    // optional uint32 account_flags = 7;

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }

    pub fn get_account_flags<'a>(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    // optional uint64 facebook_id = 8;

    pub fn clear_facebook_id(&mut self) {
        self.facebook_id = ::std::option::Option::None;
    }

    pub fn has_facebook_id(&self) -> bool {
        self.facebook_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facebook_id(&mut self, v: u64) {
        self.facebook_id = ::std::option::Option::Some(v);
    }

    pub fn get_facebook_id<'a>(&self) -> u64 {
        self.facebook_id.unwrap_or(0)
    }

    // optional string facebook_name = 9;

    pub fn clear_facebook_name(&mut self) {
        self.facebook_name.clear();
    }

    pub fn has_facebook_name(&self) -> bool {
        self.facebook_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facebook_name(&mut self, v: ::std::string::String) {
        self.facebook_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_facebook_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.facebook_name.is_none() {
            self.facebook_name.set_default();
        };
        self.facebook_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_facebook_name(&mut self) -> ::std::string::String {
        self.facebook_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_facebook_name<'a>(&'a self) -> &'a str {
        match self.facebook_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool steamguard_notify_newmachines = 14;

    pub fn clear_steamguard_notify_newmachines(&mut self) {
        self.steamguard_notify_newmachines = ::std::option::Option::None;
    }

    pub fn has_steamguard_notify_newmachines(&self) -> bool {
        self.steamguard_notify_newmachines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_notify_newmachines(&mut self, v: bool) {
        self.steamguard_notify_newmachines = ::std::option::Option::Some(v);
    }

    pub fn get_steamguard_notify_newmachines<'a>(&self) -> bool {
        self.steamguard_notify_newmachines.unwrap_or(false)
    }

    // optional string steamguard_machine_name_user_chosen = 15;

    pub fn clear_steamguard_machine_name_user_chosen(&mut self) {
        self.steamguard_machine_name_user_chosen.clear();
    }

    pub fn has_steamguard_machine_name_user_chosen(&self) -> bool {
        self.steamguard_machine_name_user_chosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamguard_machine_name_user_chosen(&mut self, v: ::std::string::String) {
        self.steamguard_machine_name_user_chosen = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamguard_machine_name_user_chosen<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.steamguard_machine_name_user_chosen.is_none() {
            self.steamguard_machine_name_user_chosen.set_default();
        };
        self.steamguard_machine_name_user_chosen.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamguard_machine_name_user_chosen(&mut self) -> ::std::string::String {
        self.steamguard_machine_name_user_chosen.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_steamguard_machine_name_user_chosen<'a>(&'a self) -> &'a str {
        match self.steamguard_machine_name_user_chosen.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientAccountInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_country));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.count_authed_computers = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.account_flags = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.facebook_id = ::std::option::Option::Some(tmp);
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.facebook_name));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.steamguard_notify_newmachines = ::std::option::Option::Some(tmp);
                },
                15 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.steamguard_machine_name_user_chosen));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.persona_name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.ip_country.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.count_authed_computers.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.account_flags.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.facebook_id.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.facebook_name.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.steamguard_notify_newmachines.is_some() {
            my_size += 2;
        };
        for value in self.steamguard_machine_name_user_chosen.iter() {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.ip_country.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.count_authed_computers {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.account_flags {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.facebook_id {
            try!(os.write_uint64(8, v));
        };
        if let Some(v) = self.facebook_name.as_ref() {
            try!(os.write_string(9, &v));
        };
        if let Some(v) = self.steamguard_notify_newmachines {
            try!(os.write_bool(14, v));
        };
        if let Some(v) = self.steamguard_machine_name_user_chosen.as_ref() {
            try!(os.write_string(15, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAccountInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAccountInfo {
    fn new() -> CMsgClientAccountInfo {
        CMsgClientAccountInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAccountInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name",
                    CMsgClientAccountInfo::has_persona_name,
                    CMsgClientAccountInfo::get_persona_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip_country",
                    CMsgClientAccountInfo::has_ip_country,
                    CMsgClientAccountInfo::get_ip_country,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "count_authed_computers",
                    CMsgClientAccountInfo::has_count_authed_computers,
                    CMsgClientAccountInfo::get_count_authed_computers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "account_flags",
                    CMsgClientAccountInfo::has_account_flags,
                    CMsgClientAccountInfo::get_account_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "facebook_id",
                    CMsgClientAccountInfo::has_facebook_id,
                    CMsgClientAccountInfo::get_facebook_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "facebook_name",
                    CMsgClientAccountInfo::has_facebook_name,
                    CMsgClientAccountInfo::get_facebook_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "steamguard_notify_newmachines",
                    CMsgClientAccountInfo::has_steamguard_notify_newmachines,
                    CMsgClientAccountInfo::get_steamguard_notify_newmachines,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "steamguard_machine_name_user_chosen",
                    CMsgClientAccountInfo::has_steamguard_machine_name_user_chosen,
                    CMsgClientAccountInfo::get_steamguard_machine_name_user_chosen,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAccountInfo>(
                    "CMsgClientAccountInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAccountInfo {
    fn clear(&mut self) {
        self.clear_persona_name();
        self.clear_ip_country();
        self.clear_count_authed_computers();
        self.clear_account_flags();
        self.clear_facebook_id();
        self.clear_facebook_name();
        self.clear_steamguard_notify_newmachines();
        self.clear_steamguard_machine_name_user_chosen();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAccountInfo {
    fn eq(&self, other: &CMsgClientAccountInfo) -> bool {
        self.persona_name == other.persona_name &&
        self.ip_country == other.ip_country &&
        self.count_authed_computers == other.count_authed_computers &&
        self.account_flags == other.account_flags &&
        self.facebook_id == other.facebook_id &&
        self.facebook_name == other.facebook_name &&
        self.steamguard_notify_newmachines == other.steamguard_notify_newmachines &&
        self.steamguard_machine_name_user_chosen == other.steamguard_machine_name_user_chosen &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAccountInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppMinutesPlayedData {
    // message fields
    minutes_played: ::protobuf::RepeatedField<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppMinutesPlayedData {}

impl CMsgClientAppMinutesPlayedData {
    pub fn new() -> CMsgClientAppMinutesPlayedData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppMinutesPlayedData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppMinutesPlayedData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppMinutesPlayedData,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppMinutesPlayedData {
                    minutes_played: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientAppMinutesPlayedData.AppMinutesPlayedData minutes_played = 1;

    pub fn clear_minutes_played(&mut self) {
        self.minutes_played.clear();
    }

    // Param is passed by value, moved
    pub fn set_minutes_played(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData>) {
        self.minutes_played = v;
    }

    // Mutable pointer to the field.
    pub fn mut_minutes_played<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData> {
        &mut self.minutes_played
    }

    // Take field
    pub fn take_minutes_played(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData> {
        ::std::mem::replace(&mut self.minutes_played, ::protobuf::RepeatedField::new())
    }

    pub fn get_minutes_played<'a>(&'a self) -> &'a [CMsgClientAppMinutesPlayedData_AppMinutesPlayedData] {
        &self.minutes_played
    }
}

impl ::protobuf::Message for CMsgClientAppMinutesPlayedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.minutes_played));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.minutes_played.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.minutes_played.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppMinutesPlayedData>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppMinutesPlayedData {
    fn new() -> CMsgClientAppMinutesPlayedData {
        CMsgClientAppMinutesPlayedData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppMinutesPlayedData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "minutes_played",
                    CMsgClientAppMinutesPlayedData::get_minutes_played,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppMinutesPlayedData>(
                    "CMsgClientAppMinutesPlayedData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppMinutesPlayedData {
    fn clear(&mut self) {
        self.clear_minutes_played();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppMinutesPlayedData {
    fn eq(&self, other: &CMsgClientAppMinutesPlayedData) -> bool {
        self.minutes_played == other.minutes_played &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppMinutesPlayedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    // message fields
    app_id: ::std::option::Option<u32>,
    forever: ::std::option::Option<i32>,
    last_two_weeks: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {}

impl CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    pub fn new() -> CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppMinutesPlayedData_AppMinutesPlayedData,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
                    app_id: ::std::option::Option::None,
                    forever: ::std::option::Option::None,
                    last_two_weeks: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 forever = 2;

    pub fn clear_forever(&mut self) {
        self.forever = ::std::option::Option::None;
    }

    pub fn has_forever(&self) -> bool {
        self.forever.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forever(&mut self, v: i32) {
        self.forever = ::std::option::Option::Some(v);
    }

    pub fn get_forever<'a>(&self) -> i32 {
        self.forever.unwrap_or(0)
    }

    // optional int32 last_two_weeks = 3;

    pub fn clear_last_two_weeks(&mut self) {
        self.last_two_weeks = ::std::option::Option::None;
    }

    pub fn has_last_two_weeks(&self) -> bool {
        self.last_two_weeks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_two_weeks(&mut self, v: i32) {
        self.last_two_weeks = ::std::option::Option::Some(v);
    }

    pub fn get_last_two_weeks<'a>(&self) -> i32 {
        self.last_two_weeks.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.forever = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.last_two_weeks = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.forever.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.last_two_weeks.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.forever {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.last_two_weeks {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    fn new() -> CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
        CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::has_app_id,
                    CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "forever",
                    CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::has_forever,
                    CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::get_forever,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "last_two_weeks",
                    CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::has_last_two_weeks,
                    CMsgClientAppMinutesPlayedData_AppMinutesPlayedData::get_last_two_weeks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppMinutesPlayedData_AppMinutesPlayedData>(
                    "CMsgClientAppMinutesPlayedData_AppMinutesPlayedData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_forever();
        self.clear_last_two_weeks();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    fn eq(&self, other: &CMsgClientAppMinutesPlayedData_AppMinutesPlayedData) -> bool {
        self.app_id == other.app_id &&
        self.forever == other.forever &&
        self.last_two_weeks == other.last_two_weeks &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppMinutesPlayedData_AppMinutesPlayedData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientIsLimitedAccount {
    // message fields
    bis_limited_account: ::std::option::Option<bool>,
    bis_community_banned: ::std::option::Option<bool>,
    bis_locked_account: ::std::option::Option<bool>,
    bis_limited_account_allowed_to_invite_friends: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientIsLimitedAccount {}

impl CMsgClientIsLimitedAccount {
    pub fn new() -> CMsgClientIsLimitedAccount {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientIsLimitedAccount {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientIsLimitedAccount> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientIsLimitedAccount,
        };
        unsafe {
            instance.get(|| {
                CMsgClientIsLimitedAccount {
                    bis_limited_account: ::std::option::Option::None,
                    bis_community_banned: ::std::option::Option::None,
                    bis_locked_account: ::std::option::Option::None,
                    bis_limited_account_allowed_to_invite_friends: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool bis_limited_account = 1;

    pub fn clear_bis_limited_account(&mut self) {
        self.bis_limited_account = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account(&self) -> bool {
        self.bis_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account(&mut self, v: bool) {
        self.bis_limited_account = ::std::option::Option::Some(v);
    }

    pub fn get_bis_limited_account<'a>(&self) -> bool {
        self.bis_limited_account.unwrap_or(false)
    }

    // optional bool bis_community_banned = 2;

    pub fn clear_bis_community_banned(&mut self) {
        self.bis_community_banned = ::std::option::Option::None;
    }

    pub fn has_bis_community_banned(&self) -> bool {
        self.bis_community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_community_banned(&mut self, v: bool) {
        self.bis_community_banned = ::std::option::Option::Some(v);
    }

    pub fn get_bis_community_banned<'a>(&self) -> bool {
        self.bis_community_banned.unwrap_or(false)
    }

    // optional bool bis_locked_account = 3;

    pub fn clear_bis_locked_account(&mut self) {
        self.bis_locked_account = ::std::option::Option::None;
    }

    pub fn has_bis_locked_account(&self) -> bool {
        self.bis_locked_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_locked_account(&mut self, v: bool) {
        self.bis_locked_account = ::std::option::Option::Some(v);
    }

    pub fn get_bis_locked_account<'a>(&self) -> bool {
        self.bis_locked_account.unwrap_or(false)
    }

    // optional bool bis_limited_account_allowed_to_invite_friends = 4;

    pub fn clear_bis_limited_account_allowed_to_invite_friends(&mut self) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::None;
    }

    pub fn has_bis_limited_account_allowed_to_invite_friends(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bis_limited_account_allowed_to_invite_friends(&mut self, v: bool) {
        self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(v);
    }

    pub fn get_bis_limited_account_allowed_to_invite_friends<'a>(&self) -> bool {
        self.bis_limited_account_allowed_to_invite_friends.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientIsLimitedAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bis_limited_account = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bis_community_banned = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bis_locked_account = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.bis_limited_account_allowed_to_invite_friends = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bis_limited_account.is_some() {
            my_size += 2;
        };
        if self.bis_community_banned.is_some() {
            my_size += 2;
        };
        if self.bis_locked_account.is_some() {
            my_size += 2;
        };
        if self.bis_limited_account_allowed_to_invite_friends.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.bis_limited_account {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.bis_community_banned {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.bis_locked_account {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.bis_limited_account_allowed_to_invite_friends {
            try!(os.write_bool(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientIsLimitedAccount>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientIsLimitedAccount {
    fn new() -> CMsgClientIsLimitedAccount {
        CMsgClientIsLimitedAccount::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientIsLimitedAccount>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bis_limited_account",
                    CMsgClientIsLimitedAccount::has_bis_limited_account,
                    CMsgClientIsLimitedAccount::get_bis_limited_account,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bis_community_banned",
                    CMsgClientIsLimitedAccount::has_bis_community_banned,
                    CMsgClientIsLimitedAccount::get_bis_community_banned,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bis_locked_account",
                    CMsgClientIsLimitedAccount::has_bis_locked_account,
                    CMsgClientIsLimitedAccount::get_bis_locked_account,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "bis_limited_account_allowed_to_invite_friends",
                    CMsgClientIsLimitedAccount::has_bis_limited_account_allowed_to_invite_friends,
                    CMsgClientIsLimitedAccount::get_bis_limited_account_allowed_to_invite_friends,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientIsLimitedAccount>(
                    "CMsgClientIsLimitedAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientIsLimitedAccount {
    fn clear(&mut self) {
        self.clear_bis_limited_account();
        self.clear_bis_community_banned();
        self.clear_bis_locked_account();
        self.clear_bis_limited_account_allowed_to_invite_friends();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientIsLimitedAccount {
    fn eq(&self, other: &CMsgClientIsLimitedAccount) -> bool {
        self.bis_limited_account == other.bis_limited_account &&
        self.bis_community_banned == other.bis_community_banned &&
        self.bis_locked_account == other.bis_locked_account &&
        self.bis_limited_account_allowed_to_invite_friends == other.bis_limited_account_allowed_to_invite_friends &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientIsLimitedAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestFriendData {
    // message fields
    persona_state_requested: ::std::option::Option<u32>,
    friends: ::std::vec::Vec<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestFriendData {}

impl CMsgClientRequestFriendData {
    pub fn new() -> CMsgClientRequestFriendData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestFriendData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestFriendData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestFriendData,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestFriendData {
                    persona_state_requested: ::std::option::Option::None,
                    friends: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 persona_state_requested = 1;

    pub fn clear_persona_state_requested(&mut self) {
        self.persona_state_requested = ::std::option::Option::None;
    }

    pub fn has_persona_state_requested(&self) -> bool {
        self.persona_state_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_requested(&mut self, v: u32) {
        self.persona_state_requested = ::std::option::Option::Some(v);
    }

    pub fn get_persona_state_requested<'a>(&self) -> u32 {
        self.persona_state_requested.unwrap_or(0)
    }

    // repeated fixed64 friends = 2;

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::std::vec::Vec<u64>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u64> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.friends, ::std::vec::Vec::new())
    }

    pub fn get_friends<'a>(&'a self) -> &'a [u64] {
        &self.friends
    }
}

impl ::protobuf::Message for CMsgClientRequestFriendData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.persona_state_requested = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_fixed64_into(wire_type, is, &mut self.friends));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.persona_state_requested.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 9 * self.friends.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_state_requested {
            try!(os.write_uint32(1, v));
        };
        for v in self.friends.iter() {
            try!(os.write_fixed64(2, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestFriendData>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestFriendData {
    fn new() -> CMsgClientRequestFriendData {
        CMsgClientRequestFriendData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestFriendData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "persona_state_requested",
                    CMsgClientRequestFriendData::has_persona_state_requested,
                    CMsgClientRequestFriendData::get_persona_state_requested,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u64_accessor(
                    "friends",
                    CMsgClientRequestFriendData::get_friends,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestFriendData>(
                    "CMsgClientRequestFriendData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestFriendData {
    fn clear(&mut self) {
        self.clear_persona_state_requested();
        self.clear_friends();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestFriendData {
    fn eq(&self, other: &CMsgClientRequestFriendData) -> bool {
        self.persona_state_requested == other.persona_state_requested &&
        self.friends == other.friends &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientChangeStatus {
    // message fields
    persona_state: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    is_auto_generated_name: ::std::option::Option<bool>,
    high_priority: ::std::option::Option<bool>,
    persona_set_by_user: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientChangeStatus {}

impl CMsgClientChangeStatus {
    pub fn new() -> CMsgClientChangeStatus {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientChangeStatus {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientChangeStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientChangeStatus,
        };
        unsafe {
            instance.get(|| {
                CMsgClientChangeStatus {
                    persona_state: ::std::option::Option::None,
                    player_name: ::protobuf::SingularField::none(),
                    is_auto_generated_name: ::std::option::Option::None,
                    high_priority: ::std::option::Option::None,
                    persona_set_by_user: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 persona_state = 1;

    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    pub fn get_persona_state<'a>(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }

    // optional string player_name = 2;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        };
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name<'a>(&'a self) -> &'a str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool is_auto_generated_name = 3;

    pub fn clear_is_auto_generated_name(&mut self) {
        self.is_auto_generated_name = ::std::option::Option::None;
    }

    pub fn has_is_auto_generated_name(&self) -> bool {
        self.is_auto_generated_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_auto_generated_name(&mut self, v: bool) {
        self.is_auto_generated_name = ::std::option::Option::Some(v);
    }

    pub fn get_is_auto_generated_name<'a>(&self) -> bool {
        self.is_auto_generated_name.unwrap_or(false)
    }

    // optional bool high_priority = 4;

    pub fn clear_high_priority(&mut self) {
        self.high_priority = ::std::option::Option::None;
    }

    pub fn has_high_priority(&self) -> bool {
        self.high_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority(&mut self, v: bool) {
        self.high_priority = ::std::option::Option::Some(v);
    }

    pub fn get_high_priority<'a>(&self) -> bool {
        self.high_priority.unwrap_or(false)
    }

    // optional bool persona_set_by_user = 5;

    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    pub fn get_persona_set_by_user<'a>(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientChangeStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.persona_state = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_auto_generated_name = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.high_priority = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.persona_set_by_user = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.persona_state.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.player_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.is_auto_generated_name.is_some() {
            my_size += 2;
        };
        if self.high_priority.is_some() {
            my_size += 2;
        };
        if self.persona_set_by_user.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.persona_state {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.player_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.is_auto_generated_name {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.high_priority {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.persona_set_by_user {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientChangeStatus>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientChangeStatus {
    fn new() -> CMsgClientChangeStatus {
        CMsgClientChangeStatus::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientChangeStatus>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "persona_state",
                    CMsgClientChangeStatus::has_persona_state,
                    CMsgClientChangeStatus::get_persona_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "player_name",
                    CMsgClientChangeStatus::has_player_name,
                    CMsgClientChangeStatus::get_player_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_auto_generated_name",
                    CMsgClientChangeStatus::has_is_auto_generated_name,
                    CMsgClientChangeStatus::get_is_auto_generated_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "high_priority",
                    CMsgClientChangeStatus::has_high_priority,
                    CMsgClientChangeStatus::get_high_priority,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "persona_set_by_user",
                    CMsgClientChangeStatus::has_persona_set_by_user,
                    CMsgClientChangeStatus::get_persona_set_by_user,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChangeStatus>(
                    "CMsgClientChangeStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientChangeStatus {
    fn clear(&mut self) {
        self.clear_persona_state();
        self.clear_player_name();
        self.clear_is_auto_generated_name();
        self.clear_high_priority();
        self.clear_persona_set_by_user();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientChangeStatus {
    fn eq(&self, other: &CMsgClientChangeStatus) -> bool {
        self.persona_state == other.persona_state &&
        self.player_name == other.player_name &&
        self.is_auto_generated_name == other.is_auto_generated_name &&
        self.high_priority == other.high_priority &&
        self.persona_set_by_user == other.persona_set_by_user &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientChangeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgPersonaChangeResponse {
    // message fields
    result: ::std::option::Option<u32>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgPersonaChangeResponse {}

impl CMsgPersonaChangeResponse {
    pub fn new() -> CMsgPersonaChangeResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgPersonaChangeResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgPersonaChangeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgPersonaChangeResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgPersonaChangeResponse {
                    result: ::std::option::Option::None,
                    player_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    // optional string player_name = 2;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        };
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name<'a>(&'a self) -> &'a str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgPersonaChangeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.result = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.result.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.player_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.player_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgPersonaChangeResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgPersonaChangeResponse {
    fn new() -> CMsgPersonaChangeResponse {
        CMsgPersonaChangeResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgPersonaChangeResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "result",
                    CMsgPersonaChangeResponse::has_result,
                    CMsgPersonaChangeResponse::get_result,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "player_name",
                    CMsgPersonaChangeResponse::has_player_name,
                    CMsgPersonaChangeResponse::get_player_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgPersonaChangeResponse>(
                    "CMsgPersonaChangeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgPersonaChangeResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.clear_player_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgPersonaChangeResponse {
    fn eq(&self, other: &CMsgPersonaChangeResponse) -> bool {
        self.result == other.result &&
        self.player_name == other.player_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgPersonaChangeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPersonaState {
    // message fields
    status_flags: ::std::option::Option<u32>,
    friends: ::protobuf::RepeatedField<CMsgClientPersonaState_Friend>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPersonaState {}

impl CMsgClientPersonaState {
    pub fn new() -> CMsgClientPersonaState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPersonaState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPersonaState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPersonaState,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPersonaState {
                    status_flags: ::std::option::Option::None,
                    friends: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 status_flags = 1;

    pub fn clear_status_flags(&mut self) {
        self.status_flags = ::std::option::Option::None;
    }

    pub fn has_status_flags(&self) -> bool {
        self.status_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_flags(&mut self, v: u32) {
        self.status_flags = ::std::option::Option::Some(v);
    }

    pub fn get_status_flags<'a>(&self) -> u32 {
        self.status_flags.unwrap_or(0)
    }

    // repeated .CMsgClientPersonaState.Friend friends = 2;

    pub fn clear_friends(&mut self) {
        self.friends.clear();
    }

    // Param is passed by value, moved
    pub fn set_friends(&mut self, v: ::protobuf::RepeatedField<CMsgClientPersonaState_Friend>) {
        self.friends = v;
    }

    // Mutable pointer to the field.
    pub fn mut_friends<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPersonaState_Friend> {
        &mut self.friends
    }

    // Take field
    pub fn take_friends(&mut self) -> ::protobuf::RepeatedField<CMsgClientPersonaState_Friend> {
        ::std::mem::replace(&mut self.friends, ::protobuf::RepeatedField::new())
    }

    pub fn get_friends<'a>(&'a self) -> &'a [CMsgClientPersonaState_Friend] {
        &self.friends
    }
}

impl ::protobuf::Message for CMsgClientPersonaState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.status_flags = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.friends));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.status_flags.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.friends.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.status_flags {
            try!(os.write_uint32(1, v));
        };
        for v in self.friends.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPersonaState>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPersonaState {
    fn new() -> CMsgClientPersonaState {
        CMsgClientPersonaState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPersonaState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "status_flags",
                    CMsgClientPersonaState::has_status_flags,
                    CMsgClientPersonaState::get_status_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "friends",
                    CMsgClientPersonaState::get_friends,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPersonaState>(
                    "CMsgClientPersonaState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState {
    fn clear(&mut self) {
        self.clear_status_flags();
        self.clear_friends();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPersonaState {
    fn eq(&self, other: &CMsgClientPersonaState) -> bool {
        self.status_flags == other.status_flags &&
        self.friends == other.friends &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPersonaState_Friend {
    // message fields
    friendid: ::std::option::Option<u64>,
    persona_state: ::std::option::Option<u32>,
    game_played_app_id: ::std::option::Option<u32>,
    game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    persona_state_flags: ::std::option::Option<u32>,
    online_session_instances: ::std::option::Option<u32>,
    published_instance_id: ::std::option::Option<u32>,
    persona_set_by_user: ::std::option::Option<bool>,
    player_name: ::protobuf::SingularField<::std::string::String>,
    query_port: ::std::option::Option<u32>,
    steamid_source: ::std::option::Option<u64>,
    avatar_hash: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    last_logoff: ::std::option::Option<u32>,
    last_logon: ::std::option::Option<u32>,
    clan_rank: ::std::option::Option<u32>,
    game_name: ::protobuf::SingularField<::std::string::String>,
    gameid: ::std::option::Option<u64>,
    game_data_blob: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    clan_tag: ::protobuf::SingularField<::std::string::String>,
    facebook_name: ::protobuf::SingularField<::std::string::String>,
    facebook_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPersonaState_Friend {}

impl CMsgClientPersonaState_Friend {
    pub fn new() -> CMsgClientPersonaState_Friend {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPersonaState_Friend {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPersonaState_Friend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPersonaState_Friend,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPersonaState_Friend {
                    friendid: ::std::option::Option::None,
                    persona_state: ::std::option::Option::None,
                    game_played_app_id: ::std::option::Option::None,
                    game_server_ip: ::std::option::Option::None,
                    game_server_port: ::std::option::Option::None,
                    persona_state_flags: ::std::option::Option::None,
                    online_session_instances: ::std::option::Option::None,
                    published_instance_id: ::std::option::Option::None,
                    persona_set_by_user: ::std::option::Option::None,
                    player_name: ::protobuf::SingularField::none(),
                    query_port: ::std::option::Option::None,
                    steamid_source: ::std::option::Option::None,
                    avatar_hash: ::protobuf::SingularField::none(),
                    last_logoff: ::std::option::Option::None,
                    last_logon: ::std::option::Option::None,
                    clan_rank: ::std::option::Option::None,
                    game_name: ::protobuf::SingularField::none(),
                    gameid: ::std::option::Option::None,
                    game_data_blob: ::protobuf::SingularField::none(),
                    clan_tag: ::protobuf::SingularField::none(),
                    facebook_name: ::protobuf::SingularField::none(),
                    facebook_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 friendid = 1;

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    pub fn get_friendid<'a>(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    // optional uint32 persona_state = 2;

    pub fn clear_persona_state(&mut self) {
        self.persona_state = ::std::option::Option::None;
    }

    pub fn has_persona_state(&self) -> bool {
        self.persona_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state(&mut self, v: u32) {
        self.persona_state = ::std::option::Option::Some(v);
    }

    pub fn get_persona_state<'a>(&self) -> u32 {
        self.persona_state.unwrap_or(0)
    }

    // optional uint32 game_played_app_id = 3;

    pub fn clear_game_played_app_id(&mut self) {
        self.game_played_app_id = ::std::option::Option::None;
    }

    pub fn has_game_played_app_id(&self) -> bool {
        self.game_played_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_played_app_id(&mut self, v: u32) {
        self.game_played_app_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_played_app_id<'a>(&self) -> u32 {
        self.game_played_app_id.unwrap_or(0)
    }

    // optional uint32 game_server_ip = 4;

    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip = ::std::option::Option::None;
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: u32) {
        self.game_server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_ip<'a>(&self) -> u32 {
        self.game_server_ip.unwrap_or(0)
    }

    // optional uint32 game_server_port = 5;

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_port<'a>(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    // optional uint32 persona_state_flags = 6;

    pub fn clear_persona_state_flags(&mut self) {
        self.persona_state_flags = ::std::option::Option::None;
    }

    pub fn has_persona_state_flags(&self) -> bool {
        self.persona_state_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_state_flags(&mut self, v: u32) {
        self.persona_state_flags = ::std::option::Option::Some(v);
    }

    pub fn get_persona_state_flags<'a>(&self) -> u32 {
        self.persona_state_flags.unwrap_or(0)
    }

    // optional uint32 online_session_instances = 7;

    pub fn clear_online_session_instances(&mut self) {
        self.online_session_instances = ::std::option::Option::None;
    }

    pub fn has_online_session_instances(&self) -> bool {
        self.online_session_instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online_session_instances(&mut self, v: u32) {
        self.online_session_instances = ::std::option::Option::Some(v);
    }

    pub fn get_online_session_instances<'a>(&self) -> u32 {
        self.online_session_instances.unwrap_or(0)
    }

    // optional uint32 published_instance_id = 8;

    pub fn clear_published_instance_id(&mut self) {
        self.published_instance_id = ::std::option::Option::None;
    }

    pub fn has_published_instance_id(&self) -> bool {
        self.published_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published_instance_id(&mut self, v: u32) {
        self.published_instance_id = ::std::option::Option::Some(v);
    }

    pub fn get_published_instance_id<'a>(&self) -> u32 {
        self.published_instance_id.unwrap_or(0)
    }

    // optional bool persona_set_by_user = 10;

    pub fn clear_persona_set_by_user(&mut self) {
        self.persona_set_by_user = ::std::option::Option::None;
    }

    pub fn has_persona_set_by_user(&self) -> bool {
        self.persona_set_by_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_set_by_user(&mut self, v: bool) {
        self.persona_set_by_user = ::std::option::Option::Some(v);
    }

    pub fn get_persona_set_by_user<'a>(&self) -> bool {
        self.persona_set_by_user.unwrap_or(false)
    }

    // optional string player_name = 15;

    pub fn clear_player_name(&mut self) {
        self.player_name.clear();
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name.set_default();
        };
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_player_name<'a>(&'a self) -> &'a str {
        match self.player_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 query_port = 20;

    pub fn clear_query_port(&mut self) {
        self.query_port = ::std::option::Option::None;
    }

    pub fn has_query_port(&self) -> bool {
        self.query_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_query_port(&mut self, v: u32) {
        self.query_port = ::std::option::Option::Some(v);
    }

    pub fn get_query_port<'a>(&self) -> u32 {
        self.query_port.unwrap_or(0)
    }

    // optional fixed64 steamid_source = 25;

    pub fn clear_steamid_source(&mut self) {
        self.steamid_source = ::std::option::Option::None;
    }

    pub fn has_steamid_source(&self) -> bool {
        self.steamid_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_source(&mut self, v: u64) {
        self.steamid_source = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_source<'a>(&self) -> u64 {
        self.steamid_source.unwrap_or(0)
    }

    // optional bytes avatar_hash = 31;

    pub fn clear_avatar_hash(&mut self) {
        self.avatar_hash.clear();
    }

    pub fn has_avatar_hash(&self) -> bool {
        self.avatar_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avatar_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.avatar_hash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_avatar_hash<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.avatar_hash.is_none() {
            self.avatar_hash.set_default();
        };
        self.avatar_hash.as_mut().unwrap()
    }

    // Take field
    pub fn take_avatar_hash(&mut self) -> ::std::vec::Vec<u8> {
        self.avatar_hash.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_avatar_hash<'a>(&'a self) -> &'a [u8] {
        match self.avatar_hash.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 last_logoff = 45;

    pub fn clear_last_logoff(&mut self) {
        self.last_logoff = ::std::option::Option::None;
    }

    pub fn has_last_logoff(&self) -> bool {
        self.last_logoff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_logoff(&mut self, v: u32) {
        self.last_logoff = ::std::option::Option::Some(v);
    }

    pub fn get_last_logoff<'a>(&self) -> u32 {
        self.last_logoff.unwrap_or(0)
    }

    // optional uint32 last_logon = 46;

    pub fn clear_last_logon(&mut self) {
        self.last_logon = ::std::option::Option::None;
    }

    pub fn has_last_logon(&self) -> bool {
        self.last_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_logon(&mut self, v: u32) {
        self.last_logon = ::std::option::Option::Some(v);
    }

    pub fn get_last_logon<'a>(&self) -> u32 {
        self.last_logon.unwrap_or(0)
    }

    // optional uint32 clan_rank = 50;

    pub fn clear_clan_rank(&mut self) {
        self.clan_rank = ::std::option::Option::None;
    }

    pub fn has_clan_rank(&self) -> bool {
        self.clan_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_rank(&mut self, v: u32) {
        self.clan_rank = ::std::option::Option::Some(v);
    }

    pub fn get_clan_rank<'a>(&self) -> u32 {
        self.clan_rank.unwrap_or(0)
    }

    // optional string game_name = 55;

    pub fn clear_game_name(&mut self) {
        self.game_name.clear();
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name.set_default();
        };
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_game_name<'a>(&'a self) -> &'a str {
        match self.game_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 gameid = 56;

    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    pub fn get_gameid<'a>(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }

    // optional bytes game_data_blob = 60;

    pub fn clear_game_data_blob(&mut self) {
        self.game_data_blob.clear();
    }

    pub fn has_game_data_blob(&self) -> bool {
        self.game_data_blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data_blob(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data_blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data_blob<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.game_data_blob.is_none() {
            self.game_data_blob.set_default();
        };
        self.game_data_blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data_blob(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data_blob.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_game_data_blob<'a>(&'a self) -> &'a [u8] {
        match self.game_data_blob.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string clan_tag = 65;

    pub fn clear_clan_tag(&mut self) {
        self.clan_tag.clear();
    }

    pub fn has_clan_tag(&self) -> bool {
        self.clan_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_tag(&mut self, v: ::std::string::String) {
        self.clan_tag = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan_tag<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clan_tag.is_none() {
            self.clan_tag.set_default();
        };
        self.clan_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan_tag(&mut self) -> ::std::string::String {
        self.clan_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clan_tag<'a>(&'a self) -> &'a str {
        match self.clan_tag.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string facebook_name = 66;

    pub fn clear_facebook_name(&mut self) {
        self.facebook_name.clear();
    }

    pub fn has_facebook_name(&self) -> bool {
        self.facebook_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facebook_name(&mut self, v: ::std::string::String) {
        self.facebook_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_facebook_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.facebook_name.is_none() {
            self.facebook_name.set_default();
        };
        self.facebook_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_facebook_name(&mut self) -> ::std::string::String {
        self.facebook_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_facebook_name<'a>(&'a self) -> &'a str {
        match self.facebook_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 facebook_id = 67;

    pub fn clear_facebook_id(&mut self) {
        self.facebook_id = ::std::option::Option::None;
    }

    pub fn has_facebook_id(&self) -> bool {
        self.facebook_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_facebook_id(&mut self, v: u64) {
        self.facebook_id = ::std::option::Option::Some(v);
    }

    pub fn get_facebook_id<'a>(&self) -> u64 {
        self.facebook_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPersonaState_Friend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.friendid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.persona_state = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_played_app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_server_ip = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_server_port = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.persona_state_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.online_session_instances = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.published_instance_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.persona_set_by_user = ::std::option::Option::Some(tmp);
                },
                15 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.player_name));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.query_port = ::std::option::Option::Some(tmp);
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_source = ::std::option::Option::Some(tmp);
                },
                31 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.avatar_hash));
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_logoff = ::std::option::Option::Some(tmp);
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_logon = ::std::option::Option::Some(tmp);
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.clan_rank = ::std::option::Option::Some(tmp);
                },
                55 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.game_name));
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.gameid = ::std::option::Option::Some(tmp);
                },
                60 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.game_data_blob));
                },
                65 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clan_tag));
                },
                66 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.facebook_name));
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.facebook_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.friendid.is_some() {
            my_size += 9;
        };
        for value in self.persona_state.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_played_app_id.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_server_ip.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_server_port.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.persona_state_flags.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.online_session_instances.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.published_instance_id.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.persona_set_by_user.is_some() {
            my_size += 2;
        };
        for value in self.player_name.iter() {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        for value in self.query_port.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steamid_source.is_some() {
            my_size += 10;
        };
        for value in self.avatar_hash.iter() {
            my_size += ::protobuf::rt::bytes_size(31, &value);
        };
        for value in self.last_logoff.iter() {
            my_size += ::protobuf::rt::value_size(45, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.last_logon.iter() {
            my_size += ::protobuf::rt::value_size(46, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.clan_rank.iter() {
            my_size += ::protobuf::rt::value_size(50, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_name.iter() {
            my_size += ::protobuf::rt::string_size(55, &value);
        };
        if self.gameid.is_some() {
            my_size += 10;
        };
        for value in self.game_data_blob.iter() {
            my_size += ::protobuf::rt::bytes_size(60, &value);
        };
        for value in self.clan_tag.iter() {
            my_size += ::protobuf::rt::string_size(65, &value);
        };
        for value in self.facebook_name.iter() {
            my_size += ::protobuf::rt::string_size(66, &value);
        };
        for value in self.facebook_id.iter() {
            my_size += ::protobuf::rt::value_size(67, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.persona_state {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.game_played_app_id {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.game_server_ip {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.game_server_port {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.persona_state_flags {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.online_session_instances {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.published_instance_id {
            try!(os.write_uint32(8, v));
        };
        if let Some(v) = self.persona_set_by_user {
            try!(os.write_bool(10, v));
        };
        if let Some(v) = self.player_name.as_ref() {
            try!(os.write_string(15, &v));
        };
        if let Some(v) = self.query_port {
            try!(os.write_uint32(20, v));
        };
        if let Some(v) = self.steamid_source {
            try!(os.write_fixed64(25, v));
        };
        if let Some(v) = self.avatar_hash.as_ref() {
            try!(os.write_bytes(31, &v));
        };
        if let Some(v) = self.last_logoff {
            try!(os.write_uint32(45, v));
        };
        if let Some(v) = self.last_logon {
            try!(os.write_uint32(46, v));
        };
        if let Some(v) = self.clan_rank {
            try!(os.write_uint32(50, v));
        };
        if let Some(v) = self.game_name.as_ref() {
            try!(os.write_string(55, &v));
        };
        if let Some(v) = self.gameid {
            try!(os.write_fixed64(56, v));
        };
        if let Some(v) = self.game_data_blob.as_ref() {
            try!(os.write_bytes(60, &v));
        };
        if let Some(v) = self.clan_tag.as_ref() {
            try!(os.write_string(65, &v));
        };
        if let Some(v) = self.facebook_name.as_ref() {
            try!(os.write_string(66, &v));
        };
        if let Some(v) = self.facebook_id {
            try!(os.write_uint64(67, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPersonaState_Friend>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPersonaState_Friend {
    fn new() -> CMsgClientPersonaState_Friend {
        CMsgClientPersonaState_Friend::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPersonaState_Friend>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "friendid",
                    CMsgClientPersonaState_Friend::has_friendid,
                    CMsgClientPersonaState_Friend::get_friendid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "persona_state",
                    CMsgClientPersonaState_Friend::has_persona_state,
                    CMsgClientPersonaState_Friend::get_persona_state,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_played_app_id",
                    CMsgClientPersonaState_Friend::has_game_played_app_id,
                    CMsgClientPersonaState_Friend::get_game_played_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_server_ip",
                    CMsgClientPersonaState_Friend::has_game_server_ip,
                    CMsgClientPersonaState_Friend::get_game_server_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_server_port",
                    CMsgClientPersonaState_Friend::has_game_server_port,
                    CMsgClientPersonaState_Friend::get_game_server_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "persona_state_flags",
                    CMsgClientPersonaState_Friend::has_persona_state_flags,
                    CMsgClientPersonaState_Friend::get_persona_state_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "online_session_instances",
                    CMsgClientPersonaState_Friend::has_online_session_instances,
                    CMsgClientPersonaState_Friend::get_online_session_instances,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "published_instance_id",
                    CMsgClientPersonaState_Friend::has_published_instance_id,
                    CMsgClientPersonaState_Friend::get_published_instance_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "persona_set_by_user",
                    CMsgClientPersonaState_Friend::has_persona_set_by_user,
                    CMsgClientPersonaState_Friend::get_persona_set_by_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "player_name",
                    CMsgClientPersonaState_Friend::has_player_name,
                    CMsgClientPersonaState_Friend::get_player_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "query_port",
                    CMsgClientPersonaState_Friend::has_query_port,
                    CMsgClientPersonaState_Friend::get_query_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_source",
                    CMsgClientPersonaState_Friend::has_steamid_source,
                    CMsgClientPersonaState_Friend::get_steamid_source,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "avatar_hash",
                    CMsgClientPersonaState_Friend::has_avatar_hash,
                    CMsgClientPersonaState_Friend::get_avatar_hash,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_logoff",
                    CMsgClientPersonaState_Friend::has_last_logoff,
                    CMsgClientPersonaState_Friend::get_last_logoff,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_logon",
                    CMsgClientPersonaState_Friend::has_last_logon,
                    CMsgClientPersonaState_Friend::get_last_logon,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "clan_rank",
                    CMsgClientPersonaState_Friend::has_clan_rank,
                    CMsgClientPersonaState_Friend::get_clan_rank,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "game_name",
                    CMsgClientPersonaState_Friend::has_game_name,
                    CMsgClientPersonaState_Friend::get_game_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "gameid",
                    CMsgClientPersonaState_Friend::has_gameid,
                    CMsgClientPersonaState_Friend::get_gameid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "game_data_blob",
                    CMsgClientPersonaState_Friend::has_game_data_blob,
                    CMsgClientPersonaState_Friend::get_game_data_blob,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clan_tag",
                    CMsgClientPersonaState_Friend::has_clan_tag,
                    CMsgClientPersonaState_Friend::get_clan_tag,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "facebook_name",
                    CMsgClientPersonaState_Friend::has_facebook_name,
                    CMsgClientPersonaState_Friend::get_facebook_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "facebook_id",
                    CMsgClientPersonaState_Friend::has_facebook_id,
                    CMsgClientPersonaState_Friend::get_facebook_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPersonaState_Friend>(
                    "CMsgClientPersonaState_Friend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPersonaState_Friend {
    fn clear(&mut self) {
        self.clear_friendid();
        self.clear_persona_state();
        self.clear_game_played_app_id();
        self.clear_game_server_ip();
        self.clear_game_server_port();
        self.clear_persona_state_flags();
        self.clear_online_session_instances();
        self.clear_published_instance_id();
        self.clear_persona_set_by_user();
        self.clear_player_name();
        self.clear_query_port();
        self.clear_steamid_source();
        self.clear_avatar_hash();
        self.clear_last_logoff();
        self.clear_last_logon();
        self.clear_clan_rank();
        self.clear_game_name();
        self.clear_gameid();
        self.clear_game_data_blob();
        self.clear_clan_tag();
        self.clear_facebook_name();
        self.clear_facebook_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPersonaState_Friend {
    fn eq(&self, other: &CMsgClientPersonaState_Friend) -> bool {
        self.friendid == other.friendid &&
        self.persona_state == other.persona_state &&
        self.game_played_app_id == other.game_played_app_id &&
        self.game_server_ip == other.game_server_ip &&
        self.game_server_port == other.game_server_port &&
        self.persona_state_flags == other.persona_state_flags &&
        self.online_session_instances == other.online_session_instances &&
        self.published_instance_id == other.published_instance_id &&
        self.persona_set_by_user == other.persona_set_by_user &&
        self.player_name == other.player_name &&
        self.query_port == other.query_port &&
        self.steamid_source == other.steamid_source &&
        self.avatar_hash == other.avatar_hash &&
        self.last_logoff == other.last_logoff &&
        self.last_logon == other.last_logon &&
        self.clan_rank == other.clan_rank &&
        self.game_name == other.game_name &&
        self.gameid == other.gameid &&
        self.game_data_blob == other.game_data_blob &&
        self.clan_tag == other.clan_tag &&
        self.facebook_name == other.facebook_name &&
        self.facebook_id == other.facebook_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPersonaState_Friend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendProfileInfo {
    // message fields
    steamid_friend: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendProfileInfo {}

impl CMsgClientFriendProfileInfo {
    pub fn new() -> CMsgClientFriendProfileInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendProfileInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendProfileInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendProfileInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendProfileInfo {
                    steamid_friend: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_friend = 1;

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_friend<'a>(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_friend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_friend.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_friend {
            try!(os.write_fixed64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendProfileInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendProfileInfo {
    fn new() -> CMsgClientFriendProfileInfo {
        CMsgClientFriendProfileInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendProfileInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_friend",
                    CMsgClientFriendProfileInfo::has_steamid_friend,
                    CMsgClientFriendProfileInfo::get_steamid_friend,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendProfileInfo>(
                    "CMsgClientFriendProfileInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendProfileInfo {
    fn clear(&mut self) {
        self.clear_steamid_friend();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendProfileInfo {
    fn eq(&self, other: &CMsgClientFriendProfileInfo) -> bool {
        self.steamid_friend == other.steamid_friend &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendProfileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendProfileInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid_friend: ::std::option::Option<u64>,
    time_created: ::std::option::Option<u32>,
    real_name: ::protobuf::SingularField<::std::string::String>,
    city_name: ::protobuf::SingularField<::std::string::String>,
    state_name: ::protobuf::SingularField<::std::string::String>,
    country_name: ::protobuf::SingularField<::std::string::String>,
    headline: ::protobuf::SingularField<::std::string::String>,
    summary: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendProfileInfoResponse {}

impl CMsgClientFriendProfileInfoResponse {
    pub fn new() -> CMsgClientFriendProfileInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendProfileInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendProfileInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendProfileInfoResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendProfileInfoResponse {
                    eresult: ::std::option::Option::None,
                    steamid_friend: ::std::option::Option::None,
                    time_created: ::std::option::Option::None,
                    real_name: ::protobuf::SingularField::none(),
                    city_name: ::protobuf::SingularField::none(),
                    state_name: ::protobuf::SingularField::none(),
                    country_name: ::protobuf::SingularField::none(),
                    headline: ::protobuf::SingularField::none(),
                    summary: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional fixed64 steamid_friend = 2;

    pub fn clear_steamid_friend(&mut self) {
        self.steamid_friend = ::std::option::Option::None;
    }

    pub fn has_steamid_friend(&self) -> bool {
        self.steamid_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_friend(&mut self, v: u64) {
        self.steamid_friend = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_friend<'a>(&self) -> u64 {
        self.steamid_friend.unwrap_or(0)
    }

    // optional uint32 time_created = 3;

    pub fn clear_time_created(&mut self) {
        self.time_created = ::std::option::Option::None;
    }

    pub fn has_time_created(&self) -> bool {
        self.time_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_created(&mut self, v: u32) {
        self.time_created = ::std::option::Option::Some(v);
    }

    pub fn get_time_created<'a>(&self) -> u32 {
        self.time_created.unwrap_or(0)
    }

    // optional string real_name = 4;

    pub fn clear_real_name(&mut self) {
        self.real_name.clear();
    }

    pub fn has_real_name(&self) -> bool {
        self.real_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_real_name(&mut self, v: ::std::string::String) {
        self.real_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_real_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.real_name.is_none() {
            self.real_name.set_default();
        };
        self.real_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_real_name(&mut self) -> ::std::string::String {
        self.real_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_real_name<'a>(&'a self) -> &'a str {
        match self.real_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string city_name = 5;

    pub fn clear_city_name(&mut self) {
        self.city_name.clear();
    }

    pub fn has_city_name(&self) -> bool {
        self.city_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city_name(&mut self, v: ::std::string::String) {
        self.city_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.city_name.is_none() {
            self.city_name.set_default();
        };
        self.city_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_city_name(&mut self) -> ::std::string::String {
        self.city_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_city_name<'a>(&'a self) -> &'a str {
        match self.city_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string state_name = 6;

    pub fn clear_state_name(&mut self) {
        self.state_name.clear();
    }

    pub fn has_state_name(&self) -> bool {
        self.state_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_name(&mut self, v: ::std::string::String) {
        self.state_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.state_name.is_none() {
            self.state_name.set_default();
        };
        self.state_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_state_name(&mut self) -> ::std::string::String {
        self.state_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_state_name<'a>(&'a self) -> &'a str {
        match self.state_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string country_name = 7;

    pub fn clear_country_name(&mut self) {
        self.country_name.clear();
    }

    pub fn has_country_name(&self) -> bool {
        self.country_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_name(&mut self, v: ::std::string::String) {
        self.country_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.country_name.is_none() {
            self.country_name.set_default();
        };
        self.country_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_name(&mut self) -> ::std::string::String {
        self.country_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_country_name<'a>(&'a self) -> &'a str {
        match self.country_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string headline = 8;

    pub fn clear_headline(&mut self) {
        self.headline.clear();
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.headline.is_none() {
            self.headline.set_default();
        };
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_headline<'a>(&'a self) -> &'a str {
        match self.headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string summary = 9;

    pub fn clear_summary(&mut self) {
        self.summary.clear();
    }

    pub fn has_summary(&self) -> bool {
        self.summary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_summary(&mut self, v: ::std::string::String) {
        self.summary = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.summary.is_none() {
            self.summary.set_default();
        };
        self.summary.as_mut().unwrap()
    }

    // Take field
    pub fn take_summary(&mut self) -> ::std::string::String {
        self.summary.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_summary<'a>(&'a self) -> &'a str {
        match self.summary.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientFriendProfileInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_friend = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.time_created = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.real_name));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city_name));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state_name));
                },
                7 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_name));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.summary));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steamid_friend.is_some() {
            my_size += 9;
        };
        for value in self.time_created.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.real_name.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.city_name.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.state_name.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.country_name.iter() {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in self.headline.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.summary.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.steamid_friend {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.time_created {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.real_name.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.city_name.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.state_name.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.country_name.as_ref() {
            try!(os.write_string(7, &v));
        };
        if let Some(v) = self.headline.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.summary.as_ref() {
            try!(os.write_string(9, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendProfileInfoResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendProfileInfoResponse {
    fn new() -> CMsgClientFriendProfileInfoResponse {
        CMsgClientFriendProfileInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendProfileInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientFriendProfileInfoResponse::has_eresult,
                    CMsgClientFriendProfileInfoResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_friend",
                    CMsgClientFriendProfileInfoResponse::has_steamid_friend,
                    CMsgClientFriendProfileInfoResponse::get_steamid_friend,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "time_created",
                    CMsgClientFriendProfileInfoResponse::has_time_created,
                    CMsgClientFriendProfileInfoResponse::get_time_created,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "real_name",
                    CMsgClientFriendProfileInfoResponse::has_real_name,
                    CMsgClientFriendProfileInfoResponse::get_real_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "city_name",
                    CMsgClientFriendProfileInfoResponse::has_city_name,
                    CMsgClientFriendProfileInfoResponse::get_city_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "state_name",
                    CMsgClientFriendProfileInfoResponse::has_state_name,
                    CMsgClientFriendProfileInfoResponse::get_state_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "country_name",
                    CMsgClientFriendProfileInfoResponse::has_country_name,
                    CMsgClientFriendProfileInfoResponse::get_country_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "headline",
                    CMsgClientFriendProfileInfoResponse::has_headline,
                    CMsgClientFriendProfileInfoResponse::get_headline,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "summary",
                    CMsgClientFriendProfileInfoResponse::has_summary,
                    CMsgClientFriendProfileInfoResponse::get_summary,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendProfileInfoResponse>(
                    "CMsgClientFriendProfileInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendProfileInfoResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_steamid_friend();
        self.clear_time_created();
        self.clear_real_name();
        self.clear_city_name();
        self.clear_state_name();
        self.clear_country_name();
        self.clear_headline();
        self.clear_summary();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendProfileInfoResponse {
    fn eq(&self, other: &CMsgClientFriendProfileInfoResponse) -> bool {
        self.eresult == other.eresult &&
        self.steamid_friend == other.steamid_friend &&
        self.time_created == other.time_created &&
        self.real_name == other.real_name &&
        self.city_name == other.city_name &&
        self.state_name == other.state_name &&
        self.country_name == other.country_name &&
        self.headline == other.headline &&
        self.summary == other.summary &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendProfileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientServerList {
    // message fields
    servers: ::protobuf::RepeatedField<CMsgClientServerList_Server>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientServerList {}

impl CMsgClientServerList {
    pub fn new() -> CMsgClientServerList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientServerList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientServerList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientServerList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientServerList {
                    servers: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientServerList.Server servers = 1;

    pub fn clear_servers(&mut self) {
        self.servers.clear();
    }

    // Param is passed by value, moved
    pub fn set_servers(&mut self, v: ::protobuf::RepeatedField<CMsgClientServerList_Server>) {
        self.servers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_servers<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientServerList_Server> {
        &mut self.servers
    }

    // Take field
    pub fn take_servers(&mut self) -> ::protobuf::RepeatedField<CMsgClientServerList_Server> {
        ::std::mem::replace(&mut self.servers, ::protobuf::RepeatedField::new())
    }

    pub fn get_servers<'a>(&'a self) -> &'a [CMsgClientServerList_Server] {
        &self.servers
    }
}

impl ::protobuf::Message for CMsgClientServerList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.servers));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.servers.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.servers.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientServerList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientServerList {
    fn new() -> CMsgClientServerList {
        CMsgClientServerList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientServerList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "servers",
                    CMsgClientServerList::get_servers,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServerList>(
                    "CMsgClientServerList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientServerList {
    fn clear(&mut self) {
        self.clear_servers();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientServerList {
    fn eq(&self, other: &CMsgClientServerList) -> bool {
        self.servers == other.servers &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientServerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientServerList_Server {
    // message fields
    server_type: ::std::option::Option<u32>,
    server_ip: ::std::option::Option<u32>,
    server_port: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientServerList_Server {}

impl CMsgClientServerList_Server {
    pub fn new() -> CMsgClientServerList_Server {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientServerList_Server {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientServerList_Server> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientServerList_Server,
        };
        unsafe {
            instance.get(|| {
                CMsgClientServerList_Server {
                    server_type: ::std::option::Option::None,
                    server_ip: ::std::option::Option::None,
                    server_port: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 server_type = 1;

    pub fn clear_server_type(&mut self) {
        self.server_type = ::std::option::Option::None;
    }

    pub fn has_server_type(&self) -> bool {
        self.server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: u32) {
        self.server_type = ::std::option::Option::Some(v);
    }

    pub fn get_server_type<'a>(&self) -> u32 {
        self.server_type.unwrap_or(0)
    }

    // optional uint32 server_ip = 2;

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_server_ip<'a>(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    // optional uint32 server_port = 3;

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    pub fn get_server_port<'a>(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientServerList_Server {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.server_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.server_ip = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.server_port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.server_type.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.server_ip.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.server_port.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server_type {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.server_ip {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.server_port {
            try!(os.write_uint32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientServerList_Server>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientServerList_Server {
    fn new() -> CMsgClientServerList_Server {
        CMsgClientServerList_Server::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientServerList_Server>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "server_type",
                    CMsgClientServerList_Server::has_server_type,
                    CMsgClientServerList_Server::get_server_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "server_ip",
                    CMsgClientServerList_Server::has_server_ip,
                    CMsgClientServerList_Server::get_server_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "server_port",
                    CMsgClientServerList_Server::has_server_port,
                    CMsgClientServerList_Server::get_server_port,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServerList_Server>(
                    "CMsgClientServerList_Server",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientServerList_Server {
    fn clear(&mut self) {
        self.clear_server_type();
        self.clear_server_ip();
        self.clear_server_port();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientServerList_Server {
    fn eq(&self, other: &CMsgClientServerList_Server) -> bool {
        self.server_type == other.server_type &&
        self.server_ip == other.server_ip &&
        self.server_port == other.server_port &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientServerList_Server {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestedClientStats {
    // message fields
    stats_to_send: ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestedClientStats {}

impl CMsgClientRequestedClientStats {
    pub fn new() -> CMsgClientRequestedClientStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestedClientStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestedClientStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestedClientStats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestedClientStats {
                    stats_to_send: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientRequestedClientStats.StatsToSend stats_to_send = 1;

    pub fn clear_stats_to_send(&mut self) {
        self.stats_to_send.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_to_send(&mut self, v: ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend>) {
        self.stats_to_send = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_to_send<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend> {
        &mut self.stats_to_send
    }

    // Take field
    pub fn take_stats_to_send(&mut self) -> ::protobuf::RepeatedField<CMsgClientRequestedClientStats_StatsToSend> {
        ::std::mem::replace(&mut self.stats_to_send, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats_to_send<'a>(&'a self) -> &'a [CMsgClientRequestedClientStats_StatsToSend] {
        &self.stats_to_send
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_to_send));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stats_to_send.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.stats_to_send.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestedClientStats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestedClientStats {
    fn new() -> CMsgClientRequestedClientStats {
        CMsgClientRequestedClientStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestedClientStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "stats_to_send",
                    CMsgClientRequestedClientStats::get_stats_to_send,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestedClientStats>(
                    "CMsgClientRequestedClientStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestedClientStats {
    fn clear(&mut self) {
        self.clear_stats_to_send();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestedClientStats {
    fn eq(&self, other: &CMsgClientRequestedClientStats) -> bool {
        self.stats_to_send == other.stats_to_send &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestedClientStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestedClientStats_StatsToSend {
    // message fields
    client_stat: ::std::option::Option<u32>,
    stat_aggregate_method: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestedClientStats_StatsToSend {}

impl CMsgClientRequestedClientStats_StatsToSend {
    pub fn new() -> CMsgClientRequestedClientStats_StatsToSend {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestedClientStats_StatsToSend {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestedClientStats_StatsToSend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestedClientStats_StatsToSend,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestedClientStats_StatsToSend {
                    client_stat: ::std::option::Option::None,
                    stat_aggregate_method: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 client_stat = 1;

    pub fn clear_client_stat(&mut self) {
        self.client_stat = ::std::option::Option::None;
    }

    pub fn has_client_stat(&self) -> bool {
        self.client_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_stat(&mut self, v: u32) {
        self.client_stat = ::std::option::Option::Some(v);
    }

    pub fn get_client_stat<'a>(&self) -> u32 {
        self.client_stat.unwrap_or(0)
    }

    // optional uint32 stat_aggregate_method = 2;

    pub fn clear_stat_aggregate_method(&mut self) {
        self.stat_aggregate_method = ::std::option::Option::None;
    }

    pub fn has_stat_aggregate_method(&self) -> bool {
        self.stat_aggregate_method.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_aggregate_method(&mut self, v: u32) {
        self.stat_aggregate_method = ::std::option::Option::Some(v);
    }

    pub fn get_stat_aggregate_method<'a>(&self) -> u32 {
        self.stat_aggregate_method.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientRequestedClientStats_StatsToSend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.client_stat = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_aggregate_method = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.client_stat.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stat_aggregate_method.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_stat {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.stat_aggregate_method {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestedClientStats_StatsToSend>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestedClientStats_StatsToSend {
    fn new() -> CMsgClientRequestedClientStats_StatsToSend {
        CMsgClientRequestedClientStats_StatsToSend::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestedClientStats_StatsToSend>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "client_stat",
                    CMsgClientRequestedClientStats_StatsToSend::has_client_stat,
                    CMsgClientRequestedClientStats_StatsToSend::get_client_stat,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_aggregate_method",
                    CMsgClientRequestedClientStats_StatsToSend::has_stat_aggregate_method,
                    CMsgClientRequestedClientStats_StatsToSend::get_stat_aggregate_method,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestedClientStats_StatsToSend>(
                    "CMsgClientRequestedClientStats_StatsToSend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestedClientStats_StatsToSend {
    fn clear(&mut self) {
        self.clear_client_stat();
        self.clear_stat_aggregate_method();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestedClientStats_StatsToSend {
    fn eq(&self, other: &CMsgClientRequestedClientStats_StatsToSend) -> bool {
        self.client_stat == other.client_stat &&
        self.stat_aggregate_method == other.stat_aggregate_method &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestedClientStats_StatsToSend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStat2 {
    // message fields
    stat_detail: ::protobuf::RepeatedField<CMsgClientStat2_StatDetail>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStat2 {}

impl CMsgClientStat2 {
    pub fn new() -> CMsgClientStat2 {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStat2 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStat2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStat2,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStat2 {
                    stat_detail: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientStat2.StatDetail stat_detail = 1;

    pub fn clear_stat_detail(&mut self) {
        self.stat_detail.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_detail(&mut self, v: ::protobuf::RepeatedField<CMsgClientStat2_StatDetail>) {
        self.stat_detail = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stat_detail<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientStat2_StatDetail> {
        &mut self.stat_detail
    }

    // Take field
    pub fn take_stat_detail(&mut self) -> ::protobuf::RepeatedField<CMsgClientStat2_StatDetail> {
        ::std::mem::replace(&mut self.stat_detail, ::protobuf::RepeatedField::new())
    }

    pub fn get_stat_detail<'a>(&'a self) -> &'a [CMsgClientStat2_StatDetail] {
        &self.stat_detail
    }
}

impl ::protobuf::Message for CMsgClientStat2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stat_detail));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stat_detail.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.stat_detail.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStat2>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStat2 {
    fn new() -> CMsgClientStat2 {
        CMsgClientStat2::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStat2>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "stat_detail",
                    CMsgClientStat2::get_stat_detail,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStat2>(
                    "CMsgClientStat2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStat2 {
    fn clear(&mut self) {
        self.clear_stat_detail();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStat2 {
    fn eq(&self, other: &CMsgClientStat2) -> bool {
        self.stat_detail == other.stat_detail &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStat2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStat2_StatDetail {
    // message fields
    client_stat: ::std::option::Option<u32>,
    ll_value: ::std::option::Option<i64>,
    time_of_day: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    depot_id: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStat2_StatDetail {}

impl CMsgClientStat2_StatDetail {
    pub fn new() -> CMsgClientStat2_StatDetail {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStat2_StatDetail {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStat2_StatDetail> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStat2_StatDetail,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStat2_StatDetail {
                    client_stat: ::std::option::Option::None,
                    ll_value: ::std::option::Option::None,
                    time_of_day: ::std::option::Option::None,
                    cell_id: ::std::option::Option::None,
                    depot_id: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 client_stat = 1;

    pub fn clear_client_stat(&mut self) {
        self.client_stat = ::std::option::Option::None;
    }

    pub fn has_client_stat(&self) -> bool {
        self.client_stat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_stat(&mut self, v: u32) {
        self.client_stat = ::std::option::Option::Some(v);
    }

    pub fn get_client_stat<'a>(&self) -> u32 {
        self.client_stat.unwrap_or(0)
    }

    // optional int64 ll_value = 2;

    pub fn clear_ll_value(&mut self) {
        self.ll_value = ::std::option::Option::None;
    }

    pub fn has_ll_value(&self) -> bool {
        self.ll_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ll_value(&mut self, v: i64) {
        self.ll_value = ::std::option::Option::Some(v);
    }

    pub fn get_ll_value<'a>(&self) -> i64 {
        self.ll_value.unwrap_or(0)
    }

    // optional uint32 time_of_day = 3;

    pub fn clear_time_of_day(&mut self) {
        self.time_of_day = ::std::option::Option::None;
    }

    pub fn has_time_of_day(&self) -> bool {
        self.time_of_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_of_day(&mut self, v: u32) {
        self.time_of_day = ::std::option::Option::Some(v);
    }

    pub fn get_time_of_day<'a>(&self) -> u32 {
        self.time_of_day.unwrap_or(0)
    }

    // optional uint32 cell_id = 4;

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id<'a>(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    // optional uint32 depot_id = 5;

    pub fn clear_depot_id(&mut self) {
        self.depot_id = ::std::option::Option::None;
    }

    pub fn has_depot_id(&self) -> bool {
        self.depot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depot_id(&mut self, v: u32) {
        self.depot_id = ::std::option::Option::Some(v);
    }

    pub fn get_depot_id<'a>(&self) -> u32 {
        self.depot_id.unwrap_or(0)
    }

    // optional uint32 app_id = 6;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientStat2_StatDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.client_stat = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.ll_value = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.time_of_day = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.depot_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.client_stat.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.ll_value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.time_of_day.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cell_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.depot_id.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.client_stat {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.ll_value {
            try!(os.write_int64(2, v));
        };
        if let Some(v) = self.time_of_day {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.cell_id {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.depot_id {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(6, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStat2_StatDetail>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStat2_StatDetail {
    fn new() -> CMsgClientStat2_StatDetail {
        CMsgClientStat2_StatDetail::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStat2_StatDetail>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "client_stat",
                    CMsgClientStat2_StatDetail::has_client_stat,
                    CMsgClientStat2_StatDetail::get_client_stat,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "ll_value",
                    CMsgClientStat2_StatDetail::has_ll_value,
                    CMsgClientStat2_StatDetail::get_ll_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "time_of_day",
                    CMsgClientStat2_StatDetail::has_time_of_day,
                    CMsgClientStat2_StatDetail::get_time_of_day,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id",
                    CMsgClientStat2_StatDetail::has_cell_id,
                    CMsgClientStat2_StatDetail::get_cell_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "depot_id",
                    CMsgClientStat2_StatDetail::has_depot_id,
                    CMsgClientStat2_StatDetail::get_depot_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientStat2_StatDetail::has_app_id,
                    CMsgClientStat2_StatDetail::get_app_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStat2_StatDetail>(
                    "CMsgClientStat2_StatDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStat2_StatDetail {
    fn clear(&mut self) {
        self.clear_client_stat();
        self.clear_ll_value();
        self.clear_time_of_day();
        self.clear_cell_id();
        self.clear_depot_id();
        self.clear_app_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStat2_StatDetail {
    fn eq(&self, other: &CMsgClientStat2_StatDetail) -> bool {
        self.client_stat == other.client_stat &&
        self.ll_value == other.ll_value &&
        self.time_of_day == other.time_of_day &&
        self.cell_id == other.cell_id &&
        self.depot_id == other.depot_id &&
        self.app_id == other.app_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStat2_StatDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSCreateLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<u32>,
    public_ip: ::std::option::Option<u32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    persona_name_owner: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSCreateLobby {}

impl CMsgClientMMSCreateLobby {
    pub fn new() -> CMsgClientMMSCreateLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSCreateLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSCreateLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSCreateLobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSCreateLobby {
                    app_id: ::std::option::Option::None,
                    max_members: ::std::option::Option::None,
                    lobby_type: ::std::option::Option::None,
                    lobby_flags: ::std::option::Option::None,
                    cell_id: ::std::option::Option::None,
                    public_ip: ::std::option::Option::None,
                    metadata: ::protobuf::SingularField::none(),
                    persona_name_owner: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 max_members = 2;

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    pub fn get_max_members<'a>(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    // optional int32 lobby_type = 3;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type<'a>(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    // optional int32 lobby_flags = 4;

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_flags<'a>(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    // optional uint32 cell_id = 5;

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id<'a>(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    // optional uint32 public_ip = 6;

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    pub fn get_public_ip<'a>(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    // optional bytes metadata = 7;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional string persona_name_owner = 8;

    pub fn clear_persona_name_owner(&mut self) {
        self.persona_name_owner.clear();
    }

    pub fn has_persona_name_owner(&self) -> bool {
        self.persona_name_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_owner(&mut self, v: ::std::string::String) {
        self.persona_name_owner = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_owner<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name_owner.is_none() {
            self.persona_name_owner.set_default();
        };
        self.persona_name_owner.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_owner(&mut self) -> ::std::string::String {
        self.persona_name_owner.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name_owner<'a>(&'a self) -> &'a str {
        match self.persona_name_owner.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                7 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name_owner));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.max_members.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_type.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_flags.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cell_id.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.public_ip.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        for value in self.persona_name_owner.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.max_members {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.lobby_type {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.lobby_flags {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.cell_id {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.public_ip {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(7, &v));
        };
        if let Some(v) = self.persona_name_owner.as_ref() {
            try!(os.write_string(8, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSCreateLobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSCreateLobby {
    fn new() -> CMsgClientMMSCreateLobby {
        CMsgClientMMSCreateLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSCreateLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSCreateLobby::has_app_id,
                    CMsgClientMMSCreateLobby::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "max_members",
                    CMsgClientMMSCreateLobby::has_max_members,
                    CMsgClientMMSCreateLobby::get_max_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_type",
                    CMsgClientMMSCreateLobby::has_lobby_type,
                    CMsgClientMMSCreateLobby::get_lobby_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_flags",
                    CMsgClientMMSCreateLobby::has_lobby_flags,
                    CMsgClientMMSCreateLobby::get_lobby_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id",
                    CMsgClientMMSCreateLobby::has_cell_id,
                    CMsgClientMMSCreateLobby::get_cell_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "public_ip",
                    CMsgClientMMSCreateLobby::has_public_ip,
                    CMsgClientMMSCreateLobby::get_public_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSCreateLobby::has_metadata,
                    CMsgClientMMSCreateLobby::get_metadata,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name_owner",
                    CMsgClientMMSCreateLobby::has_persona_name_owner,
                    CMsgClientMMSCreateLobby::get_persona_name_owner,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSCreateLobby>(
                    "CMsgClientMMSCreateLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSCreateLobby {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_max_members();
        self.clear_lobby_type();
        self.clear_lobby_flags();
        self.clear_cell_id();
        self.clear_public_ip();
        self.clear_metadata();
        self.clear_persona_name_owner();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSCreateLobby {
    fn eq(&self, other: &CMsgClientMMSCreateLobby) -> bool {
        self.app_id == other.app_id &&
        self.max_members == other.max_members &&
        self.lobby_type == other.lobby_type &&
        self.lobby_flags == other.lobby_flags &&
        self.cell_id == other.cell_id &&
        self.public_ip == other.public_ip &&
        self.metadata == other.metadata &&
        self.persona_name_owner == other.persona_name_owner &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSCreateLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSCreateLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSCreateLobbyResponse {}

impl CMsgClientMMSCreateLobbyResponse {
    pub fn new() -> CMsgClientMMSCreateLobbyResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSCreateLobbyResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSCreateLobbyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSCreateLobbyResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSCreateLobbyResponse {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional int32 eresult = 3;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientMMSCreateLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSCreateLobbyResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSCreateLobbyResponse {
    fn new() -> CMsgClientMMSCreateLobbyResponse {
        CMsgClientMMSCreateLobbyResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSCreateLobbyResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSCreateLobbyResponse::has_app_id,
                    CMsgClientMMSCreateLobbyResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSCreateLobbyResponse::has_steam_id_lobby,
                    CMsgClientMMSCreateLobbyResponse::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientMMSCreateLobbyResponse::has_eresult,
                    CMsgClientMMSCreateLobbyResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSCreateLobbyResponse>(
                    "CMsgClientMMSCreateLobbyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSCreateLobbyResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSCreateLobbyResponse {
    fn eq(&self, other: &CMsgClientMMSCreateLobbyResponse) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSCreateLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSJoinLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSJoinLobby {}

impl CMsgClientMMSJoinLobby {
    pub fn new() -> CMsgClientMMSJoinLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSJoinLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSJoinLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSJoinLobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSJoinLobby {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    persona_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional string persona_name = 3;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        };
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name<'a>(&'a self) -> &'a str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.persona_name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.persona_name.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSJoinLobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSJoinLobby {
    fn new() -> CMsgClientMMSJoinLobby {
        CMsgClientMMSJoinLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSJoinLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSJoinLobby::has_app_id,
                    CMsgClientMMSJoinLobby::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSJoinLobby::has_steam_id_lobby,
                    CMsgClientMMSJoinLobby::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name",
                    CMsgClientMMSJoinLobby::has_persona_name,
                    CMsgClientMMSJoinLobby::get_persona_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSJoinLobby>(
                    "CMsgClientMMSJoinLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobby {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_persona_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSJoinLobby {
    fn eq(&self, other: &CMsgClientMMSJoinLobby) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.persona_name == other.persona_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSJoinLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    chat_room_enter_response: ::std::option::Option<i32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    steam_id_owner: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    members: ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSJoinLobbyResponse {}

impl CMsgClientMMSJoinLobbyResponse {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSJoinLobbyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSJoinLobbyResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSJoinLobbyResponse {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    chat_room_enter_response: ::std::option::Option::None,
                    max_members: ::std::option::Option::None,
                    lobby_type: ::std::option::Option::None,
                    lobby_flags: ::std::option::Option::None,
                    steam_id_owner: ::std::option::Option::None,
                    metadata: ::protobuf::SingularField::none(),
                    members: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional int32 chat_room_enter_response = 3;

    pub fn clear_chat_room_enter_response(&mut self) {
        self.chat_room_enter_response = ::std::option::Option::None;
    }

    pub fn has_chat_room_enter_response(&self) -> bool {
        self.chat_room_enter_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_room_enter_response(&mut self, v: i32) {
        self.chat_room_enter_response = ::std::option::Option::Some(v);
    }

    pub fn get_chat_room_enter_response<'a>(&self) -> i32 {
        self.chat_room_enter_response.unwrap_or(0)
    }

    // optional int32 max_members = 4;

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    pub fn get_max_members<'a>(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    // optional int32 lobby_type = 5;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type<'a>(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    // optional int32 lobby_flags = 6;

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_flags<'a>(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_owner<'a>(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    // optional bytes metadata = 8;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .CMsgClientMMSJoinLobbyResponse.Member members = 9;

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSJoinLobbyResponse_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    pub fn get_members<'a>(&'a self) -> &'a [CMsgClientMMSJoinLobbyResponse_Member] {
        &self.members
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.chat_room_enter_response = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_owner = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                9 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.chat_room_enter_response.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.max_members.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_type.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_flags.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_owner.is_some() {
            my_size += 9;
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        for value in self.members.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.chat_room_enter_response {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.max_members {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.lobby_type {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.lobby_flags {
            try!(os.write_int32(6, v));
        };
        if let Some(v) = self.steam_id_owner {
            try!(os.write_fixed64(7, v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(8, &v));
        };
        for v in self.members.iter() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSJoinLobbyResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSJoinLobbyResponse {
    fn new() -> CMsgClientMMSJoinLobbyResponse {
        CMsgClientMMSJoinLobbyResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSJoinLobbyResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSJoinLobbyResponse::has_app_id,
                    CMsgClientMMSJoinLobbyResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSJoinLobbyResponse::has_steam_id_lobby,
                    CMsgClientMMSJoinLobbyResponse::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "chat_room_enter_response",
                    CMsgClientMMSJoinLobbyResponse::has_chat_room_enter_response,
                    CMsgClientMMSJoinLobbyResponse::get_chat_room_enter_response,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "max_members",
                    CMsgClientMMSJoinLobbyResponse::has_max_members,
                    CMsgClientMMSJoinLobbyResponse::get_max_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_type",
                    CMsgClientMMSJoinLobbyResponse::has_lobby_type,
                    CMsgClientMMSJoinLobbyResponse::get_lobby_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_flags",
                    CMsgClientMMSJoinLobbyResponse::has_lobby_flags,
                    CMsgClientMMSJoinLobbyResponse::get_lobby_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_owner",
                    CMsgClientMMSJoinLobbyResponse::has_steam_id_owner,
                    CMsgClientMMSJoinLobbyResponse::get_steam_id_owner,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSJoinLobbyResponse::has_metadata,
                    CMsgClientMMSJoinLobbyResponse::get_metadata,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "members",
                    CMsgClientMMSJoinLobbyResponse::get_members,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSJoinLobbyResponse>(
                    "CMsgClientMMSJoinLobbyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobbyResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_chat_room_enter_response();
        self.clear_max_members();
        self.clear_lobby_type();
        self.clear_lobby_flags();
        self.clear_steam_id_owner();
        self.clear_metadata();
        self.clear_members();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSJoinLobbyResponse {
    fn eq(&self, other: &CMsgClientMMSJoinLobbyResponse) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.chat_room_enter_response == other.chat_room_enter_response &&
        self.max_members == other.max_members &&
        self.lobby_type == other.lobby_type &&
        self.lobby_flags == other.lobby_flags &&
        self.steam_id_owner == other.steam_id_owner &&
        self.metadata == other.metadata &&
        self.members == other.members &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSJoinLobbyResponse_Member {
    // message fields
    steam_id: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSJoinLobbyResponse_Member {}

impl CMsgClientMMSJoinLobbyResponse_Member {
    pub fn new() -> CMsgClientMMSJoinLobbyResponse_Member {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSJoinLobbyResponse_Member {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSJoinLobbyResponse_Member> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSJoinLobbyResponse_Member,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSJoinLobbyResponse_Member {
                    steam_id: ::std::option::Option::None,
                    persona_name: ::protobuf::SingularField::none(),
                    metadata: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional string persona_name = 2;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        };
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name<'a>(&'a self) -> &'a str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes metadata = 3;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSJoinLobbyResponse_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        for value in self.persona_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.persona_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSJoinLobbyResponse_Member>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSJoinLobbyResponse_Member {
    fn new() -> CMsgClientMMSJoinLobbyResponse_Member {
        CMsgClientMMSJoinLobbyResponse_Member::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSJoinLobbyResponse_Member>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgClientMMSJoinLobbyResponse_Member::has_steam_id,
                    CMsgClientMMSJoinLobbyResponse_Member::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name",
                    CMsgClientMMSJoinLobbyResponse_Member::has_persona_name,
                    CMsgClientMMSJoinLobbyResponse_Member::get_persona_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSJoinLobbyResponse_Member::has_metadata,
                    CMsgClientMMSJoinLobbyResponse_Member::get_metadata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSJoinLobbyResponse_Member>(
                    "CMsgClientMMSJoinLobbyResponse_Member",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSJoinLobbyResponse_Member {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_persona_name();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSJoinLobbyResponse_Member {
    fn eq(&self, other: &CMsgClientMMSJoinLobbyResponse_Member) -> bool {
        self.steam_id == other.steam_id &&
        self.persona_name == other.persona_name &&
        self.metadata == other.metadata &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSJoinLobbyResponse_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSLeaveLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSLeaveLobby {}

impl CMsgClientMMSLeaveLobby {
    pub fn new() -> CMsgClientMMSLeaveLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSLeaveLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSLeaveLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSLeaveLobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSLeaveLobby {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSLeaveLobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSLeaveLobby {
    fn new() -> CMsgClientMMSLeaveLobby {
        CMsgClientMMSLeaveLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSLeaveLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSLeaveLobby::has_app_id,
                    CMsgClientMMSLeaveLobby::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSLeaveLobby::has_steam_id_lobby,
                    CMsgClientMMSLeaveLobby::get_steam_id_lobby,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLeaveLobby>(
                    "CMsgClientMMSLeaveLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSLeaveLobby {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSLeaveLobby {
    fn eq(&self, other: &CMsgClientMMSLeaveLobby) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLeaveLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSLeaveLobbyResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSLeaveLobbyResponse {}

impl CMsgClientMMSLeaveLobbyResponse {
    pub fn new() -> CMsgClientMMSLeaveLobbyResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSLeaveLobbyResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSLeaveLobbyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSLeaveLobbyResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSLeaveLobbyResponse {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional int32 eresult = 3;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientMMSLeaveLobbyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSLeaveLobbyResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSLeaveLobbyResponse {
    fn new() -> CMsgClientMMSLeaveLobbyResponse {
        CMsgClientMMSLeaveLobbyResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSLeaveLobbyResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSLeaveLobbyResponse::has_app_id,
                    CMsgClientMMSLeaveLobbyResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSLeaveLobbyResponse::has_steam_id_lobby,
                    CMsgClientMMSLeaveLobbyResponse::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientMMSLeaveLobbyResponse::has_eresult,
                    CMsgClientMMSLeaveLobbyResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLeaveLobbyResponse>(
                    "CMsgClientMMSLeaveLobbyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSLeaveLobbyResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSLeaveLobbyResponse {
    fn eq(&self, other: &CMsgClientMMSLeaveLobbyResponse) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLeaveLobbyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSGetLobbyList {
    // message fields
    app_id: ::std::option::Option<u32>,
    num_lobbies_requested: ::std::option::Option<i32>,
    cell_id: ::std::option::Option<u32>,
    public_ip: ::std::option::Option<u32>,
    filters: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSGetLobbyList {}

impl CMsgClientMMSGetLobbyList {
    pub fn new() -> CMsgClientMMSGetLobbyList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSGetLobbyList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSGetLobbyList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSGetLobbyList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSGetLobbyList {
                    app_id: ::std::option::Option::None,
                    num_lobbies_requested: ::std::option::Option::None,
                    cell_id: ::std::option::Option::None,
                    public_ip: ::std::option::Option::None,
                    filters: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 num_lobbies_requested = 3;

    pub fn clear_num_lobbies_requested(&mut self) {
        self.num_lobbies_requested = ::std::option::Option::None;
    }

    pub fn has_num_lobbies_requested(&self) -> bool {
        self.num_lobbies_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_lobbies_requested(&mut self, v: i32) {
        self.num_lobbies_requested = ::std::option::Option::Some(v);
    }

    pub fn get_num_lobbies_requested<'a>(&self) -> i32 {
        self.num_lobbies_requested.unwrap_or(0)
    }

    // optional uint32 cell_id = 4;

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id<'a>(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    // optional uint32 public_ip = 5;

    pub fn clear_public_ip(&mut self) {
        self.public_ip = ::std::option::Option::None;
    }

    pub fn has_public_ip(&self) -> bool {
        self.public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_ip(&mut self, v: u32) {
        self.public_ip = ::std::option::Option::Some(v);
    }

    pub fn get_public_ip<'a>(&self) -> u32 {
        self.public_ip.unwrap_or(0)
    }

    // repeated .CMsgClientMMSGetLobbyList.Filter filters = 6;

    pub fn clear_filters(&mut self) {
        self.filters.clear();
    }

    // Param is passed by value, moved
    pub fn set_filters(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter>) {
        self.filters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_filters<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter> {
        &mut self.filters
    }

    // Take field
    pub fn take_filters(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSGetLobbyList_Filter> {
        ::std::mem::replace(&mut self.filters, ::protobuf::RepeatedField::new())
    }

    pub fn get_filters<'a>(&'a self) -> &'a [CMsgClientMMSGetLobbyList_Filter] {
        &self.filters
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.num_lobbies_requested = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.public_ip = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.filters));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_lobbies_requested.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cell_id.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.public_ip.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filters.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.num_lobbies_requested {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.cell_id {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.public_ip {
            try!(os.write_uint32(5, v));
        };
        for v in self.filters.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSGetLobbyList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSGetLobbyList {
    fn new() -> CMsgClientMMSGetLobbyList {
        CMsgClientMMSGetLobbyList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSGetLobbyList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSGetLobbyList::has_app_id,
                    CMsgClientMMSGetLobbyList::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "num_lobbies_requested",
                    CMsgClientMMSGetLobbyList::has_num_lobbies_requested,
                    CMsgClientMMSGetLobbyList::get_num_lobbies_requested,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id",
                    CMsgClientMMSGetLobbyList::has_cell_id,
                    CMsgClientMMSGetLobbyList::get_cell_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "public_ip",
                    CMsgClientMMSGetLobbyList::has_public_ip,
                    CMsgClientMMSGetLobbyList::get_public_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "filters",
                    CMsgClientMMSGetLobbyList::get_filters,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyList>(
                    "CMsgClientMMSGetLobbyList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyList {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_num_lobbies_requested();
        self.clear_cell_id();
        self.clear_public_ip();
        self.clear_filters();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSGetLobbyList {
    fn eq(&self, other: &CMsgClientMMSGetLobbyList) -> bool {
        self.app_id == other.app_id &&
        self.num_lobbies_requested == other.num_lobbies_requested &&
        self.cell_id == other.cell_id &&
        self.public_ip == other.public_ip &&
        self.filters == other.filters &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSGetLobbyList_Filter {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    comparision: ::std::option::Option<i32>,
    filter_type: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSGetLobbyList_Filter {}

impl CMsgClientMMSGetLobbyList_Filter {
    pub fn new() -> CMsgClientMMSGetLobbyList_Filter {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSGetLobbyList_Filter {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSGetLobbyList_Filter> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSGetLobbyList_Filter,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSGetLobbyList_Filter {
                    key: ::protobuf::SingularField::none(),
                    value: ::protobuf::SingularField::none(),
                    comparision: ::std::option::Option::None,
                    filter_type: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string key = 1;

    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        };
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_key<'a>(&'a self) -> &'a str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string value = 2;

    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        };
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_value<'a>(&'a self) -> &'a str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional int32 comparision = 3;

    pub fn clear_comparision(&mut self) {
        self.comparision = ::std::option::Option::None;
    }

    pub fn has_comparision(&self) -> bool {
        self.comparision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comparision(&mut self, v: i32) {
        self.comparision = ::std::option::Option::Some(v);
    }

    pub fn get_comparision<'a>(&self) -> i32 {
        self.comparision.unwrap_or(0)
    }

    // optional int32 filter_type = 4;

    pub fn clear_filter_type(&mut self) {
        self.filter_type = ::std::option::Option::None;
    }

    pub fn has_filter_type(&self) -> bool {
        self.filter_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_type(&mut self, v: i32) {
        self.filter_type = ::std::option::Option::Some(v);
    }

    pub fn get_filter_type<'a>(&self) -> i32 {
        self.filter_type.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyList_Filter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.comparision = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.filter_type = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.key.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.value.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.comparision.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filter_type.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.key.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.value.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.comparision {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.filter_type {
            try!(os.write_int32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSGetLobbyList_Filter>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSGetLobbyList_Filter {
    fn new() -> CMsgClientMMSGetLobbyList_Filter {
        CMsgClientMMSGetLobbyList_Filter::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSGetLobbyList_Filter>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "key",
                    CMsgClientMMSGetLobbyList_Filter::has_key,
                    CMsgClientMMSGetLobbyList_Filter::get_key,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "value",
                    CMsgClientMMSGetLobbyList_Filter::has_value,
                    CMsgClientMMSGetLobbyList_Filter::get_value,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "comparision",
                    CMsgClientMMSGetLobbyList_Filter::has_comparision,
                    CMsgClientMMSGetLobbyList_Filter::get_comparision,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "filter_type",
                    CMsgClientMMSGetLobbyList_Filter::has_filter_type,
                    CMsgClientMMSGetLobbyList_Filter::get_filter_type,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyList_Filter>(
                    "CMsgClientMMSGetLobbyList_Filter",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyList_Filter {
    fn clear(&mut self) {
        self.clear_key();
        self.clear_value();
        self.clear_comparision();
        self.clear_filter_type();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSGetLobbyList_Filter {
    fn eq(&self, other: &CMsgClientMMSGetLobbyList_Filter) -> bool {
        self.key == other.key &&
        self.value == other.value &&
        self.comparision == other.comparision &&
        self.filter_type == other.filter_type &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyList_Filter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSGetLobbyListResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<i32>,
    lobbies: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSGetLobbyListResponse {}

impl CMsgClientMMSGetLobbyListResponse {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSGetLobbyListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSGetLobbyListResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSGetLobbyListResponse {
                    app_id: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    lobbies: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 eresult = 3;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // repeated .CMsgClientMMSGetLobbyListResponse.Lobby lobbies = 4;

    pub fn clear_lobbies(&mut self) {
        self.lobbies.clear();
    }

    // Param is passed by value, moved
    pub fn set_lobbies(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby>) {
        self.lobbies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lobbies<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby> {
        &mut self.lobbies
    }

    // Take field
    pub fn take_lobbies(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSGetLobbyListResponse_Lobby> {
        ::std::mem::replace(&mut self.lobbies, ::protobuf::RepeatedField::new())
    }

    pub fn get_lobbies<'a>(&'a self) -> &'a [CMsgClientMMSGetLobbyListResponse_Lobby] {
        &self.lobbies
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.lobbies));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobbies.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(3, v));
        };
        for v in self.lobbies.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSGetLobbyListResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSGetLobbyListResponse {
    fn new() -> CMsgClientMMSGetLobbyListResponse {
        CMsgClientMMSGetLobbyListResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSGetLobbyListResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSGetLobbyListResponse::has_app_id,
                    CMsgClientMMSGetLobbyListResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientMMSGetLobbyListResponse::has_eresult,
                    CMsgClientMMSGetLobbyListResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "lobbies",
                    CMsgClientMMSGetLobbyListResponse::get_lobbies,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyListResponse>(
                    "CMsgClientMMSGetLobbyListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyListResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_eresult();
        self.clear_lobbies();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSGetLobbyListResponse {
    fn eq(&self, other: &CMsgClientMMSGetLobbyListResponse) -> bool {
        self.app_id == other.app_id &&
        self.eresult == other.eresult &&
        self.lobbies == other.lobbies &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSGetLobbyListResponse_Lobby {
    // message fields
    steam_id: ::std::option::Option<u64>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    num_members: ::std::option::Option<i32>,
    distance: ::std::option::Option<f32>,
    weight: ::std::option::Option<i64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSGetLobbyListResponse_Lobby {}

impl CMsgClientMMSGetLobbyListResponse_Lobby {
    pub fn new() -> CMsgClientMMSGetLobbyListResponse_Lobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSGetLobbyListResponse_Lobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSGetLobbyListResponse_Lobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSGetLobbyListResponse_Lobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSGetLobbyListResponse_Lobby {
                    steam_id: ::std::option::Option::None,
                    max_members: ::std::option::Option::None,
                    lobby_type: ::std::option::Option::None,
                    lobby_flags: ::std::option::Option::None,
                    metadata: ::protobuf::SingularField::none(),
                    num_members: ::std::option::Option::None,
                    distance: ::std::option::Option::None,
                    weight: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional int32 max_members = 2;

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    pub fn get_max_members<'a>(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    // optional int32 lobby_type = 3;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type<'a>(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    // optional int32 lobby_flags = 4;

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_flags<'a>(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    // optional bytes metadata = 5;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional int32 num_members = 6;

    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    pub fn get_num_members<'a>(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }

    // optional float distance = 7;

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }

    pub fn get_distance<'a>(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    // optional int64 weight = 8;

    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i64) {
        self.weight = ::std::option::Option::Some(v);
    }

    pub fn get_weight<'a>(&self) -> i64 {
        self.weight.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.num_members = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_float());
                    self.distance = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int64());
                    self.weight = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        for value in self.max_members.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_type.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_flags.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in self.num_members.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.distance.is_some() {
            my_size += 5;
        };
        for value in self.weight.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.max_members {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.lobby_type {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.lobby_flags {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(5, &v));
        };
        if let Some(v) = self.num_members {
            try!(os.write_int32(6, v));
        };
        if let Some(v) = self.distance {
            try!(os.write_float(7, v));
        };
        if let Some(v) = self.weight {
            try!(os.write_int64(8, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSGetLobbyListResponse_Lobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn new() -> CMsgClientMMSGetLobbyListResponse_Lobby {
        CMsgClientMMSGetLobbyListResponse_Lobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSGetLobbyListResponse_Lobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_steam_id,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "max_members",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_max_members,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_max_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_type",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_lobby_type,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_lobby_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_flags",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_lobby_flags,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_lobby_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_metadata,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_metadata,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "num_members",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_num_members,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_num_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor(
                    "distance",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_distance,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_distance,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor(
                    "weight",
                    CMsgClientMMSGetLobbyListResponse_Lobby::has_weight,
                    CMsgClientMMSGetLobbyListResponse_Lobby::get_weight,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyListResponse_Lobby>(
                    "CMsgClientMMSGetLobbyListResponse_Lobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_max_members();
        self.clear_lobby_type();
        self.clear_lobby_flags();
        self.clear_metadata();
        self.clear_num_members();
        self.clear_distance();
        self.clear_weight();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn eq(&self, other: &CMsgClientMMSGetLobbyListResponse_Lobby) -> bool {
        self.steam_id == other.steam_id &&
        self.max_members == other.max_members &&
        self.lobby_type == other.lobby_type &&
        self.lobby_flags == other.lobby_flags &&
        self.metadata == other.metadata &&
        self.num_members == other.num_members &&
        self.distance == other.distance &&
        self.weight == other.weight &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyListResponse_Lobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSetLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_member: ::std::option::Option<u64>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSetLobbyData {}

impl CMsgClientMMSSetLobbyData {
    pub fn new() -> CMsgClientMMSSetLobbyData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSetLobbyData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSetLobbyData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSetLobbyData,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSetLobbyData {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_member: ::std::option::Option::None,
                    max_members: ::std::option::Option::None,
                    lobby_type: ::std::option::Option::None,
                    lobby_flags: ::std::option::Option::None,
                    metadata: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_member = 3;

    pub fn clear_steam_id_member(&mut self) {
        self.steam_id_member = ::std::option::Option::None;
    }

    pub fn has_steam_id_member(&self) -> bool {
        self.steam_id_member.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_member(&mut self, v: u64) {
        self.steam_id_member = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_member<'a>(&self) -> u64 {
        self.steam_id_member.unwrap_or(0)
    }

    // optional int32 max_members = 4;

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    pub fn get_max_members<'a>(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    // optional int32 lobby_type = 5;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type<'a>(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    // optional int32 lobby_flags = 6;

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_flags<'a>(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    // optional bytes metadata = 7;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_member = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_member.is_some() {
            my_size += 9;
        };
        for value in self.max_members.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_type.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_flags.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_member {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.max_members {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.lobby_type {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.lobby_flags {
            try!(os.write_int32(6, v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(7, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSetLobbyData>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSetLobbyData {
    fn new() -> CMsgClientMMSSetLobbyData {
        CMsgClientMMSSetLobbyData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSetLobbyData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSetLobbyData::has_app_id,
                    CMsgClientMMSSetLobbyData::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSetLobbyData::has_steam_id_lobby,
                    CMsgClientMMSSetLobbyData::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_member",
                    CMsgClientMMSSetLobbyData::has_steam_id_member,
                    CMsgClientMMSSetLobbyData::get_steam_id_member,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "max_members",
                    CMsgClientMMSSetLobbyData::has_max_members,
                    CMsgClientMMSSetLobbyData::get_max_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_type",
                    CMsgClientMMSSetLobbyData::has_lobby_type,
                    CMsgClientMMSSetLobbyData::get_lobby_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_flags",
                    CMsgClientMMSSetLobbyData::has_lobby_flags,
                    CMsgClientMMSSetLobbyData::get_lobby_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSSetLobbyData::has_metadata,
                    CMsgClientMMSSetLobbyData::get_metadata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyData>(
                    "CMsgClientMMSSetLobbyData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyData {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_member();
        self.clear_max_members();
        self.clear_lobby_type();
        self.clear_lobby_flags();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSetLobbyData {
    fn eq(&self, other: &CMsgClientMMSSetLobbyData) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_member == other.steam_id_member &&
        self.max_members == other.max_members &&
        self.lobby_type == other.lobby_type &&
        self.lobby_flags == other.lobby_flags &&
        self.metadata == other.metadata &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSetLobbyDataResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSetLobbyDataResponse {}

impl CMsgClientMMSSetLobbyDataResponse {
    pub fn new() -> CMsgClientMMSSetLobbyDataResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSetLobbyDataResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSetLobbyDataResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSetLobbyDataResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSetLobbyDataResponse {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional int32 eresult = 3;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyDataResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSetLobbyDataResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSetLobbyDataResponse {
    fn new() -> CMsgClientMMSSetLobbyDataResponse {
        CMsgClientMMSSetLobbyDataResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSetLobbyDataResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSetLobbyDataResponse::has_app_id,
                    CMsgClientMMSSetLobbyDataResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSetLobbyDataResponse::has_steam_id_lobby,
                    CMsgClientMMSSetLobbyDataResponse::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientMMSSetLobbyDataResponse::has_eresult,
                    CMsgClientMMSSetLobbyDataResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyDataResponse>(
                    "CMsgClientMMSSetLobbyDataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyDataResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSetLobbyDataResponse {
    fn eq(&self, other: &CMsgClientMMSSetLobbyDataResponse) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSGetLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSGetLobbyData {}

impl CMsgClientMMSGetLobbyData {
    pub fn new() -> CMsgClientMMSGetLobbyData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSGetLobbyData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSGetLobbyData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSGetLobbyData,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSGetLobbyData {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSGetLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSGetLobbyData>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSGetLobbyData {
    fn new() -> CMsgClientMMSGetLobbyData {
        CMsgClientMMSGetLobbyData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSGetLobbyData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSGetLobbyData::has_app_id,
                    CMsgClientMMSGetLobbyData::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSGetLobbyData::has_steam_id_lobby,
                    CMsgClientMMSGetLobbyData::get_steam_id_lobby,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSGetLobbyData>(
                    "CMsgClientMMSGetLobbyData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSGetLobbyData {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSGetLobbyData {
    fn eq(&self, other: &CMsgClientMMSGetLobbyData) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSGetLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSLobbyData {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    num_members: ::std::option::Option<i32>,
    max_members: ::std::option::Option<i32>,
    lobby_type: ::std::option::Option<i32>,
    lobby_flags: ::std::option::Option<i32>,
    steam_id_owner: ::std::option::Option<u64>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    members: ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member>,
    lobby_cellid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSLobbyData {}

impl CMsgClientMMSLobbyData {
    pub fn new() -> CMsgClientMMSLobbyData {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSLobbyData {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSLobbyData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSLobbyData,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSLobbyData {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    num_members: ::std::option::Option::None,
                    max_members: ::std::option::Option::None,
                    lobby_type: ::std::option::Option::None,
                    lobby_flags: ::std::option::Option::None,
                    steam_id_owner: ::std::option::Option::None,
                    metadata: ::protobuf::SingularField::none(),
                    members: ::protobuf::RepeatedField::new(),
                    lobby_cellid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional int32 num_members = 3;

    pub fn clear_num_members(&mut self) {
        self.num_members = ::std::option::Option::None;
    }

    pub fn has_num_members(&self) -> bool {
        self.num_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_members(&mut self, v: i32) {
        self.num_members = ::std::option::Option::Some(v);
    }

    pub fn get_num_members<'a>(&self) -> i32 {
        self.num_members.unwrap_or(0)
    }

    // optional int32 max_members = 4;

    pub fn clear_max_members(&mut self) {
        self.max_members = ::std::option::Option::None;
    }

    pub fn has_max_members(&self) -> bool {
        self.max_members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_members(&mut self, v: i32) {
        self.max_members = ::std::option::Option::Some(v);
    }

    pub fn get_max_members<'a>(&self) -> i32 {
        self.max_members.unwrap_or(0)
    }

    // optional int32 lobby_type = 5;

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_type<'a>(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    // optional int32 lobby_flags = 6;

    pub fn clear_lobby_flags(&mut self) {
        self.lobby_flags = ::std::option::Option::None;
    }

    pub fn has_lobby_flags(&self) -> bool {
        self.lobby_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_flags(&mut self, v: i32) {
        self.lobby_flags = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_flags<'a>(&self) -> i32 {
        self.lobby_flags.unwrap_or(0)
    }

    // optional fixed64 steam_id_owner = 7;

    pub fn clear_steam_id_owner(&mut self) {
        self.steam_id_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_owner(&self) -> bool {
        self.steam_id_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_owner(&mut self, v: u64) {
        self.steam_id_owner = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_owner<'a>(&self) -> u64 {
        self.steam_id_owner.unwrap_or(0)
    }

    // optional bytes metadata = 8;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .CMsgClientMMSLobbyData.Member members = 9;

    pub fn clear_members(&mut self) {
        self.members.clear();
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member>) {
        self.members = v;
    }

    // Mutable pointer to the field.
    pub fn mut_members<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member> {
        &mut self.members
    }

    // Take field
    pub fn take_members(&mut self) -> ::protobuf::RepeatedField<CMsgClientMMSLobbyData_Member> {
        ::std::mem::replace(&mut self.members, ::protobuf::RepeatedField::new())
    }

    pub fn get_members<'a>(&'a self) -> &'a [CMsgClientMMSLobbyData_Member] {
        &self.members
    }

    // optional uint32 lobby_cellid = 10;

    pub fn clear_lobby_cellid(&mut self) {
        self.lobby_cellid = ::std::option::Option::None;
    }

    pub fn has_lobby_cellid(&self) -> bool {
        self.lobby_cellid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_cellid(&mut self, v: u32) {
        self.lobby_cellid = ::std::option::Option::Some(v);
    }

    pub fn get_lobby_cellid<'a>(&self) -> u32 {
        self.lobby_cellid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.num_members = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.max_members = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_type = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.lobby_flags = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_owner = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                9 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.members));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.lobby_cellid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.num_members.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.max_members.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_type.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.lobby_flags.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_owner.is_some() {
            my_size += 9;
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(8, &value);
        };
        for value in self.members.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.lobby_cellid.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.num_members {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.max_members {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.lobby_type {
            try!(os.write_int32(5, v));
        };
        if let Some(v) = self.lobby_flags {
            try!(os.write_int32(6, v));
        };
        if let Some(v) = self.steam_id_owner {
            try!(os.write_fixed64(7, v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(8, &v));
        };
        for v in self.members.iter() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.lobby_cellid {
            try!(os.write_uint32(10, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSLobbyData>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSLobbyData {
    fn new() -> CMsgClientMMSLobbyData {
        CMsgClientMMSLobbyData::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSLobbyData>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSLobbyData::has_app_id,
                    CMsgClientMMSLobbyData::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSLobbyData::has_steam_id_lobby,
                    CMsgClientMMSLobbyData::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "num_members",
                    CMsgClientMMSLobbyData::has_num_members,
                    CMsgClientMMSLobbyData::get_num_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "max_members",
                    CMsgClientMMSLobbyData::has_max_members,
                    CMsgClientMMSLobbyData::get_max_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_type",
                    CMsgClientMMSLobbyData::has_lobby_type,
                    CMsgClientMMSLobbyData::get_lobby_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "lobby_flags",
                    CMsgClientMMSLobbyData::has_lobby_flags,
                    CMsgClientMMSLobbyData::get_lobby_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_owner",
                    CMsgClientMMSLobbyData::has_steam_id_owner,
                    CMsgClientMMSLobbyData::get_steam_id_owner,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSLobbyData::has_metadata,
                    CMsgClientMMSLobbyData::get_metadata,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "members",
                    CMsgClientMMSLobbyData::get_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "lobby_cellid",
                    CMsgClientMMSLobbyData::has_lobby_cellid,
                    CMsgClientMMSLobbyData::get_lobby_cellid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyData>(
                    "CMsgClientMMSLobbyData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyData {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_num_members();
        self.clear_max_members();
        self.clear_lobby_type();
        self.clear_lobby_flags();
        self.clear_steam_id_owner();
        self.clear_metadata();
        self.clear_members();
        self.clear_lobby_cellid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSLobbyData {
    fn eq(&self, other: &CMsgClientMMSLobbyData) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.num_members == other.num_members &&
        self.max_members == other.max_members &&
        self.lobby_type == other.lobby_type &&
        self.lobby_flags == other.lobby_flags &&
        self.steam_id_owner == other.steam_id_owner &&
        self.metadata == other.metadata &&
        self.members == other.members &&
        self.lobby_cellid == other.lobby_cellid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSLobbyData_Member {
    // message fields
    steam_id: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    metadata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSLobbyData_Member {}

impl CMsgClientMMSLobbyData_Member {
    pub fn new() -> CMsgClientMMSLobbyData_Member {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSLobbyData_Member {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSLobbyData_Member> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSLobbyData_Member,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSLobbyData_Member {
                    steam_id: ::std::option::Option::None,
                    persona_name: ::protobuf::SingularField::none(),
                    metadata: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional string persona_name = 2;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        };
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name<'a>(&'a self) -> &'a str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes metadata = 3;

    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::vec::Vec<u8>) {
        self.metadata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.metadata.is_none() {
            self.metadata.set_default();
        };
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::vec::Vec<u8> {
        self.metadata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_metadata<'a>(&'a self) -> &'a [u8] {
        match self.metadata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyData_Member {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.metadata));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        for value in self.persona_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.metadata.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.persona_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.metadata.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSLobbyData_Member>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSLobbyData_Member {
    fn new() -> CMsgClientMMSLobbyData_Member {
        CMsgClientMMSLobbyData_Member::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSLobbyData_Member>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgClientMMSLobbyData_Member::has_steam_id,
                    CMsgClientMMSLobbyData_Member::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name",
                    CMsgClientMMSLobbyData_Member::has_persona_name,
                    CMsgClientMMSLobbyData_Member::get_persona_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "metadata",
                    CMsgClientMMSLobbyData_Member::has_metadata,
                    CMsgClientMMSLobbyData_Member::get_metadata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyData_Member>(
                    "CMsgClientMMSLobbyData_Member",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyData_Member {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_persona_name();
        self.clear_metadata();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSLobbyData_Member {
    fn eq(&self, other: &CMsgClientMMSLobbyData_Member) -> bool {
        self.steam_id == other.steam_id &&
        self.persona_name == other.persona_name &&
        self.metadata == other.metadata &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyData_Member {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSendLobbyChatMsg {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_target: ::std::option::Option<u64>,
    lobby_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSendLobbyChatMsg {}

impl CMsgClientMMSSendLobbyChatMsg {
    pub fn new() -> CMsgClientMMSSendLobbyChatMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSendLobbyChatMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSendLobbyChatMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSendLobbyChatMsg,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSendLobbyChatMsg {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_target: ::std::option::Option::None,
                    lobby_message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_target = 3;

    pub fn clear_steam_id_target(&mut self) {
        self.steam_id_target = ::std::option::Option::None;
    }

    pub fn has_steam_id_target(&self) -> bool {
        self.steam_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_target(&mut self, v: u64) {
        self.steam_id_target = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_target<'a>(&self) -> u64 {
        self.steam_id_target.unwrap_or(0)
    }

    // optional bytes lobby_message = 4;

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message.clear();
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message.set_default();
        };
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_lobby_message<'a>(&'a self) -> &'a [u8] {
        match self.lobby_message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSSendLobbyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_target = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lobby_message));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_target.is_some() {
            my_size += 9;
        };
        for value in self.lobby_message.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_target {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.lobby_message.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSendLobbyChatMsg>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSendLobbyChatMsg {
    fn new() -> CMsgClientMMSSendLobbyChatMsg {
        CMsgClientMMSSendLobbyChatMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSendLobbyChatMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSendLobbyChatMsg::has_app_id,
                    CMsgClientMMSSendLobbyChatMsg::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSendLobbyChatMsg::has_steam_id_lobby,
                    CMsgClientMMSSendLobbyChatMsg::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_target",
                    CMsgClientMMSSendLobbyChatMsg::has_steam_id_target,
                    CMsgClientMMSSendLobbyChatMsg::get_steam_id_target,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "lobby_message",
                    CMsgClientMMSSendLobbyChatMsg::has_lobby_message,
                    CMsgClientMMSSendLobbyChatMsg::get_lobby_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSendLobbyChatMsg>(
                    "CMsgClientMMSSendLobbyChatMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSendLobbyChatMsg {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_target();
        self.clear_lobby_message();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSendLobbyChatMsg {
    fn eq(&self, other: &CMsgClientMMSSendLobbyChatMsg) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_target == other.steam_id_target &&
        self.lobby_message == other.lobby_message &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSendLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSLobbyChatMsg {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_sender: ::std::option::Option<u64>,
    lobby_message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSLobbyChatMsg {}

impl CMsgClientMMSLobbyChatMsg {
    pub fn new() -> CMsgClientMMSLobbyChatMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSLobbyChatMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSLobbyChatMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSLobbyChatMsg,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSLobbyChatMsg {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_sender: ::std::option::Option::None,
                    lobby_message: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_sender = 3;

    pub fn clear_steam_id_sender(&mut self) {
        self.steam_id_sender = ::std::option::Option::None;
    }

    pub fn has_steam_id_sender(&self) -> bool {
        self.steam_id_sender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_sender(&mut self, v: u64) {
        self.steam_id_sender = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_sender<'a>(&self) -> u64 {
        self.steam_id_sender.unwrap_or(0)
    }

    // optional bytes lobby_message = 4;

    pub fn clear_lobby_message(&mut self) {
        self.lobby_message.clear();
    }

    pub fn has_lobby_message(&self) -> bool {
        self.lobby_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.lobby_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_message<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.lobby_message.is_none() {
            self.lobby_message.set_default();
        };
        self.lobby_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_message(&mut self) -> ::std::vec::Vec<u8> {
        self.lobby_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_lobby_message<'a>(&'a self) -> &'a [u8] {
        match self.lobby_message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyChatMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_sender = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.lobby_message));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_sender.is_some() {
            my_size += 9;
        };
        for value in self.lobby_message.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_sender {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.lobby_message.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSLobbyChatMsg>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSLobbyChatMsg {
    fn new() -> CMsgClientMMSLobbyChatMsg {
        CMsgClientMMSLobbyChatMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSLobbyChatMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSLobbyChatMsg::has_app_id,
                    CMsgClientMMSLobbyChatMsg::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSLobbyChatMsg::has_steam_id_lobby,
                    CMsgClientMMSLobbyChatMsg::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_sender",
                    CMsgClientMMSLobbyChatMsg::has_steam_id_sender,
                    CMsgClientMMSLobbyChatMsg::get_steam_id_sender,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "lobby_message",
                    CMsgClientMMSLobbyChatMsg::has_lobby_message,
                    CMsgClientMMSLobbyChatMsg::get_lobby_message,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyChatMsg>(
                    "CMsgClientMMSLobbyChatMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyChatMsg {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_sender();
        self.clear_lobby_message();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSLobbyChatMsg {
    fn eq(&self, other: &CMsgClientMMSLobbyChatMsg) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_sender == other.steam_id_sender &&
        self.lobby_message == other.lobby_message &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyChatMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSetLobbyOwner {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_new_owner: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSetLobbyOwner {}

impl CMsgClientMMSSetLobbyOwner {
    pub fn new() -> CMsgClientMMSSetLobbyOwner {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSetLobbyOwner {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSetLobbyOwner> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSetLobbyOwner,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSetLobbyOwner {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_new_owner: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_new_owner = 3;

    pub fn clear_steam_id_new_owner(&mut self) {
        self.steam_id_new_owner = ::std::option::Option::None;
    }

    pub fn has_steam_id_new_owner(&self) -> bool {
        self.steam_id_new_owner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_new_owner(&mut self, v: u64) {
        self.steam_id_new_owner = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_new_owner<'a>(&self) -> u64 {
        self.steam_id_new_owner.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwner {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_new_owner = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_new_owner.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_new_owner {
            try!(os.write_fixed64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSetLobbyOwner>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSetLobbyOwner {
    fn new() -> CMsgClientMMSSetLobbyOwner {
        CMsgClientMMSSetLobbyOwner::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSetLobbyOwner>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSetLobbyOwner::has_app_id,
                    CMsgClientMMSSetLobbyOwner::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSetLobbyOwner::has_steam_id_lobby,
                    CMsgClientMMSSetLobbyOwner::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_new_owner",
                    CMsgClientMMSSetLobbyOwner::has_steam_id_new_owner,
                    CMsgClientMMSSetLobbyOwner::get_steam_id_new_owner,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyOwner>(
                    "CMsgClientMMSSetLobbyOwner",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyOwner {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_new_owner();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSetLobbyOwner {
    fn eq(&self, other: &CMsgClientMMSSetLobbyOwner) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_new_owner == other.steam_id_new_owner &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyOwner {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSetLobbyOwnerResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSetLobbyOwnerResponse {}

impl CMsgClientMMSSetLobbyOwnerResponse {
    pub fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSetLobbyOwnerResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSetLobbyOwnerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSetLobbyOwnerResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSetLobbyOwnerResponse {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional int32 eresult = 3;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyOwnerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSetLobbyOwnerResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSetLobbyOwnerResponse {
    fn new() -> CMsgClientMMSSetLobbyOwnerResponse {
        CMsgClientMMSSetLobbyOwnerResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSetLobbyOwnerResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSetLobbyOwnerResponse::has_app_id,
                    CMsgClientMMSSetLobbyOwnerResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSetLobbyOwnerResponse::has_steam_id_lobby,
                    CMsgClientMMSSetLobbyOwnerResponse::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientMMSSetLobbyOwnerResponse::has_eresult,
                    CMsgClientMMSSetLobbyOwnerResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyOwnerResponse>(
                    "CMsgClientMMSSetLobbyOwnerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyOwnerResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSetLobbyOwnerResponse {
    fn eq(&self, other: &CMsgClientMMSSetLobbyOwnerResponse) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyOwnerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSetLobbyLinked {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_lobby2: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSetLobbyLinked {}

impl CMsgClientMMSSetLobbyLinked {
    pub fn new() -> CMsgClientMMSSetLobbyLinked {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSetLobbyLinked {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSetLobbyLinked> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSetLobbyLinked,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSetLobbyLinked {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_lobby2: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby2 = 3;

    pub fn clear_steam_id_lobby2(&mut self) {
        self.steam_id_lobby2 = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby2(&self) -> bool {
        self.steam_id_lobby2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby2(&mut self, v: u64) {
        self.steam_id_lobby2 = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby2<'a>(&self) -> u64 {
        self.steam_id_lobby2.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyLinked {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby2 = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_lobby2.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_lobby2 {
            try!(os.write_fixed64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSetLobbyLinked>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSetLobbyLinked {
    fn new() -> CMsgClientMMSSetLobbyLinked {
        CMsgClientMMSSetLobbyLinked::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSetLobbyLinked>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSetLobbyLinked::has_app_id,
                    CMsgClientMMSSetLobbyLinked::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSetLobbyLinked::has_steam_id_lobby,
                    CMsgClientMMSSetLobbyLinked::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby2",
                    CMsgClientMMSSetLobbyLinked::has_steam_id_lobby2,
                    CMsgClientMMSSetLobbyLinked::get_steam_id_lobby2,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyLinked>(
                    "CMsgClientMMSSetLobbyLinked",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyLinked {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_lobby2();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSetLobbyLinked {
    fn eq(&self, other: &CMsgClientMMSSetLobbyLinked) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_lobby2 == other.steam_id_lobby2 &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyLinked {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSSetLobbyGameServer {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSSetLobbyGameServer {}

impl CMsgClientMMSSetLobbyGameServer {
    pub fn new() -> CMsgClientMMSSetLobbyGameServer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSSetLobbyGameServer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSSetLobbyGameServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSSetLobbyGameServer,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSSetLobbyGameServer {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    game_server_ip: ::std::option::Option::None,
                    game_server_port: ::std::option::Option::None,
                    game_server_steam_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional uint32 game_server_ip = 3;

    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip = ::std::option::Option::None;
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: u32) {
        self.game_server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_ip<'a>(&self) -> u32 {
        self.game_server_ip.unwrap_or(0)
    }

    // optional uint32 game_server_port = 4;

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_port<'a>(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_steam_id<'a>(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSSetLobbyGameServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_server_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_server_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.game_server_ip.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_server_port.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.game_server_steam_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.game_server_ip {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.game_server_port {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.game_server_steam_id {
            try!(os.write_fixed64(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSSetLobbyGameServer>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSSetLobbyGameServer {
    fn new() -> CMsgClientMMSSetLobbyGameServer {
        CMsgClientMMSSetLobbyGameServer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSSetLobbyGameServer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSSetLobbyGameServer::has_app_id,
                    CMsgClientMMSSetLobbyGameServer::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSSetLobbyGameServer::has_steam_id_lobby,
                    CMsgClientMMSSetLobbyGameServer::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_server_ip",
                    CMsgClientMMSSetLobbyGameServer::has_game_server_ip,
                    CMsgClientMMSSetLobbyGameServer::get_game_server_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_server_port",
                    CMsgClientMMSSetLobbyGameServer::has_game_server_port,
                    CMsgClientMMSSetLobbyGameServer::get_game_server_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_server_steam_id",
                    CMsgClientMMSSetLobbyGameServer::has_game_server_steam_id,
                    CMsgClientMMSSetLobbyGameServer::get_game_server_steam_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSSetLobbyGameServer>(
                    "CMsgClientMMSSetLobbyGameServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSSetLobbyGameServer {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_game_server_ip();
        self.clear_game_server_port();
        self.clear_game_server_steam_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSSetLobbyGameServer {
    fn eq(&self, other: &CMsgClientMMSSetLobbyGameServer) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.game_server_ip == other.game_server_ip &&
        self.game_server_port == other.game_server_port &&
        self.game_server_steam_id == other.game_server_steam_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSSetLobbyGameServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSLobbyGameServerSet {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    game_server_ip: ::std::option::Option<u32>,
    game_server_port: ::std::option::Option<u32>,
    game_server_steam_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSLobbyGameServerSet {}

impl CMsgClientMMSLobbyGameServerSet {
    pub fn new() -> CMsgClientMMSLobbyGameServerSet {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSLobbyGameServerSet {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSLobbyGameServerSet> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSLobbyGameServerSet,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSLobbyGameServerSet {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    game_server_ip: ::std::option::Option::None,
                    game_server_port: ::std::option::Option::None,
                    game_server_steam_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional uint32 game_server_ip = 3;

    pub fn clear_game_server_ip(&mut self) {
        self.game_server_ip = ::std::option::Option::None;
    }

    pub fn has_game_server_ip(&self) -> bool {
        self.game_server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_ip(&mut self, v: u32) {
        self.game_server_ip = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_ip<'a>(&self) -> u32 {
        self.game_server_ip.unwrap_or(0)
    }

    // optional uint32 game_server_port = 4;

    pub fn clear_game_server_port(&mut self) {
        self.game_server_port = ::std::option::Option::None;
    }

    pub fn has_game_server_port(&self) -> bool {
        self.game_server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_port(&mut self, v: u32) {
        self.game_server_port = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_port<'a>(&self) -> u32 {
        self.game_server_port.unwrap_or(0)
    }

    // optional fixed64 game_server_steam_id = 5;

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_server_steam_id<'a>(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSLobbyGameServerSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_server_ip = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.game_server_port = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_server_steam_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        for value in self.game_server_ip.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.game_server_port.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.game_server_steam_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.game_server_ip {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.game_server_port {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.game_server_steam_id {
            try!(os.write_fixed64(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSLobbyGameServerSet>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSLobbyGameServerSet {
    fn new() -> CMsgClientMMSLobbyGameServerSet {
        CMsgClientMMSLobbyGameServerSet::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSLobbyGameServerSet>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSLobbyGameServerSet::has_app_id,
                    CMsgClientMMSLobbyGameServerSet::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSLobbyGameServerSet::has_steam_id_lobby,
                    CMsgClientMMSLobbyGameServerSet::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_server_ip",
                    CMsgClientMMSLobbyGameServerSet::has_game_server_ip,
                    CMsgClientMMSLobbyGameServerSet::get_game_server_ip,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "game_server_port",
                    CMsgClientMMSLobbyGameServerSet::has_game_server_port,
                    CMsgClientMMSLobbyGameServerSet::get_game_server_port,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_server_steam_id",
                    CMsgClientMMSLobbyGameServerSet::has_game_server_steam_id,
                    CMsgClientMMSLobbyGameServerSet::get_game_server_steam_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSLobbyGameServerSet>(
                    "CMsgClientMMSLobbyGameServerSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSLobbyGameServerSet {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_game_server_ip();
        self.clear_game_server_port();
        self.clear_game_server_steam_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSLobbyGameServerSet {
    fn eq(&self, other: &CMsgClientMMSLobbyGameServerSet) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.game_server_ip == other.game_server_ip &&
        self.game_server_port == other.game_server_port &&
        self.game_server_steam_id == other.game_server_steam_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSLobbyGameServerSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSUserJoinedLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSUserJoinedLobby {}

impl CMsgClientMMSUserJoinedLobby {
    pub fn new() -> CMsgClientMMSUserJoinedLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSUserJoinedLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSUserJoinedLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSUserJoinedLobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSUserJoinedLobby {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_user: ::std::option::Option::None,
                    persona_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_user = 3;

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_user<'a>(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    // optional string persona_name = 4;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        };
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name<'a>(&'a self) -> &'a str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSUserJoinedLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_user = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_user.is_some() {
            my_size += 9;
        };
        for value in self.persona_name.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_user {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.persona_name.as_ref() {
            try!(os.write_string(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSUserJoinedLobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSUserJoinedLobby {
    fn new() -> CMsgClientMMSUserJoinedLobby {
        CMsgClientMMSUserJoinedLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSUserJoinedLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSUserJoinedLobby::has_app_id,
                    CMsgClientMMSUserJoinedLobby::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSUserJoinedLobby::has_steam_id_lobby,
                    CMsgClientMMSUserJoinedLobby::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_user",
                    CMsgClientMMSUserJoinedLobby::has_steam_id_user,
                    CMsgClientMMSUserJoinedLobby::get_steam_id_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name",
                    CMsgClientMMSUserJoinedLobby::has_persona_name,
                    CMsgClientMMSUserJoinedLobby::get_persona_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSUserJoinedLobby>(
                    "CMsgClientMMSUserJoinedLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSUserJoinedLobby {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_user();
        self.clear_persona_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSUserJoinedLobby {
    fn eq(&self, other: &CMsgClientMMSUserJoinedLobby) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_user == other.steam_id_user &&
        self.persona_name == other.persona_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSUserJoinedLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSUserLeftLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user: ::std::option::Option<u64>,
    persona_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSUserLeftLobby {}

impl CMsgClientMMSUserLeftLobby {
    pub fn new() -> CMsgClientMMSUserLeftLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSUserLeftLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSUserLeftLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSUserLeftLobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSUserLeftLobby {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_user: ::std::option::Option::None,
                    persona_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_user = 3;

    pub fn clear_steam_id_user(&mut self) {
        self.steam_id_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_user(&self) -> bool {
        self.steam_id_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user(&mut self, v: u64) {
        self.steam_id_user = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_user<'a>(&self) -> u64 {
        self.steam_id_user.unwrap_or(0)
    }

    // optional string persona_name = 4;

    pub fn clear_persona_name(&mut self) {
        self.persona_name.clear();
    }

    pub fn has_persona_name(&self) -> bool {
        self.persona_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name(&mut self, v: ::std::string::String) {
        self.persona_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name.is_none() {
            self.persona_name.set_default();
        };
        self.persona_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name(&mut self) -> ::std::string::String {
        self.persona_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name<'a>(&'a self) -> &'a str {
        match self.persona_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientMMSUserLeftLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_user = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_user.is_some() {
            my_size += 9;
        };
        for value in self.persona_name.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_user {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.persona_name.as_ref() {
            try!(os.write_string(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSUserLeftLobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSUserLeftLobby {
    fn new() -> CMsgClientMMSUserLeftLobby {
        CMsgClientMMSUserLeftLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSUserLeftLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSUserLeftLobby::has_app_id,
                    CMsgClientMMSUserLeftLobby::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSUserLeftLobby::has_steam_id_lobby,
                    CMsgClientMMSUserLeftLobby::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_user",
                    CMsgClientMMSUserLeftLobby::has_steam_id_user,
                    CMsgClientMMSUserLeftLobby::get_steam_id_user,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name",
                    CMsgClientMMSUserLeftLobby::has_persona_name,
                    CMsgClientMMSUserLeftLobby::get_persona_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSUserLeftLobby>(
                    "CMsgClientMMSUserLeftLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSUserLeftLobby {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_user();
        self.clear_persona_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSUserLeftLobby {
    fn eq(&self, other: &CMsgClientMMSUserLeftLobby) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_user == other.steam_id_user &&
        self.persona_name == other.persona_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSUserLeftLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientMMSInviteToLobby {
    // message fields
    app_id: ::std::option::Option<u32>,
    steam_id_lobby: ::std::option::Option<u64>,
    steam_id_user_invited: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientMMSInviteToLobby {}

impl CMsgClientMMSInviteToLobby {
    pub fn new() -> CMsgClientMMSInviteToLobby {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientMMSInviteToLobby {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientMMSInviteToLobby> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientMMSInviteToLobby,
        };
        unsafe {
            instance.get(|| {
                CMsgClientMMSInviteToLobby {
                    app_id: ::std::option::Option::None,
                    steam_id_lobby: ::std::option::Option::None,
                    steam_id_user_invited: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional fixed64 steam_id_lobby = 2;

    pub fn clear_steam_id_lobby(&mut self) {
        self.steam_id_lobby = ::std::option::Option::None;
    }

    pub fn has_steam_id_lobby(&self) -> bool {
        self.steam_id_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_lobby(&mut self, v: u64) {
        self.steam_id_lobby = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_lobby<'a>(&self) -> u64 {
        self.steam_id_lobby.unwrap_or(0)
    }

    // optional fixed64 steam_id_user_invited = 3;

    pub fn clear_steam_id_user_invited(&mut self) {
        self.steam_id_user_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_user_invited(&self) -> bool {
        self.steam_id_user_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_user_invited(&mut self, v: u64) {
        self.steam_id_user_invited = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_user_invited<'a>(&self) -> u64 {
        self.steam_id_user_invited.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientMMSInviteToLobby {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_lobby = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_user_invited = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_lobby.is_some() {
            my_size += 9;
        };
        if self.steam_id_user_invited.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.steam_id_lobby {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_user_invited {
            try!(os.write_fixed64(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientMMSInviteToLobby>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientMMSInviteToLobby {
    fn new() -> CMsgClientMMSInviteToLobby {
        CMsgClientMMSInviteToLobby::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientMMSInviteToLobby>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientMMSInviteToLobby::has_app_id,
                    CMsgClientMMSInviteToLobby::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_lobby",
                    CMsgClientMMSInviteToLobby::has_steam_id_lobby,
                    CMsgClientMMSInviteToLobby::get_steam_id_lobby,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_user_invited",
                    CMsgClientMMSInviteToLobby::has_steam_id_user_invited,
                    CMsgClientMMSInviteToLobby::get_steam_id_user_invited,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientMMSInviteToLobby>(
                    "CMsgClientMMSInviteToLobby",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientMMSInviteToLobby {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_steam_id_lobby();
        self.clear_steam_id_user_invited();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientMMSInviteToLobby {
    fn eq(&self, other: &CMsgClientMMSInviteToLobby) -> bool {
        self.app_id == other.app_id &&
        self.steam_id_lobby == other.steam_id_lobby &&
        self.steam_id_user_invited == other.steam_id_user_invited &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientMMSInviteToLobby {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUDSInviteToGame {
    // message fields
    steam_id_dest: ::std::option::Option<u64>,
    steam_id_src: ::std::option::Option<u64>,
    connect_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUDSInviteToGame {}

impl CMsgClientUDSInviteToGame {
    pub fn new() -> CMsgClientUDSInviteToGame {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUDSInviteToGame {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUDSInviteToGame> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUDSInviteToGame,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUDSInviteToGame {
                    steam_id_dest: ::std::option::Option::None,
                    steam_id_src: ::std::option::Option::None,
                    connect_string: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id_dest = 1;

    pub fn clear_steam_id_dest(&mut self) {
        self.steam_id_dest = ::std::option::Option::None;
    }

    pub fn has_steam_id_dest(&self) -> bool {
        self.steam_id_dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_dest(&mut self, v: u64) {
        self.steam_id_dest = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_dest<'a>(&self) -> u64 {
        self.steam_id_dest.unwrap_or(0)
    }

    // optional fixed64 steam_id_src = 2;

    pub fn clear_steam_id_src(&mut self) {
        self.steam_id_src = ::std::option::Option::None;
    }

    pub fn has_steam_id_src(&self) -> bool {
        self.steam_id_src.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_src(&mut self, v: u64) {
        self.steam_id_src = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_src<'a>(&self) -> u64 {
        self.steam_id_src.unwrap_or(0)
    }

    // optional string connect_string = 3;

    pub fn clear_connect_string(&mut self) {
        self.connect_string.clear();
    }

    pub fn has_connect_string(&self) -> bool {
        self.connect_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_string(&mut self, v: ::std::string::String) {
        self.connect_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect_string<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.connect_string.is_none() {
            self.connect_string.set_default();
        };
        self.connect_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect_string(&mut self) -> ::std::string::String {
        self.connect_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_connect_string<'a>(&'a self) -> &'a str {
        match self.connect_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientUDSInviteToGame {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_dest = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_src = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.connect_string));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id_dest.is_some() {
            my_size += 9;
        };
        if self.steam_id_src.is_some() {
            my_size += 9;
        };
        for value in self.connect_string.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_dest {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.steam_id_src {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.connect_string.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUDSInviteToGame>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUDSInviteToGame {
    fn new() -> CMsgClientUDSInviteToGame {
        CMsgClientUDSInviteToGame::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUDSInviteToGame>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_dest",
                    CMsgClientUDSInviteToGame::has_steam_id_dest,
                    CMsgClientUDSInviteToGame::get_steam_id_dest,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_src",
                    CMsgClientUDSInviteToGame::has_steam_id_src,
                    CMsgClientUDSInviteToGame::get_steam_id_src,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "connect_string",
                    CMsgClientUDSInviteToGame::has_connect_string,
                    CMsgClientUDSInviteToGame::get_connect_string,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUDSInviteToGame>(
                    "CMsgClientUDSInviteToGame",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUDSInviteToGame {
    fn clear(&mut self) {
        self.clear_steam_id_dest();
        self.clear_steam_id_src();
        self.clear_connect_string();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUDSInviteToGame {
    fn eq(&self, other: &CMsgClientUDSInviteToGame) -> bool {
        self.steam_id_dest == other.steam_id_dest &&
        self.steam_id_src == other.steam_id_src &&
        self.connect_string == other.connect_string &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUDSInviteToGame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientChatInvite {
    // message fields
    steam_id_invited: ::std::option::Option<u64>,
    steam_id_chat: ::std::option::Option<u64>,
    steam_id_patron: ::std::option::Option<u64>,
    chatroom_type: ::std::option::Option<i32>,
    steam_id_friend_chat: ::std::option::Option<u64>,
    chat_name: ::protobuf::SingularField<::std::string::String>,
    game_id: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientChatInvite {}

impl CMsgClientChatInvite {
    pub fn new() -> CMsgClientChatInvite {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientChatInvite {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientChatInvite> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientChatInvite,
        };
        unsafe {
            instance.get(|| {
                CMsgClientChatInvite {
                    steam_id_invited: ::std::option::Option::None,
                    steam_id_chat: ::std::option::Option::None,
                    steam_id_patron: ::std::option::Option::None,
                    chatroom_type: ::std::option::Option::None,
                    steam_id_friend_chat: ::std::option::Option::None,
                    chat_name: ::protobuf::SingularField::none(),
                    game_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id_invited = 1;

    pub fn clear_steam_id_invited(&mut self) {
        self.steam_id_invited = ::std::option::Option::None;
    }

    pub fn has_steam_id_invited(&self) -> bool {
        self.steam_id_invited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_invited(&mut self, v: u64) {
        self.steam_id_invited = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_invited<'a>(&self) -> u64 {
        self.steam_id_invited.unwrap_or(0)
    }

    // optional fixed64 steam_id_chat = 2;

    pub fn clear_steam_id_chat(&mut self) {
        self.steam_id_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_chat(&self) -> bool {
        self.steam_id_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_chat(&mut self, v: u64) {
        self.steam_id_chat = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_chat<'a>(&self) -> u64 {
        self.steam_id_chat.unwrap_or(0)
    }

    // optional fixed64 steam_id_patron = 3;

    pub fn clear_steam_id_patron(&mut self) {
        self.steam_id_patron = ::std::option::Option::None;
    }

    pub fn has_steam_id_patron(&self) -> bool {
        self.steam_id_patron.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_patron(&mut self, v: u64) {
        self.steam_id_patron = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_patron<'a>(&self) -> u64 {
        self.steam_id_patron.unwrap_or(0)
    }

    // optional int32 chatroom_type = 4;

    pub fn clear_chatroom_type(&mut self) {
        self.chatroom_type = ::std::option::Option::None;
    }

    pub fn has_chatroom_type(&self) -> bool {
        self.chatroom_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatroom_type(&mut self, v: i32) {
        self.chatroom_type = ::std::option::Option::Some(v);
    }

    pub fn get_chatroom_type<'a>(&self) -> i32 {
        self.chatroom_type.unwrap_or(0)
    }

    // optional fixed64 steam_id_friend_chat = 5;

    pub fn clear_steam_id_friend_chat(&mut self) {
        self.steam_id_friend_chat = ::std::option::Option::None;
    }

    pub fn has_steam_id_friend_chat(&self) -> bool {
        self.steam_id_friend_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_friend_chat(&mut self, v: u64) {
        self.steam_id_friend_chat = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_friend_chat<'a>(&self) -> u64 {
        self.steam_id_friend_chat.unwrap_or(0)
    }

    // optional string chat_name = 6;

    pub fn clear_chat_name(&mut self) {
        self.chat_name.clear();
    }

    pub fn has_chat_name(&self) -> bool {
        self.chat_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_name(&mut self, v: ::std::string::String) {
        self.chat_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chat_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.chat_name.is_none() {
            self.chat_name.set_default();
        };
        self.chat_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_chat_name(&mut self) -> ::std::string::String {
        self.chat_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_chat_name<'a>(&'a self) -> &'a str {
        match self.chat_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 game_id = 7;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientChatInvite {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_invited = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_chat = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_patron = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.chatroom_type = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_friend_chat = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.chat_name));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id_invited.is_some() {
            my_size += 9;
        };
        if self.steam_id_chat.is_some() {
            my_size += 9;
        };
        if self.steam_id_patron.is_some() {
            my_size += 9;
        };
        for value in self.chatroom_type.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_friend_chat.is_some() {
            my_size += 9;
        };
        for value in self.chat_name.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.game_id.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id_invited {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.steam_id_chat {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.steam_id_patron {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.chatroom_type {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.steam_id_friend_chat {
            try!(os.write_fixed64(5, v));
        };
        if let Some(v) = self.chat_name.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientChatInvite>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientChatInvite {
    fn new() -> CMsgClientChatInvite {
        CMsgClientChatInvite::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientChatInvite>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_invited",
                    CMsgClientChatInvite::has_steam_id_invited,
                    CMsgClientChatInvite::get_steam_id_invited,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_chat",
                    CMsgClientChatInvite::has_steam_id_chat,
                    CMsgClientChatInvite::get_steam_id_chat,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_patron",
                    CMsgClientChatInvite::has_steam_id_patron,
                    CMsgClientChatInvite::get_steam_id_patron,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "chatroom_type",
                    CMsgClientChatInvite::has_chatroom_type,
                    CMsgClientChatInvite::get_chatroom_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_friend_chat",
                    CMsgClientChatInvite::has_steam_id_friend_chat,
                    CMsgClientChatInvite::get_steam_id_friend_chat,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "chat_name",
                    CMsgClientChatInvite::has_chat_name,
                    CMsgClientChatInvite::get_chat_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientChatInvite::has_game_id,
                    CMsgClientChatInvite::get_game_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientChatInvite>(
                    "CMsgClientChatInvite",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientChatInvite {
    fn clear(&mut self) {
        self.clear_steam_id_invited();
        self.clear_steam_id_chat();
        self.clear_steam_id_patron();
        self.clear_chatroom_type();
        self.clear_steam_id_friend_chat();
        self.clear_chat_name();
        self.clear_game_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientChatInvite {
    fn eq(&self, other: &CMsgClientChatInvite) -> bool {
        self.steam_id_invited == other.steam_id_invited &&
        self.steam_id_chat == other.steam_id_chat &&
        self.steam_id_patron == other.steam_id_patron &&
        self.chatroom_type == other.chatroom_type &&
        self.steam_id_friend_chat == other.steam_id_friend_chat &&
        self.chat_name == other.chat_name &&
        self.game_id == other.game_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientChatInvite {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientConnectionStats {
    // message fields
    stats_logon: ::protobuf::SingularPtrField<CMsgClientConnectionStats_Stats_Logon>,
    stats_vconn: ::protobuf::SingularPtrField<CMsgClientConnectionStats_Stats_VConn>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientConnectionStats {}

impl CMsgClientConnectionStats {
    pub fn new() -> CMsgClientConnectionStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientConnectionStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientConnectionStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientConnectionStats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientConnectionStats {
                    stats_logon: ::protobuf::SingularPtrField::none(),
                    stats_vconn: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional .CMsgClientConnectionStats.Stats_Logon stats_logon = 1;

    pub fn clear_stats_logon(&mut self) {
        self.stats_logon.clear();
    }

    pub fn has_stats_logon(&self) -> bool {
        self.stats_logon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_logon(&mut self, v: CMsgClientConnectionStats_Stats_Logon) {
        self.stats_logon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_logon<'a>(&'a mut self) -> &'a mut CMsgClientConnectionStats_Stats_Logon {
        if self.stats_logon.is_none() {
            self.stats_logon.set_default();
        };
        self.stats_logon.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_logon(&mut self) -> CMsgClientConnectionStats_Stats_Logon {
        self.stats_logon.take().unwrap_or_else(|| CMsgClientConnectionStats_Stats_Logon::new())
    }

    pub fn get_stats_logon<'a>(&'a self) -> &'a CMsgClientConnectionStats_Stats_Logon {
        self.stats_logon.as_ref().unwrap_or_else(|| CMsgClientConnectionStats_Stats_Logon::default_instance())
    }

    // optional .CMsgClientConnectionStats.Stats_VConn stats_vconn = 2;

    pub fn clear_stats_vconn(&mut self) {
        self.stats_vconn.clear();
    }

    pub fn has_stats_vconn(&self) -> bool {
        self.stats_vconn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_vconn(&mut self, v: CMsgClientConnectionStats_Stats_VConn) {
        self.stats_vconn = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_vconn<'a>(&'a mut self) -> &'a mut CMsgClientConnectionStats_Stats_VConn {
        if self.stats_vconn.is_none() {
            self.stats_vconn.set_default();
        };
        self.stats_vconn.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_vconn(&mut self) -> CMsgClientConnectionStats_Stats_VConn {
        self.stats_vconn.take().unwrap_or_else(|| CMsgClientConnectionStats_Stats_VConn::new())
    }

    pub fn get_stats_vconn<'a>(&'a self) -> &'a CMsgClientConnectionStats_Stats_VConn {
        self.stats_vconn.as_ref().unwrap_or_else(|| CMsgClientConnectionStats_Stats_VConn::default_instance())
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_logon));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_vconn));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stats_logon.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.stats_vconn.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stats_logon.as_ref() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.stats_vconn.as_ref() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientConnectionStats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientConnectionStats {
    fn new() -> CMsgClientConnectionStats {
        CMsgClientConnectionStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientConnectionStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stats_logon",
                    CMsgClientConnectionStats::has_stats_logon,
                    CMsgClientConnectionStats::get_stats_logon,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stats_vconn",
                    CMsgClientConnectionStats::has_stats_vconn,
                    CMsgClientConnectionStats::get_stats_vconn,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientConnectionStats>(
                    "CMsgClientConnectionStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats {
    fn clear(&mut self) {
        self.clear_stats_logon();
        self.clear_stats_vconn();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientConnectionStats {
    fn eq(&self, other: &CMsgClientConnectionStats) -> bool {
        self.stats_logon == other.stats_logon &&
        self.stats_vconn == other.stats_vconn &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientConnectionStats_Stats_Logon {
    // message fields
    connect_attempts: ::std::option::Option<i32>,
    connect_successes: ::std::option::Option<i32>,
    connect_failures: ::std::option::Option<i32>,
    connections_dropped: ::std::option::Option<i32>,
    seconds_running: ::std::option::Option<u32>,
    msec_tologonthistime: ::std::option::Option<u32>,
    count_bad_cms: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientConnectionStats_Stats_Logon {}

impl CMsgClientConnectionStats_Stats_Logon {
    pub fn new() -> CMsgClientConnectionStats_Stats_Logon {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientConnectionStats_Stats_Logon {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientConnectionStats_Stats_Logon> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientConnectionStats_Stats_Logon,
        };
        unsafe {
            instance.get(|| {
                CMsgClientConnectionStats_Stats_Logon {
                    connect_attempts: ::std::option::Option::None,
                    connect_successes: ::std::option::Option::None,
                    connect_failures: ::std::option::Option::None,
                    connections_dropped: ::std::option::Option::None,
                    seconds_running: ::std::option::Option::None,
                    msec_tologonthistime: ::std::option::Option::None,
                    count_bad_cms: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 connect_attempts = 1;

    pub fn clear_connect_attempts(&mut self) {
        self.connect_attempts = ::std::option::Option::None;
    }

    pub fn has_connect_attempts(&self) -> bool {
        self.connect_attempts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_attempts(&mut self, v: i32) {
        self.connect_attempts = ::std::option::Option::Some(v);
    }

    pub fn get_connect_attempts<'a>(&self) -> i32 {
        self.connect_attempts.unwrap_or(0)
    }

    // optional int32 connect_successes = 2;

    pub fn clear_connect_successes(&mut self) {
        self.connect_successes = ::std::option::Option::None;
    }

    pub fn has_connect_successes(&self) -> bool {
        self.connect_successes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_successes(&mut self, v: i32) {
        self.connect_successes = ::std::option::Option::Some(v);
    }

    pub fn get_connect_successes<'a>(&self) -> i32 {
        self.connect_successes.unwrap_or(0)
    }

    // optional int32 connect_failures = 3;

    pub fn clear_connect_failures(&mut self) {
        self.connect_failures = ::std::option::Option::None;
    }

    pub fn has_connect_failures(&self) -> bool {
        self.connect_failures.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_failures(&mut self, v: i32) {
        self.connect_failures = ::std::option::Option::Some(v);
    }

    pub fn get_connect_failures<'a>(&self) -> i32 {
        self.connect_failures.unwrap_or(0)
    }

    // optional int32 connections_dropped = 4;

    pub fn clear_connections_dropped(&mut self) {
        self.connections_dropped = ::std::option::Option::None;
    }

    pub fn has_connections_dropped(&self) -> bool {
        self.connections_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connections_dropped(&mut self, v: i32) {
        self.connections_dropped = ::std::option::Option::Some(v);
    }

    pub fn get_connections_dropped<'a>(&self) -> i32 {
        self.connections_dropped.unwrap_or(0)
    }

    // optional uint32 seconds_running = 5;

    pub fn clear_seconds_running(&mut self) {
        self.seconds_running = ::std::option::Option::None;
    }

    pub fn has_seconds_running(&self) -> bool {
        self.seconds_running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_running(&mut self, v: u32) {
        self.seconds_running = ::std::option::Option::Some(v);
    }

    pub fn get_seconds_running<'a>(&self) -> u32 {
        self.seconds_running.unwrap_or(0)
    }

    // optional uint32 msec_tologonthistime = 6;

    pub fn clear_msec_tologonthistime(&mut self) {
        self.msec_tologonthistime = ::std::option::Option::None;
    }

    pub fn has_msec_tologonthistime(&self) -> bool {
        self.msec_tologonthistime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msec_tologonthistime(&mut self, v: u32) {
        self.msec_tologonthistime = ::std::option::Option::Some(v);
    }

    pub fn get_msec_tologonthistime<'a>(&self) -> u32 {
        self.msec_tologonthistime.unwrap_or(0)
    }

    // optional uint32 count_bad_cms = 7;

    pub fn clear_count_bad_cms(&mut self) {
        self.count_bad_cms = ::std::option::Option::None;
    }

    pub fn has_count_bad_cms(&self) -> bool {
        self.count_bad_cms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count_bad_cms(&mut self, v: u32) {
        self.count_bad_cms = ::std::option::Option::Some(v);
    }

    pub fn get_count_bad_cms<'a>(&self) -> u32 {
        self.count_bad_cms.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats_Stats_Logon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.connect_attempts = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.connect_successes = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.connect_failures = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.connections_dropped = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.seconds_running = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.msec_tologonthistime = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.count_bad_cms = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.connect_attempts.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.connect_successes.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.connect_failures.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.connections_dropped.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.seconds_running.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.msec_tologonthistime.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.count_bad_cms.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connect_attempts {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.connect_successes {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.connect_failures {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.connections_dropped {
            try!(os.write_int32(4, v));
        };
        if let Some(v) = self.seconds_running {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.msec_tologonthistime {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.count_bad_cms {
            try!(os.write_uint32(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientConnectionStats_Stats_Logon>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientConnectionStats_Stats_Logon {
    fn new() -> CMsgClientConnectionStats_Stats_Logon {
        CMsgClientConnectionStats_Stats_Logon::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientConnectionStats_Stats_Logon>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "connect_attempts",
                    CMsgClientConnectionStats_Stats_Logon::has_connect_attempts,
                    CMsgClientConnectionStats_Stats_Logon::get_connect_attempts,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "connect_successes",
                    CMsgClientConnectionStats_Stats_Logon::has_connect_successes,
                    CMsgClientConnectionStats_Stats_Logon::get_connect_successes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "connect_failures",
                    CMsgClientConnectionStats_Stats_Logon::has_connect_failures,
                    CMsgClientConnectionStats_Stats_Logon::get_connect_failures,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "connections_dropped",
                    CMsgClientConnectionStats_Stats_Logon::has_connections_dropped,
                    CMsgClientConnectionStats_Stats_Logon::get_connections_dropped,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "seconds_running",
                    CMsgClientConnectionStats_Stats_Logon::has_seconds_running,
                    CMsgClientConnectionStats_Stats_Logon::get_seconds_running,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "msec_tologonthistime",
                    CMsgClientConnectionStats_Stats_Logon::has_msec_tologonthistime,
                    CMsgClientConnectionStats_Stats_Logon::get_msec_tologonthistime,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "count_bad_cms",
                    CMsgClientConnectionStats_Stats_Logon::has_count_bad_cms,
                    CMsgClientConnectionStats_Stats_Logon::get_count_bad_cms,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientConnectionStats_Stats_Logon>(
                    "CMsgClientConnectionStats_Stats_Logon",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats_Stats_Logon {
    fn clear(&mut self) {
        self.clear_connect_attempts();
        self.clear_connect_successes();
        self.clear_connect_failures();
        self.clear_connections_dropped();
        self.clear_seconds_running();
        self.clear_msec_tologonthistime();
        self.clear_count_bad_cms();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientConnectionStats_Stats_Logon {
    fn eq(&self, other: &CMsgClientConnectionStats_Stats_Logon) -> bool {
        self.connect_attempts == other.connect_attempts &&
        self.connect_successes == other.connect_successes &&
        self.connect_failures == other.connect_failures &&
        self.connections_dropped == other.connections_dropped &&
        self.seconds_running == other.seconds_running &&
        self.msec_tologonthistime == other.msec_tologonthistime &&
        self.count_bad_cms == other.count_bad_cms &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats_Stats_Logon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientConnectionStats_Stats_UDP {
    // message fields
    pkts_sent: ::std::option::Option<u64>,
    bytes_sent: ::std::option::Option<u64>,
    pkts_recv: ::std::option::Option<u64>,
    pkts_processed: ::std::option::Option<u64>,
    bytes_recv: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientConnectionStats_Stats_UDP {}

impl CMsgClientConnectionStats_Stats_UDP {
    pub fn new() -> CMsgClientConnectionStats_Stats_UDP {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientConnectionStats_Stats_UDP {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientConnectionStats_Stats_UDP> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientConnectionStats_Stats_UDP,
        };
        unsafe {
            instance.get(|| {
                CMsgClientConnectionStats_Stats_UDP {
                    pkts_sent: ::std::option::Option::None,
                    bytes_sent: ::std::option::Option::None,
                    pkts_recv: ::std::option::Option::None,
                    pkts_processed: ::std::option::Option::None,
                    bytes_recv: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint64 pkts_sent = 1;

    pub fn clear_pkts_sent(&mut self) {
        self.pkts_sent = ::std::option::Option::None;
    }

    pub fn has_pkts_sent(&self) -> bool {
        self.pkts_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_sent(&mut self, v: u64) {
        self.pkts_sent = ::std::option::Option::Some(v);
    }

    pub fn get_pkts_sent<'a>(&self) -> u64 {
        self.pkts_sent.unwrap_or(0)
    }

    // optional uint64 bytes_sent = 2;

    pub fn clear_bytes_sent(&mut self) {
        self.bytes_sent = ::std::option::Option::None;
    }

    pub fn has_bytes_sent(&self) -> bool {
        self.bytes_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_sent(&mut self, v: u64) {
        self.bytes_sent = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_sent<'a>(&self) -> u64 {
        self.bytes_sent.unwrap_or(0)
    }

    // optional uint64 pkts_recv = 3;

    pub fn clear_pkts_recv(&mut self) {
        self.pkts_recv = ::std::option::Option::None;
    }

    pub fn has_pkts_recv(&self) -> bool {
        self.pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_recv(&mut self, v: u64) {
        self.pkts_recv = ::std::option::Option::Some(v);
    }

    pub fn get_pkts_recv<'a>(&self) -> u64 {
        self.pkts_recv.unwrap_or(0)
    }

    // optional uint64 pkts_processed = 4;

    pub fn clear_pkts_processed(&mut self) {
        self.pkts_processed = ::std::option::Option::None;
    }

    pub fn has_pkts_processed(&self) -> bool {
        self.pkts_processed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_processed(&mut self, v: u64) {
        self.pkts_processed = ::std::option::Option::Some(v);
    }

    pub fn get_pkts_processed<'a>(&self) -> u64 {
        self.pkts_processed.unwrap_or(0)
    }

    // optional uint64 bytes_recv = 5;

    pub fn clear_bytes_recv(&mut self) {
        self.bytes_recv = ::std::option::Option::None;
    }

    pub fn has_bytes_recv(&self) -> bool {
        self.bytes_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_recv(&mut self, v: u64) {
        self.bytes_recv = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_recv<'a>(&self) -> u64 {
        self.bytes_recv.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats_Stats_UDP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.pkts_sent = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes_sent = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.pkts_recv = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.pkts_processed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes_recv = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.pkts_sent.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_sent.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pkts_recv.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pkts_processed.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_recv.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.pkts_sent {
            try!(os.write_uint64(1, v));
        };
        if let Some(v) = self.bytes_sent {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.pkts_recv {
            try!(os.write_uint64(3, v));
        };
        if let Some(v) = self.pkts_processed {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.bytes_recv {
            try!(os.write_uint64(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientConnectionStats_Stats_UDP>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientConnectionStats_Stats_UDP {
    fn new() -> CMsgClientConnectionStats_Stats_UDP {
        CMsgClientConnectionStats_Stats_UDP::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientConnectionStats_Stats_UDP>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "pkts_sent",
                    CMsgClientConnectionStats_Stats_UDP::has_pkts_sent,
                    CMsgClientConnectionStats_Stats_UDP::get_pkts_sent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes_sent",
                    CMsgClientConnectionStats_Stats_UDP::has_bytes_sent,
                    CMsgClientConnectionStats_Stats_UDP::get_bytes_sent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "pkts_recv",
                    CMsgClientConnectionStats_Stats_UDP::has_pkts_recv,
                    CMsgClientConnectionStats_Stats_UDP::get_pkts_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "pkts_processed",
                    CMsgClientConnectionStats_Stats_UDP::has_pkts_processed,
                    CMsgClientConnectionStats_Stats_UDP::get_pkts_processed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes_recv",
                    CMsgClientConnectionStats_Stats_UDP::has_bytes_recv,
                    CMsgClientConnectionStats_Stats_UDP::get_bytes_recv,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientConnectionStats_Stats_UDP>(
                    "CMsgClientConnectionStats_Stats_UDP",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats_Stats_UDP {
    fn clear(&mut self) {
        self.clear_pkts_sent();
        self.clear_bytes_sent();
        self.clear_pkts_recv();
        self.clear_pkts_processed();
        self.clear_bytes_recv();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientConnectionStats_Stats_UDP {
    fn eq(&self, other: &CMsgClientConnectionStats_Stats_UDP) -> bool {
        self.pkts_sent == other.pkts_sent &&
        self.bytes_sent == other.bytes_sent &&
        self.pkts_recv == other.pkts_recv &&
        self.pkts_processed == other.pkts_processed &&
        self.bytes_recv == other.bytes_recv &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats_Stats_UDP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientConnectionStats_Stats_VConn {
    // message fields
    connections_udp: ::std::option::Option<u32>,
    connections_tcp: ::std::option::Option<u32>,
    stats_udp: ::protobuf::SingularPtrField<CMsgClientConnectionStats_Stats_UDP>,
    pkts_abandoned: ::std::option::Option<u64>,
    conn_req_received: ::std::option::Option<u64>,
    pkts_resent: ::std::option::Option<u64>,
    msgs_sent: ::std::option::Option<u64>,
    msgs_sent_failed: ::std::option::Option<u64>,
    msgs_recv: ::std::option::Option<u64>,
    datagrams_sent: ::std::option::Option<u64>,
    datagrams_recv: ::std::option::Option<u64>,
    bad_pkts_recv: ::std::option::Option<u64>,
    unknown_conn_pkts_recv: ::std::option::Option<u64>,
    missed_pkts_recv: ::std::option::Option<u64>,
    dup_pkts_recv: ::std::option::Option<u64>,
    failed_connect_challenges: ::std::option::Option<u64>,
    micro_sec_avg_latency: ::std::option::Option<u32>,
    micro_sec_min_latency: ::std::option::Option<u32>,
    micro_sec_max_latency: ::std::option::Option<u32>,
    mem_pool_msg_in_use: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientConnectionStats_Stats_VConn {}

impl CMsgClientConnectionStats_Stats_VConn {
    pub fn new() -> CMsgClientConnectionStats_Stats_VConn {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientConnectionStats_Stats_VConn {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientConnectionStats_Stats_VConn> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientConnectionStats_Stats_VConn,
        };
        unsafe {
            instance.get(|| {
                CMsgClientConnectionStats_Stats_VConn {
                    connections_udp: ::std::option::Option::None,
                    connections_tcp: ::std::option::Option::None,
                    stats_udp: ::protobuf::SingularPtrField::none(),
                    pkts_abandoned: ::std::option::Option::None,
                    conn_req_received: ::std::option::Option::None,
                    pkts_resent: ::std::option::Option::None,
                    msgs_sent: ::std::option::Option::None,
                    msgs_sent_failed: ::std::option::Option::None,
                    msgs_recv: ::std::option::Option::None,
                    datagrams_sent: ::std::option::Option::None,
                    datagrams_recv: ::std::option::Option::None,
                    bad_pkts_recv: ::std::option::Option::None,
                    unknown_conn_pkts_recv: ::std::option::Option::None,
                    missed_pkts_recv: ::std::option::Option::None,
                    dup_pkts_recv: ::std::option::Option::None,
                    failed_connect_challenges: ::std::option::Option::None,
                    micro_sec_avg_latency: ::std::option::Option::None,
                    micro_sec_min_latency: ::std::option::Option::None,
                    micro_sec_max_latency: ::std::option::Option::None,
                    mem_pool_msg_in_use: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 connections_udp = 1;

    pub fn clear_connections_udp(&mut self) {
        self.connections_udp = ::std::option::Option::None;
    }

    pub fn has_connections_udp(&self) -> bool {
        self.connections_udp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connections_udp(&mut self, v: u32) {
        self.connections_udp = ::std::option::Option::Some(v);
    }

    pub fn get_connections_udp<'a>(&self) -> u32 {
        self.connections_udp.unwrap_or(0)
    }

    // optional uint32 connections_tcp = 2;

    pub fn clear_connections_tcp(&mut self) {
        self.connections_tcp = ::std::option::Option::None;
    }

    pub fn has_connections_tcp(&self) -> bool {
        self.connections_tcp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connections_tcp(&mut self, v: u32) {
        self.connections_tcp = ::std::option::Option::Some(v);
    }

    pub fn get_connections_tcp<'a>(&self) -> u32 {
        self.connections_tcp.unwrap_or(0)
    }

    // optional .CMsgClientConnectionStats.Stats_UDP stats_udp = 3;

    pub fn clear_stats_udp(&mut self) {
        self.stats_udp.clear();
    }

    pub fn has_stats_udp(&self) -> bool {
        self.stats_udp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_udp(&mut self, v: CMsgClientConnectionStats_Stats_UDP) {
        self.stats_udp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_udp<'a>(&'a mut self) -> &'a mut CMsgClientConnectionStats_Stats_UDP {
        if self.stats_udp.is_none() {
            self.stats_udp.set_default();
        };
        self.stats_udp.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_udp(&mut self) -> CMsgClientConnectionStats_Stats_UDP {
        self.stats_udp.take().unwrap_or_else(|| CMsgClientConnectionStats_Stats_UDP::new())
    }

    pub fn get_stats_udp<'a>(&'a self) -> &'a CMsgClientConnectionStats_Stats_UDP {
        self.stats_udp.as_ref().unwrap_or_else(|| CMsgClientConnectionStats_Stats_UDP::default_instance())
    }

    // optional uint64 pkts_abandoned = 4;

    pub fn clear_pkts_abandoned(&mut self) {
        self.pkts_abandoned = ::std::option::Option::None;
    }

    pub fn has_pkts_abandoned(&self) -> bool {
        self.pkts_abandoned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_abandoned(&mut self, v: u64) {
        self.pkts_abandoned = ::std::option::Option::Some(v);
    }

    pub fn get_pkts_abandoned<'a>(&self) -> u64 {
        self.pkts_abandoned.unwrap_or(0)
    }

    // optional uint64 conn_req_received = 5;

    pub fn clear_conn_req_received(&mut self) {
        self.conn_req_received = ::std::option::Option::None;
    }

    pub fn has_conn_req_received(&self) -> bool {
        self.conn_req_received.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conn_req_received(&mut self, v: u64) {
        self.conn_req_received = ::std::option::Option::Some(v);
    }

    pub fn get_conn_req_received<'a>(&self) -> u64 {
        self.conn_req_received.unwrap_or(0)
    }

    // optional uint64 pkts_resent = 6;

    pub fn clear_pkts_resent(&mut self) {
        self.pkts_resent = ::std::option::Option::None;
    }

    pub fn has_pkts_resent(&self) -> bool {
        self.pkts_resent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pkts_resent(&mut self, v: u64) {
        self.pkts_resent = ::std::option::Option::Some(v);
    }

    pub fn get_pkts_resent<'a>(&self) -> u64 {
        self.pkts_resent.unwrap_or(0)
    }

    // optional uint64 msgs_sent = 7;

    pub fn clear_msgs_sent(&mut self) {
        self.msgs_sent = ::std::option::Option::None;
    }

    pub fn has_msgs_sent(&self) -> bool {
        self.msgs_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgs_sent(&mut self, v: u64) {
        self.msgs_sent = ::std::option::Option::Some(v);
    }

    pub fn get_msgs_sent<'a>(&self) -> u64 {
        self.msgs_sent.unwrap_or(0)
    }

    // optional uint64 msgs_sent_failed = 8;

    pub fn clear_msgs_sent_failed(&mut self) {
        self.msgs_sent_failed = ::std::option::Option::None;
    }

    pub fn has_msgs_sent_failed(&self) -> bool {
        self.msgs_sent_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgs_sent_failed(&mut self, v: u64) {
        self.msgs_sent_failed = ::std::option::Option::Some(v);
    }

    pub fn get_msgs_sent_failed<'a>(&self) -> u64 {
        self.msgs_sent_failed.unwrap_or(0)
    }

    // optional uint64 msgs_recv = 9;

    pub fn clear_msgs_recv(&mut self) {
        self.msgs_recv = ::std::option::Option::None;
    }

    pub fn has_msgs_recv(&self) -> bool {
        self.msgs_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgs_recv(&mut self, v: u64) {
        self.msgs_recv = ::std::option::Option::Some(v);
    }

    pub fn get_msgs_recv<'a>(&self) -> u64 {
        self.msgs_recv.unwrap_or(0)
    }

    // optional uint64 datagrams_sent = 10;

    pub fn clear_datagrams_sent(&mut self) {
        self.datagrams_sent = ::std::option::Option::None;
    }

    pub fn has_datagrams_sent(&self) -> bool {
        self.datagrams_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datagrams_sent(&mut self, v: u64) {
        self.datagrams_sent = ::std::option::Option::Some(v);
    }

    pub fn get_datagrams_sent<'a>(&self) -> u64 {
        self.datagrams_sent.unwrap_or(0)
    }

    // optional uint64 datagrams_recv = 11;

    pub fn clear_datagrams_recv(&mut self) {
        self.datagrams_recv = ::std::option::Option::None;
    }

    pub fn has_datagrams_recv(&self) -> bool {
        self.datagrams_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datagrams_recv(&mut self, v: u64) {
        self.datagrams_recv = ::std::option::Option::Some(v);
    }

    pub fn get_datagrams_recv<'a>(&self) -> u64 {
        self.datagrams_recv.unwrap_or(0)
    }

    // optional uint64 bad_pkts_recv = 12;

    pub fn clear_bad_pkts_recv(&mut self) {
        self.bad_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_bad_pkts_recv(&self) -> bool {
        self.bad_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bad_pkts_recv(&mut self, v: u64) {
        self.bad_pkts_recv = ::std::option::Option::Some(v);
    }

    pub fn get_bad_pkts_recv<'a>(&self) -> u64 {
        self.bad_pkts_recv.unwrap_or(0)
    }

    // optional uint64 unknown_conn_pkts_recv = 13;

    pub fn clear_unknown_conn_pkts_recv(&mut self) {
        self.unknown_conn_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_unknown_conn_pkts_recv(&self) -> bool {
        self.unknown_conn_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown_conn_pkts_recv(&mut self, v: u64) {
        self.unknown_conn_pkts_recv = ::std::option::Option::Some(v);
    }

    pub fn get_unknown_conn_pkts_recv<'a>(&self) -> u64 {
        self.unknown_conn_pkts_recv.unwrap_or(0)
    }

    // optional uint64 missed_pkts_recv = 14;

    pub fn clear_missed_pkts_recv(&mut self) {
        self.missed_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_missed_pkts_recv(&self) -> bool {
        self.missed_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missed_pkts_recv(&mut self, v: u64) {
        self.missed_pkts_recv = ::std::option::Option::Some(v);
    }

    pub fn get_missed_pkts_recv<'a>(&self) -> u64 {
        self.missed_pkts_recv.unwrap_or(0)
    }

    // optional uint64 dup_pkts_recv = 15;

    pub fn clear_dup_pkts_recv(&mut self) {
        self.dup_pkts_recv = ::std::option::Option::None;
    }

    pub fn has_dup_pkts_recv(&self) -> bool {
        self.dup_pkts_recv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dup_pkts_recv(&mut self, v: u64) {
        self.dup_pkts_recv = ::std::option::Option::Some(v);
    }

    pub fn get_dup_pkts_recv<'a>(&self) -> u64 {
        self.dup_pkts_recv.unwrap_or(0)
    }

    // optional uint64 failed_connect_challenges = 16;

    pub fn clear_failed_connect_challenges(&mut self) {
        self.failed_connect_challenges = ::std::option::Option::None;
    }

    pub fn has_failed_connect_challenges(&self) -> bool {
        self.failed_connect_challenges.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_connect_challenges(&mut self, v: u64) {
        self.failed_connect_challenges = ::std::option::Option::Some(v);
    }

    pub fn get_failed_connect_challenges<'a>(&self) -> u64 {
        self.failed_connect_challenges.unwrap_or(0)
    }

    // optional uint32 micro_sec_avg_latency = 17;

    pub fn clear_micro_sec_avg_latency(&mut self) {
        self.micro_sec_avg_latency = ::std::option::Option::None;
    }

    pub fn has_micro_sec_avg_latency(&self) -> bool {
        self.micro_sec_avg_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_micro_sec_avg_latency(&mut self, v: u32) {
        self.micro_sec_avg_latency = ::std::option::Option::Some(v);
    }

    pub fn get_micro_sec_avg_latency<'a>(&self) -> u32 {
        self.micro_sec_avg_latency.unwrap_or(0)
    }

    // optional uint32 micro_sec_min_latency = 18;

    pub fn clear_micro_sec_min_latency(&mut self) {
        self.micro_sec_min_latency = ::std::option::Option::None;
    }

    pub fn has_micro_sec_min_latency(&self) -> bool {
        self.micro_sec_min_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_micro_sec_min_latency(&mut self, v: u32) {
        self.micro_sec_min_latency = ::std::option::Option::Some(v);
    }

    pub fn get_micro_sec_min_latency<'a>(&self) -> u32 {
        self.micro_sec_min_latency.unwrap_or(0)
    }

    // optional uint32 micro_sec_max_latency = 19;

    pub fn clear_micro_sec_max_latency(&mut self) {
        self.micro_sec_max_latency = ::std::option::Option::None;
    }

    pub fn has_micro_sec_max_latency(&self) -> bool {
        self.micro_sec_max_latency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_micro_sec_max_latency(&mut self, v: u32) {
        self.micro_sec_max_latency = ::std::option::Option::Some(v);
    }

    pub fn get_micro_sec_max_latency<'a>(&self) -> u32 {
        self.micro_sec_max_latency.unwrap_or(0)
    }

    // optional uint32 mem_pool_msg_in_use = 20;

    pub fn clear_mem_pool_msg_in_use(&mut self) {
        self.mem_pool_msg_in_use = ::std::option::Option::None;
    }

    pub fn has_mem_pool_msg_in_use(&self) -> bool {
        self.mem_pool_msg_in_use.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mem_pool_msg_in_use(&mut self, v: u32) {
        self.mem_pool_msg_in_use = ::std::option::Option::Some(v);
    }

    pub fn get_mem_pool_msg_in_use<'a>(&self) -> u32 {
        self.mem_pool_msg_in_use.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientConnectionStats_Stats_VConn {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.connections_udp = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.connections_tcp = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_udp));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.pkts_abandoned = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.conn_req_received = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.pkts_resent = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.msgs_sent = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.msgs_sent_failed = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.msgs_recv = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.datagrams_sent = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.datagrams_recv = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bad_pkts_recv = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.unknown_conn_pkts_recv = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.missed_pkts_recv = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.dup_pkts_recv = ::std::option::Option::Some(tmp);
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.failed_connect_challenges = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.micro_sec_avg_latency = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.micro_sec_min_latency = ::std::option::Option::Some(tmp);
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.micro_sec_max_latency = ::std::option::Option::Some(tmp);
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.mem_pool_msg_in_use = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.connections_udp.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.connections_tcp.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stats_udp.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.pkts_abandoned.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.conn_req_received.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.pkts_resent.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.msgs_sent.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.msgs_sent_failed.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.msgs_recv.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.datagrams_sent.iter() {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.datagrams_recv.iter() {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bad_pkts_recv.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.unknown_conn_pkts_recv.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.missed_pkts_recv.iter() {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.dup_pkts_recv.iter() {
            my_size += ::protobuf::rt::value_size(15, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.failed_connect_challenges.iter() {
            my_size += ::protobuf::rt::value_size(16, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.micro_sec_avg_latency.iter() {
            my_size += ::protobuf::rt::value_size(17, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.micro_sec_min_latency.iter() {
            my_size += ::protobuf::rt::value_size(18, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.micro_sec_max_latency.iter() {
            my_size += ::protobuf::rt::value_size(19, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.mem_pool_msg_in_use.iter() {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.connections_udp {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.connections_tcp {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.stats_udp.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.pkts_abandoned {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.conn_req_received {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.pkts_resent {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.msgs_sent {
            try!(os.write_uint64(7, v));
        };
        if let Some(v) = self.msgs_sent_failed {
            try!(os.write_uint64(8, v));
        };
        if let Some(v) = self.msgs_recv {
            try!(os.write_uint64(9, v));
        };
        if let Some(v) = self.datagrams_sent {
            try!(os.write_uint64(10, v));
        };
        if let Some(v) = self.datagrams_recv {
            try!(os.write_uint64(11, v));
        };
        if let Some(v) = self.bad_pkts_recv {
            try!(os.write_uint64(12, v));
        };
        if let Some(v) = self.unknown_conn_pkts_recv {
            try!(os.write_uint64(13, v));
        };
        if let Some(v) = self.missed_pkts_recv {
            try!(os.write_uint64(14, v));
        };
        if let Some(v) = self.dup_pkts_recv {
            try!(os.write_uint64(15, v));
        };
        if let Some(v) = self.failed_connect_challenges {
            try!(os.write_uint64(16, v));
        };
        if let Some(v) = self.micro_sec_avg_latency {
            try!(os.write_uint32(17, v));
        };
        if let Some(v) = self.micro_sec_min_latency {
            try!(os.write_uint32(18, v));
        };
        if let Some(v) = self.micro_sec_max_latency {
            try!(os.write_uint32(19, v));
        };
        if let Some(v) = self.mem_pool_msg_in_use {
            try!(os.write_uint32(20, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientConnectionStats_Stats_VConn>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientConnectionStats_Stats_VConn {
    fn new() -> CMsgClientConnectionStats_Stats_VConn {
        CMsgClientConnectionStats_Stats_VConn::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientConnectionStats_Stats_VConn>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "connections_udp",
                    CMsgClientConnectionStats_Stats_VConn::has_connections_udp,
                    CMsgClientConnectionStats_Stats_VConn::get_connections_udp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "connections_tcp",
                    CMsgClientConnectionStats_Stats_VConn::has_connections_tcp,
                    CMsgClientConnectionStats_Stats_VConn::get_connections_tcp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "stats_udp",
                    CMsgClientConnectionStats_Stats_VConn::has_stats_udp,
                    CMsgClientConnectionStats_Stats_VConn::get_stats_udp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "pkts_abandoned",
                    CMsgClientConnectionStats_Stats_VConn::has_pkts_abandoned,
                    CMsgClientConnectionStats_Stats_VConn::get_pkts_abandoned,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "conn_req_received",
                    CMsgClientConnectionStats_Stats_VConn::has_conn_req_received,
                    CMsgClientConnectionStats_Stats_VConn::get_conn_req_received,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "pkts_resent",
                    CMsgClientConnectionStats_Stats_VConn::has_pkts_resent,
                    CMsgClientConnectionStats_Stats_VConn::get_pkts_resent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "msgs_sent",
                    CMsgClientConnectionStats_Stats_VConn::has_msgs_sent,
                    CMsgClientConnectionStats_Stats_VConn::get_msgs_sent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "msgs_sent_failed",
                    CMsgClientConnectionStats_Stats_VConn::has_msgs_sent_failed,
                    CMsgClientConnectionStats_Stats_VConn::get_msgs_sent_failed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "msgs_recv",
                    CMsgClientConnectionStats_Stats_VConn::has_msgs_recv,
                    CMsgClientConnectionStats_Stats_VConn::get_msgs_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "datagrams_sent",
                    CMsgClientConnectionStats_Stats_VConn::has_datagrams_sent,
                    CMsgClientConnectionStats_Stats_VConn::get_datagrams_sent,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "datagrams_recv",
                    CMsgClientConnectionStats_Stats_VConn::has_datagrams_recv,
                    CMsgClientConnectionStats_Stats_VConn::get_datagrams_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bad_pkts_recv",
                    CMsgClientConnectionStats_Stats_VConn::has_bad_pkts_recv,
                    CMsgClientConnectionStats_Stats_VConn::get_bad_pkts_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "unknown_conn_pkts_recv",
                    CMsgClientConnectionStats_Stats_VConn::has_unknown_conn_pkts_recv,
                    CMsgClientConnectionStats_Stats_VConn::get_unknown_conn_pkts_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "missed_pkts_recv",
                    CMsgClientConnectionStats_Stats_VConn::has_missed_pkts_recv,
                    CMsgClientConnectionStats_Stats_VConn::get_missed_pkts_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "dup_pkts_recv",
                    CMsgClientConnectionStats_Stats_VConn::has_dup_pkts_recv,
                    CMsgClientConnectionStats_Stats_VConn::get_dup_pkts_recv,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "failed_connect_challenges",
                    CMsgClientConnectionStats_Stats_VConn::has_failed_connect_challenges,
                    CMsgClientConnectionStats_Stats_VConn::get_failed_connect_challenges,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "micro_sec_avg_latency",
                    CMsgClientConnectionStats_Stats_VConn::has_micro_sec_avg_latency,
                    CMsgClientConnectionStats_Stats_VConn::get_micro_sec_avg_latency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "micro_sec_min_latency",
                    CMsgClientConnectionStats_Stats_VConn::has_micro_sec_min_latency,
                    CMsgClientConnectionStats_Stats_VConn::get_micro_sec_min_latency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "micro_sec_max_latency",
                    CMsgClientConnectionStats_Stats_VConn::has_micro_sec_max_latency,
                    CMsgClientConnectionStats_Stats_VConn::get_micro_sec_max_latency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "mem_pool_msg_in_use",
                    CMsgClientConnectionStats_Stats_VConn::has_mem_pool_msg_in_use,
                    CMsgClientConnectionStats_Stats_VConn::get_mem_pool_msg_in_use,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientConnectionStats_Stats_VConn>(
                    "CMsgClientConnectionStats_Stats_VConn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientConnectionStats_Stats_VConn {
    fn clear(&mut self) {
        self.clear_connections_udp();
        self.clear_connections_tcp();
        self.clear_stats_udp();
        self.clear_pkts_abandoned();
        self.clear_conn_req_received();
        self.clear_pkts_resent();
        self.clear_msgs_sent();
        self.clear_msgs_sent_failed();
        self.clear_msgs_recv();
        self.clear_datagrams_sent();
        self.clear_datagrams_recv();
        self.clear_bad_pkts_recv();
        self.clear_unknown_conn_pkts_recv();
        self.clear_missed_pkts_recv();
        self.clear_dup_pkts_recv();
        self.clear_failed_connect_challenges();
        self.clear_micro_sec_avg_latency();
        self.clear_micro_sec_min_latency();
        self.clear_micro_sec_max_latency();
        self.clear_mem_pool_msg_in_use();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientConnectionStats_Stats_VConn {
    fn eq(&self, other: &CMsgClientConnectionStats_Stats_VConn) -> bool {
        self.connections_udp == other.connections_udp &&
        self.connections_tcp == other.connections_tcp &&
        self.stats_udp == other.stats_udp &&
        self.pkts_abandoned == other.pkts_abandoned &&
        self.conn_req_received == other.conn_req_received &&
        self.pkts_resent == other.pkts_resent &&
        self.msgs_sent == other.msgs_sent &&
        self.msgs_sent_failed == other.msgs_sent_failed &&
        self.msgs_recv == other.msgs_recv &&
        self.datagrams_sent == other.datagrams_sent &&
        self.datagrams_recv == other.datagrams_recv &&
        self.bad_pkts_recv == other.bad_pkts_recv &&
        self.unknown_conn_pkts_recv == other.unknown_conn_pkts_recv &&
        self.missed_pkts_recv == other.missed_pkts_recv &&
        self.dup_pkts_recv == other.dup_pkts_recv &&
        self.failed_connect_challenges == other.failed_connect_challenges &&
        self.micro_sec_avg_latency == other.micro_sec_avg_latency &&
        self.micro_sec_min_latency == other.micro_sec_min_latency &&
        self.micro_sec_max_latency == other.micro_sec_max_latency &&
        self.mem_pool_msg_in_use == other.mem_pool_msg_in_use &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientConnectionStats_Stats_VConn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientServersAvailable {
    // message fields
    server_types_available: ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available>,
    server_type_for_auth_services: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientServersAvailable {}

impl CMsgClientServersAvailable {
    pub fn new() -> CMsgClientServersAvailable {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientServersAvailable {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientServersAvailable> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientServersAvailable,
        };
        unsafe {
            instance.get(|| {
                CMsgClientServersAvailable {
                    server_types_available: ::protobuf::RepeatedField::new(),
                    server_type_for_auth_services: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientServersAvailable.Server_Types_Available server_types_available = 1;

    pub fn clear_server_types_available(&mut self) {
        self.server_types_available.clear();
    }

    // Param is passed by value, moved
    pub fn set_server_types_available(&mut self, v: ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available>) {
        self.server_types_available = v;
    }

    // Mutable pointer to the field.
    pub fn mut_server_types_available<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available> {
        &mut self.server_types_available
    }

    // Take field
    pub fn take_server_types_available(&mut self) -> ::protobuf::RepeatedField<CMsgClientServersAvailable_Server_Types_Available> {
        ::std::mem::replace(&mut self.server_types_available, ::protobuf::RepeatedField::new())
    }

    pub fn get_server_types_available<'a>(&'a self) -> &'a [CMsgClientServersAvailable_Server_Types_Available] {
        &self.server_types_available
    }

    // optional uint32 server_type_for_auth_services = 2;

    pub fn clear_server_type_for_auth_services(&mut self) {
        self.server_type_for_auth_services = ::std::option::Option::None;
    }

    pub fn has_server_type_for_auth_services(&self) -> bool {
        self.server_type_for_auth_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type_for_auth_services(&mut self, v: u32) {
        self.server_type_for_auth_services = ::std::option::Option::Some(v);
    }

    pub fn get_server_type_for_auth_services<'a>(&self) -> u32 {
        self.server_type_for_auth_services.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.server_types_available));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.server_type_for_auth_services = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.server_types_available.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.server_type_for_auth_services.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.server_types_available.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.server_type_for_auth_services {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientServersAvailable>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientServersAvailable {
    fn new() -> CMsgClientServersAvailable {
        CMsgClientServersAvailable::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientServersAvailable>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "server_types_available",
                    CMsgClientServersAvailable::get_server_types_available,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "server_type_for_auth_services",
                    CMsgClientServersAvailable::has_server_type_for_auth_services,
                    CMsgClientServersAvailable::get_server_type_for_auth_services,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServersAvailable>(
                    "CMsgClientServersAvailable",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientServersAvailable {
    fn clear(&mut self) {
        self.clear_server_types_available();
        self.clear_server_type_for_auth_services();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientServersAvailable {
    fn eq(&self, other: &CMsgClientServersAvailable) -> bool {
        self.server_types_available == other.server_types_available &&
        self.server_type_for_auth_services == other.server_type_for_auth_services &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientServersAvailable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientServersAvailable_Server_Types_Available {
    // message fields
    server: ::std::option::Option<u32>,
    changed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientServersAvailable_Server_Types_Available {}

impl CMsgClientServersAvailable_Server_Types_Available {
    pub fn new() -> CMsgClientServersAvailable_Server_Types_Available {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientServersAvailable_Server_Types_Available {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientServersAvailable_Server_Types_Available> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientServersAvailable_Server_Types_Available,
        };
        unsafe {
            instance.get(|| {
                CMsgClientServersAvailable_Server_Types_Available {
                    server: ::std::option::Option::None,
                    changed: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 server = 1;

    pub fn clear_server(&mut self) {
        self.server = ::std::option::Option::None;
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: u32) {
        self.server = ::std::option::Option::Some(v);
    }

    pub fn get_server<'a>(&self) -> u32 {
        self.server.unwrap_or(0)
    }

    // optional bool changed = 2;

    pub fn clear_changed(&mut self) {
        self.changed = ::std::option::Option::None;
    }

    pub fn has_changed(&self) -> bool {
        self.changed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changed(&mut self, v: bool) {
        self.changed = ::std::option::Option::Some(v);
    }

    pub fn get_changed<'a>(&self) -> bool {
        self.changed.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientServersAvailable_Server_Types_Available {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.server = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.changed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.server.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.changed.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.server {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.changed {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientServersAvailable_Server_Types_Available>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientServersAvailable_Server_Types_Available {
    fn new() -> CMsgClientServersAvailable_Server_Types_Available {
        CMsgClientServersAvailable_Server_Types_Available::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientServersAvailable_Server_Types_Available>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "server",
                    CMsgClientServersAvailable_Server_Types_Available::has_server,
                    CMsgClientServersAvailable_Server_Types_Available::get_server,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "changed",
                    CMsgClientServersAvailable_Server_Types_Available::has_changed,
                    CMsgClientServersAvailable_Server_Types_Available::get_changed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientServersAvailable_Server_Types_Available>(
                    "CMsgClientServersAvailable_Server_Types_Available",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientServersAvailable_Server_Types_Available {
    fn clear(&mut self) {
        self.clear_server();
        self.clear_changed();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientServersAvailable_Server_Types_Available {
    fn eq(&self, other: &CMsgClientServersAvailable_Server_Types_Available) -> bool {
        self.server == other.server &&
        self.changed == other.changed &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientServersAvailable_Server_Types_Available {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetUserStats {
    // message fields
    game_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    schema_local_version: ::std::option::Option<i32>,
    steam_id_for_user: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetUserStats {}

impl CMsgClientGetUserStats {
    pub fn new() -> CMsgClientGetUserStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetUserStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetUserStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetUserStats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetUserStats {
                    game_id: ::std::option::Option::None,
                    crc_stats: ::std::option::Option::None,
                    schema_local_version: ::std::option::Option::None,
                    steam_id_for_user: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 game_id = 1;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional uint32 crc_stats = 2;

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    pub fn get_crc_stats<'a>(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    // optional int32 schema_local_version = 3;

    pub fn clear_schema_local_version(&mut self) {
        self.schema_local_version = ::std::option::Option::None;
    }

    pub fn has_schema_local_version(&self) -> bool {
        self.schema_local_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema_local_version(&mut self, v: i32) {
        self.schema_local_version = ::std::option::Option::Some(v);
    }

    pub fn get_schema_local_version<'a>(&self) -> i32 {
        self.schema_local_version.unwrap_or(0)
    }

    // optional fixed64 steam_id_for_user = 4;

    pub fn clear_steam_id_for_user(&mut self) {
        self.steam_id_for_user = ::std::option::Option::None;
    }

    pub fn has_steam_id_for_user(&self) -> bool {
        self.steam_id_for_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_for_user(&mut self, v: u64) {
        self.steam_id_for_user = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_for_user<'a>(&self) -> u64 {
        self.steam_id_for_user.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGetUserStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.schema_local_version = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_for_user = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_id.is_some() {
            my_size += 9;
        };
        for value in self.crc_stats.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.schema_local_version.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_for_user.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.crc_stats {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.schema_local_version {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.steam_id_for_user {
            try!(os.write_fixed64(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetUserStats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetUserStats {
    fn new() -> CMsgClientGetUserStats {
        CMsgClientGetUserStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetUserStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientGetUserStats::has_game_id,
                    CMsgClientGetUserStats::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "crc_stats",
                    CMsgClientGetUserStats::has_crc_stats,
                    CMsgClientGetUserStats::get_crc_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "schema_local_version",
                    CMsgClientGetUserStats::has_schema_local_version,
                    CMsgClientGetUserStats::get_schema_local_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_for_user",
                    CMsgClientGetUserStats::has_steam_id_for_user,
                    CMsgClientGetUserStats::get_steam_id_for_user,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetUserStats>(
                    "CMsgClientGetUserStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStats {
    fn clear(&mut self) {
        self.clear_game_id();
        self.clear_crc_stats();
        self.clear_schema_local_version();
        self.clear_steam_id_for_user();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetUserStats {
    fn eq(&self, other: &CMsgClientGetUserStats) -> bool {
        self.game_id == other.game_id &&
        self.crc_stats == other.crc_stats &&
        self.schema_local_version == other.schema_local_version &&
        self.steam_id_for_user == other.steam_id_for_user &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetUserStatsResponse {
    // message fields
    game_id: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    crc_stats: ::std::option::Option<u32>,
    schema: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    stats: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats>,
    achievement_blocks: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetUserStatsResponse {}

impl CMsgClientGetUserStatsResponse {
    pub fn new() -> CMsgClientGetUserStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetUserStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetUserStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetUserStatsResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetUserStatsResponse {
                    game_id: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    crc_stats: ::std::option::Option::None,
                    schema: ::protobuf::SingularField::none(),
                    stats: ::protobuf::RepeatedField::new(),
                    achievement_blocks: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 game_id = 1;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional int32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional uint32 crc_stats = 3;

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    pub fn get_crc_stats<'a>(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    // optional bytes schema = 4;

    pub fn clear_schema(&mut self) {
        self.schema.clear();
    }

    pub fn has_schema(&self) -> bool {
        self.schema.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schema(&mut self, v: ::std::vec::Vec<u8>) {
        self.schema = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schema<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.schema.is_none() {
            self.schema.set_default();
        };
        self.schema.as_mut().unwrap()
    }

    // Take field
    pub fn take_schema(&mut self) -> ::std::vec::Vec<u8> {
        self.schema.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_schema<'a>(&'a self) -> &'a [u8] {
        match self.schema.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // repeated .CMsgClientGetUserStatsResponse.Stats stats = 5;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Stats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats<'a>(&'a self) -> &'a [CMsgClientGetUserStatsResponse_Stats] {
        &self.stats
    }

    // repeated .CMsgClientGetUserStatsResponse.Achievement_Blocks achievement_blocks = 6;

    pub fn clear_achievement_blocks(&mut self) {
        self.achievement_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_achievement_blocks(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks>) {
        self.achievement_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_achievement_blocks<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks> {
        &mut self.achievement_blocks
    }

    // Take field
    pub fn take_achievement_blocks(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetUserStatsResponse_Achievement_Blocks> {
        ::std::mem::replace(&mut self.achievement_blocks, ::protobuf::RepeatedField::new())
    }

    pub fn get_achievement_blocks<'a>(&'a self) -> &'a [CMsgClientGetUserStatsResponse_Achievement_Blocks] {
        &self.achievement_blocks
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.schema));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.achievement_blocks));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_id.is_some() {
            my_size += 9;
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.crc_stats.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.schema.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.achievement_blocks.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.crc_stats {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.schema.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        for v in self.stats.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.achievement_blocks.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetUserStatsResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetUserStatsResponse {
    fn new() -> CMsgClientGetUserStatsResponse {
        CMsgClientGetUserStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetUserStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientGetUserStatsResponse::has_game_id,
                    CMsgClientGetUserStatsResponse::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientGetUserStatsResponse::has_eresult,
                    CMsgClientGetUserStatsResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "crc_stats",
                    CMsgClientGetUserStatsResponse::has_crc_stats,
                    CMsgClientGetUserStatsResponse::get_crc_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "schema",
                    CMsgClientGetUserStatsResponse::has_schema,
                    CMsgClientGetUserStatsResponse::get_schema,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "stats",
                    CMsgClientGetUserStatsResponse::get_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "achievement_blocks",
                    CMsgClientGetUserStatsResponse::get_achievement_blocks,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetUserStatsResponse>(
                    "CMsgClientGetUserStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse {
    fn clear(&mut self) {
        self.clear_game_id();
        self.clear_eresult();
        self.clear_crc_stats();
        self.clear_schema();
        self.clear_stats();
        self.clear_achievement_blocks();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetUserStatsResponse {
    fn eq(&self, other: &CMsgClientGetUserStatsResponse) -> bool {
        self.game_id == other.game_id &&
        self.eresult == other.eresult &&
        self.crc_stats == other.crc_stats &&
        self.schema == other.schema &&
        self.stats == other.stats &&
        self.achievement_blocks == other.achievement_blocks &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetUserStatsResponse_Stats {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetUserStatsResponse_Stats {}

impl CMsgClientGetUserStatsResponse_Stats {
    pub fn new() -> CMsgClientGetUserStatsResponse_Stats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetUserStatsResponse_Stats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetUserStatsResponse_Stats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetUserStatsResponse_Stats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetUserStatsResponse_Stats {
                    stat_id: ::std::option::Option::None,
                    stat_value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 stat_id = 1;

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    pub fn get_stat_id<'a>(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }

    // optional uint32 stat_value = 2;

    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }

    pub fn get_stat_value<'a>(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stat_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stat_value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.stat_value {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetUserStatsResponse_Stats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetUserStatsResponse_Stats {
    fn new() -> CMsgClientGetUserStatsResponse_Stats {
        CMsgClientGetUserStatsResponse_Stats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetUserStatsResponse_Stats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_id",
                    CMsgClientGetUserStatsResponse_Stats::has_stat_id,
                    CMsgClientGetUserStatsResponse_Stats::get_stat_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_value",
                    CMsgClientGetUserStatsResponse_Stats::has_stat_value,
                    CMsgClientGetUserStatsResponse_Stats::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetUserStatsResponse_Stats>(
                    "CMsgClientGetUserStatsResponse_Stats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse_Stats {
    fn clear(&mut self) {
        self.clear_stat_id();
        self.clear_stat_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetUserStatsResponse_Stats {
    fn eq(&self, other: &CMsgClientGetUserStatsResponse_Stats) -> bool {
        self.stat_id == other.stat_id &&
        self.stat_value == other.stat_value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetUserStatsResponse_Achievement_Blocks {
    // message fields
    achievement_id: ::std::option::Option<u32>,
    unlock_time: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetUserStatsResponse_Achievement_Blocks {}

impl CMsgClientGetUserStatsResponse_Achievement_Blocks {
    pub fn new() -> CMsgClientGetUserStatsResponse_Achievement_Blocks {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetUserStatsResponse_Achievement_Blocks {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetUserStatsResponse_Achievement_Blocks> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetUserStatsResponse_Achievement_Blocks,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetUserStatsResponse_Achievement_Blocks {
                    achievement_id: ::std::option::Option::None,
                    unlock_time: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 achievement_id = 1;

    pub fn clear_achievement_id(&mut self) {
        self.achievement_id = ::std::option::Option::None;
    }

    pub fn has_achievement_id(&self) -> bool {
        self.achievement_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement_id(&mut self, v: u32) {
        self.achievement_id = ::std::option::Option::Some(v);
    }

    pub fn get_achievement_id<'a>(&self) -> u32 {
        self.achievement_id.unwrap_or(0)
    }

    // repeated fixed32 unlock_time = 2;

    pub fn clear_unlock_time(&mut self) {
        self.unlock_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_unlock_time(&mut self, v: ::std::vec::Vec<u32>) {
        self.unlock_time = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unlock_time<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.unlock_time
    }

    // Take field
    pub fn take_unlock_time(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unlock_time, ::std::vec::Vec::new())
    }

    pub fn get_unlock_time<'a>(&'a self) -> &'a [u32] {
        &self.unlock_time
    }
}

impl ::protobuf::Message for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.achievement_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_fixed32_into(wire_type, is, &mut self.unlock_time));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.achievement_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 5 * self.unlock_time.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.achievement_id {
            try!(os.write_uint32(1, v));
        };
        for v in self.unlock_time.iter() {
            try!(os.write_fixed32(2, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetUserStatsResponse_Achievement_Blocks>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn new() -> CMsgClientGetUserStatsResponse_Achievement_Blocks {
        CMsgClientGetUserStatsResponse_Achievement_Blocks::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetUserStatsResponse_Achievement_Blocks>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "achievement_id",
                    CMsgClientGetUserStatsResponse_Achievement_Blocks::has_achievement_id,
                    CMsgClientGetUserStatsResponse_Achievement_Blocks::get_achievement_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "unlock_time",
                    CMsgClientGetUserStatsResponse_Achievement_Blocks::get_unlock_time,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetUserStatsResponse_Achievement_Blocks>(
                    "CMsgClientGetUserStatsResponse_Achievement_Blocks",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn clear(&mut self) {
        self.clear_achievement_id();
        self.clear_unlock_time();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn eq(&self, other: &CMsgClientGetUserStatsResponse_Achievement_Blocks) -> bool {
        self.achievement_id == other.achievement_id &&
        self.unlock_time == other.unlock_time &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetUserStatsResponse_Achievement_Blocks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStoreUserStatsResponse {
    // message fields
    game_id: ::std::option::Option<u64>,
    eresult: ::std::option::Option<i32>,
    crc_stats: ::std::option::Option<u32>,
    stats_failed_validation: ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>,
    stats_out_of_date: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStoreUserStatsResponse {}

impl CMsgClientStoreUserStatsResponse {
    pub fn new() -> CMsgClientStoreUserStatsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStoreUserStatsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStoreUserStatsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStoreUserStatsResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStoreUserStatsResponse {
                    game_id: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    crc_stats: ::std::option::Option::None,
                    stats_failed_validation: ::protobuf::RepeatedField::new(),
                    stats_out_of_date: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 game_id = 1;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional int32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional uint32 crc_stats = 3;

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    pub fn get_crc_stats<'a>(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    // repeated .CMsgClientStoreUserStatsResponse.Stats_Failed_Validation stats_failed_validation = 4;

    pub fn clear_stats_failed_validation(&mut self) {
        self.stats_failed_validation.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_failed_validation(&mut self, v: ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>) {
        self.stats_failed_validation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_failed_validation<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> {
        &mut self.stats_failed_validation
    }

    // Take field
    pub fn take_stats_failed_validation(&mut self) -> ::protobuf::RepeatedField<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> {
        ::std::mem::replace(&mut self.stats_failed_validation, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats_failed_validation<'a>(&'a self) -> &'a [CMsgClientStoreUserStatsResponse_Stats_Failed_Validation] {
        &self.stats_failed_validation
    }

    // optional bool stats_out_of_date = 5;

    pub fn clear_stats_out_of_date(&mut self) {
        self.stats_out_of_date = ::std::option::Option::None;
    }

    pub fn has_stats_out_of_date(&self) -> bool {
        self.stats_out_of_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_out_of_date(&mut self, v: bool) {
        self.stats_out_of_date = ::std::option::Option::Some(v);
    }

    pub fn get_stats_out_of_date<'a>(&self) -> bool {
        self.stats_out_of_date.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStatsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_failed_validation));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.stats_out_of_date = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_id.is_some() {
            my_size += 9;
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.crc_stats.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stats_failed_validation.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.stats_out_of_date.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.crc_stats {
            try!(os.write_uint32(3, v));
        };
        for v in self.stats_failed_validation.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.stats_out_of_date {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStoreUserStatsResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStoreUserStatsResponse {
    fn new() -> CMsgClientStoreUserStatsResponse {
        CMsgClientStoreUserStatsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStoreUserStatsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientStoreUserStatsResponse::has_game_id,
                    CMsgClientStoreUserStatsResponse::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientStoreUserStatsResponse::has_eresult,
                    CMsgClientStoreUserStatsResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "crc_stats",
                    CMsgClientStoreUserStatsResponse::has_crc_stats,
                    CMsgClientStoreUserStatsResponse::get_crc_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "stats_failed_validation",
                    CMsgClientStoreUserStatsResponse::get_stats_failed_validation,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "stats_out_of_date",
                    CMsgClientStoreUserStatsResponse::has_stats_out_of_date,
                    CMsgClientStoreUserStatsResponse::get_stats_out_of_date,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStatsResponse>(
                    "CMsgClientStoreUserStatsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStatsResponse {
    fn clear(&mut self) {
        self.clear_game_id();
        self.clear_eresult();
        self.clear_crc_stats();
        self.clear_stats_failed_validation();
        self.clear_stats_out_of_date();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStoreUserStatsResponse {
    fn eq(&self, other: &CMsgClientStoreUserStatsResponse) -> bool {
        self.game_id == other.game_id &&
        self.eresult == other.eresult &&
        self.crc_stats == other.crc_stats &&
        self.stats_failed_validation == other.stats_failed_validation &&
        self.stats_out_of_date == other.stats_out_of_date &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    // message fields
    stat_id: ::std::option::Option<u32>,
    reverted_stat_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {}

impl CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    pub fn new() -> CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStoreUserStatsResponse_Stats_Failed_Validation,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
                    stat_id: ::std::option::Option::None,
                    reverted_stat_value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 stat_id = 1;

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    pub fn get_stat_id<'a>(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }

    // optional uint32 reverted_stat_value = 2;

    pub fn clear_reverted_stat_value(&mut self) {
        self.reverted_stat_value = ::std::option::Option::None;
    }

    pub fn has_reverted_stat_value(&self) -> bool {
        self.reverted_stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reverted_stat_value(&mut self, v: u32) {
        self.reverted_stat_value = ::std::option::Option::Some(v);
    }

    pub fn get_reverted_stat_value<'a>(&self) -> u32 {
        self.reverted_stat_value.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.reverted_stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stat_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.reverted_stat_value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.reverted_stat_value {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn new() -> CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
        CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_id",
                    CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::has_stat_id,
                    CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::get_stat_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "reverted_stat_value",
                    CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::has_reverted_stat_value,
                    CMsgClientStoreUserStatsResponse_Stats_Failed_Validation::get_reverted_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStatsResponse_Stats_Failed_Validation>(
                    "CMsgClientStoreUserStatsResponse_Stats_Failed_Validation",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn clear(&mut self) {
        self.clear_stat_id();
        self.clear_reverted_stat_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn eq(&self, other: &CMsgClientStoreUserStatsResponse_Stats_Failed_Validation) -> bool {
        self.stat_id == other.stat_id &&
        self.reverted_stat_value == other.reverted_stat_value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStatsResponse_Stats_Failed_Validation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStoreUserStats2 {
    // message fields
    game_id: ::std::option::Option<u64>,
    settor_steam_id: ::std::option::Option<u64>,
    settee_steam_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    explicit_reset: ::std::option::Option<bool>,
    stats: ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStoreUserStats2 {}

impl CMsgClientStoreUserStats2 {
    pub fn new() -> CMsgClientStoreUserStats2 {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStoreUserStats2 {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStoreUserStats2> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStoreUserStats2,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStoreUserStats2 {
                    game_id: ::std::option::Option::None,
                    settor_steam_id: ::std::option::Option::None,
                    settee_steam_id: ::std::option::Option::None,
                    crc_stats: ::std::option::Option::None,
                    explicit_reset: ::std::option::Option::None,
                    stats: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 game_id = 1;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional fixed64 settor_steam_id = 2;

    pub fn clear_settor_steam_id(&mut self) {
        self.settor_steam_id = ::std::option::Option::None;
    }

    pub fn has_settor_steam_id(&self) -> bool {
        self.settor_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settor_steam_id(&mut self, v: u64) {
        self.settor_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_settor_steam_id<'a>(&self) -> u64 {
        self.settor_steam_id.unwrap_or(0)
    }

    // optional fixed64 settee_steam_id = 3;

    pub fn clear_settee_steam_id(&mut self) {
        self.settee_steam_id = ::std::option::Option::None;
    }

    pub fn has_settee_steam_id(&self) -> bool {
        self.settee_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_settee_steam_id(&mut self, v: u64) {
        self.settee_steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_settee_steam_id<'a>(&self) -> u64 {
        self.settee_steam_id.unwrap_or(0)
    }

    // optional uint32 crc_stats = 4;

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    pub fn get_crc_stats<'a>(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    // optional bool explicit_reset = 5;

    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }

    pub fn get_explicit_reset<'a>(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }

    // repeated .CMsgClientStoreUserStats2.Stats stats = 6;

    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientStoreUserStats2_Stats> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats<'a>(&'a self) -> &'a [CMsgClientStoreUserStats2_Stats] {
        &self.stats
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.settor_steam_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.settee_steam_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.explicit_reset = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_id.is_some() {
            my_size += 9;
        };
        if self.settor_steam_id.is_some() {
            my_size += 9;
        };
        if self.settee_steam_id.is_some() {
            my_size += 9;
        };
        for value in self.crc_stats.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.explicit_reset.is_some() {
            my_size += 2;
        };
        for value in self.stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.settor_steam_id {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.settee_steam_id {
            try!(os.write_fixed64(3, v));
        };
        if let Some(v) = self.crc_stats {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.explicit_reset {
            try!(os.write_bool(5, v));
        };
        for v in self.stats.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStoreUserStats2>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStoreUserStats2 {
    fn new() -> CMsgClientStoreUserStats2 {
        CMsgClientStoreUserStats2::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStoreUserStats2>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientStoreUserStats2::has_game_id,
                    CMsgClientStoreUserStats2::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "settor_steam_id",
                    CMsgClientStoreUserStats2::has_settor_steam_id,
                    CMsgClientStoreUserStats2::get_settor_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "settee_steam_id",
                    CMsgClientStoreUserStats2::has_settee_steam_id,
                    CMsgClientStoreUserStats2::get_settee_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "crc_stats",
                    CMsgClientStoreUserStats2::has_crc_stats,
                    CMsgClientStoreUserStats2::get_crc_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "explicit_reset",
                    CMsgClientStoreUserStats2::has_explicit_reset,
                    CMsgClientStoreUserStats2::get_explicit_reset,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "stats",
                    CMsgClientStoreUserStats2::get_stats,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStats2>(
                    "CMsgClientStoreUserStats2",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats2 {
    fn clear(&mut self) {
        self.clear_game_id();
        self.clear_settor_steam_id();
        self.clear_settee_steam_id();
        self.clear_crc_stats();
        self.clear_explicit_reset();
        self.clear_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStoreUserStats2 {
    fn eq(&self, other: &CMsgClientStoreUserStats2) -> bool {
        self.game_id == other.game_id &&
        self.settor_steam_id == other.settor_steam_id &&
        self.settee_steam_id == other.settee_steam_id &&
        self.crc_stats == other.crc_stats &&
        self.explicit_reset == other.explicit_reset &&
        self.stats == other.stats &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStoreUserStats2_Stats {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStoreUserStats2_Stats {}

impl CMsgClientStoreUserStats2_Stats {
    pub fn new() -> CMsgClientStoreUserStats2_Stats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStoreUserStats2_Stats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStoreUserStats2_Stats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStoreUserStats2_Stats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStoreUserStats2_Stats {
                    stat_id: ::std::option::Option::None,
                    stat_value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 stat_id = 1;

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    pub fn get_stat_id<'a>(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }

    // optional uint32 stat_value = 2;

    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }

    pub fn get_stat_value<'a>(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats2_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stat_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stat_value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.stat_value {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStoreUserStats2_Stats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStoreUserStats2_Stats {
    fn new() -> CMsgClientStoreUserStats2_Stats {
        CMsgClientStoreUserStats2_Stats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStoreUserStats2_Stats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_id",
                    CMsgClientStoreUserStats2_Stats::has_stat_id,
                    CMsgClientStoreUserStats2_Stats::get_stat_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_value",
                    CMsgClientStoreUserStats2_Stats::has_stat_value,
                    CMsgClientStoreUserStats2_Stats::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStats2_Stats>(
                    "CMsgClientStoreUserStats2_Stats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats2_Stats {
    fn clear(&mut self) {
        self.clear_stat_id();
        self.clear_stat_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStoreUserStats2_Stats {
    fn eq(&self, other: &CMsgClientStoreUserStats2_Stats) -> bool {
        self.stat_id == other.stat_id &&
        self.stat_value == other.stat_value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats2_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStatsUpdated {
    // message fields
    steam_id: ::std::option::Option<u64>,
    game_id: ::std::option::Option<u64>,
    crc_stats: ::std::option::Option<u32>,
    updated_stats: ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStatsUpdated {}

impl CMsgClientStatsUpdated {
    pub fn new() -> CMsgClientStatsUpdated {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStatsUpdated {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStatsUpdated> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStatsUpdated,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStatsUpdated {
                    steam_id: ::std::option::Option::None,
                    game_id: ::std::option::Option::None,
                    crc_stats: ::std::option::Option::None,
                    updated_stats: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steam_id = 1;

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id<'a>(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    // optional fixed64 game_id = 2;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional uint32 crc_stats = 3;

    pub fn clear_crc_stats(&mut self) {
        self.crc_stats = ::std::option::Option::None;
    }

    pub fn has_crc_stats(&self) -> bool {
        self.crc_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc_stats(&mut self, v: u32) {
        self.crc_stats = ::std::option::Option::Some(v);
    }

    pub fn get_crc_stats<'a>(&self) -> u32 {
        self.crc_stats.unwrap_or(0)
    }

    // repeated .CMsgClientStatsUpdated.Updated_Stats updated_stats = 4;

    pub fn clear_updated_stats(&mut self) {
        self.updated_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_updated_stats(&mut self, v: ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats>) {
        self.updated_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_updated_stats<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats> {
        &mut self.updated_stats
    }

    // Take field
    pub fn take_updated_stats(&mut self) -> ::protobuf::RepeatedField<CMsgClientStatsUpdated_Updated_Stats> {
        ::std::mem::replace(&mut self.updated_stats, ::protobuf::RepeatedField::new())
    }

    pub fn get_updated_stats<'a>(&'a self) -> &'a [CMsgClientStatsUpdated_Updated_Stats] {
        &self.updated_stats
    }
}

impl ::protobuf::Message for CMsgClientStatsUpdated {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.crc_stats = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.updated_stats));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steam_id.is_some() {
            my_size += 9;
        };
        if self.game_id.is_some() {
            my_size += 9;
        };
        for value in self.crc_stats.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.updated_stats.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steam_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.crc_stats {
            try!(os.write_uint32(3, v));
        };
        for v in self.updated_stats.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStatsUpdated>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStatsUpdated {
    fn new() -> CMsgClientStatsUpdated {
        CMsgClientStatsUpdated::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStatsUpdated>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id",
                    CMsgClientStatsUpdated::has_steam_id,
                    CMsgClientStatsUpdated::get_steam_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientStatsUpdated::has_game_id,
                    CMsgClientStatsUpdated::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "crc_stats",
                    CMsgClientStatsUpdated::has_crc_stats,
                    CMsgClientStatsUpdated::get_crc_stats,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "updated_stats",
                    CMsgClientStatsUpdated::get_updated_stats,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStatsUpdated>(
                    "CMsgClientStatsUpdated",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStatsUpdated {
    fn clear(&mut self) {
        self.clear_steam_id();
        self.clear_game_id();
        self.clear_crc_stats();
        self.clear_updated_stats();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStatsUpdated {
    fn eq(&self, other: &CMsgClientStatsUpdated) -> bool {
        self.steam_id == other.steam_id &&
        self.game_id == other.game_id &&
        self.crc_stats == other.crc_stats &&
        self.updated_stats == other.updated_stats &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStatsUpdated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStatsUpdated_Updated_Stats {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStatsUpdated_Updated_Stats {}

impl CMsgClientStatsUpdated_Updated_Stats {
    pub fn new() -> CMsgClientStatsUpdated_Updated_Stats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStatsUpdated_Updated_Stats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStatsUpdated_Updated_Stats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStatsUpdated_Updated_Stats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStatsUpdated_Updated_Stats {
                    stat_id: ::std::option::Option::None,
                    stat_value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 stat_id = 1;

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    pub fn get_stat_id<'a>(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }

    // optional uint32 stat_value = 2;

    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }

    pub fn get_stat_value<'a>(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientStatsUpdated_Updated_Stats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stat_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stat_value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.stat_value {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStatsUpdated_Updated_Stats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStatsUpdated_Updated_Stats {
    fn new() -> CMsgClientStatsUpdated_Updated_Stats {
        CMsgClientStatsUpdated_Updated_Stats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStatsUpdated_Updated_Stats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_id",
                    CMsgClientStatsUpdated_Updated_Stats::has_stat_id,
                    CMsgClientStatsUpdated_Updated_Stats::get_stat_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_value",
                    CMsgClientStatsUpdated_Updated_Stats::has_stat_value,
                    CMsgClientStatsUpdated_Updated_Stats::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStatsUpdated_Updated_Stats>(
                    "CMsgClientStatsUpdated_Updated_Stats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStatsUpdated_Updated_Stats {
    fn clear(&mut self) {
        self.clear_stat_id();
        self.clear_stat_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStatsUpdated_Updated_Stats {
    fn eq(&self, other: &CMsgClientStatsUpdated_Updated_Stats) -> bool {
        self.stat_id == other.stat_id &&
        self.stat_value == other.stat_value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStatsUpdated_Updated_Stats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStoreUserStats {
    // message fields
    game_id: ::std::option::Option<u64>,
    explicit_reset: ::std::option::Option<bool>,
    stats_to_store: ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStoreUserStats {}

impl CMsgClientStoreUserStats {
    pub fn new() -> CMsgClientStoreUserStats {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStoreUserStats {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStoreUserStats> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStoreUserStats,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStoreUserStats {
                    game_id: ::std::option::Option::None,
                    explicit_reset: ::std::option::Option::None,
                    stats_to_store: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 game_id = 1;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional bool explicit_reset = 2;

    pub fn clear_explicit_reset(&mut self) {
        self.explicit_reset = ::std::option::Option::None;
    }

    pub fn has_explicit_reset(&self) -> bool {
        self.explicit_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_reset(&mut self, v: bool) {
        self.explicit_reset = ::std::option::Option::Some(v);
    }

    pub fn get_explicit_reset<'a>(&self) -> bool {
        self.explicit_reset.unwrap_or(false)
    }

    // repeated .CMsgClientStoreUserStats.Stats_To_Store stats_to_store = 3;

    pub fn clear_stats_to_store(&mut self) {
        self.stats_to_store.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_to_store(&mut self, v: ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store>) {
        self.stats_to_store = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_to_store<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store> {
        &mut self.stats_to_store
    }

    // Take field
    pub fn take_stats_to_store(&mut self) -> ::protobuf::RepeatedField<CMsgClientStoreUserStats_Stats_To_Store> {
        ::std::mem::replace(&mut self.stats_to_store, ::protobuf::RepeatedField::new())
    }

    pub fn get_stats_to_store<'a>(&'a self) -> &'a [CMsgClientStoreUserStats_Stats_To_Store] {
        &self.stats_to_store
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.explicit_reset = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_to_store));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.game_id.is_some() {
            my_size += 9;
        };
        if self.explicit_reset.is_some() {
            my_size += 2;
        };
        for value in self.stats_to_store.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.explicit_reset {
            try!(os.write_bool(2, v));
        };
        for v in self.stats_to_store.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStoreUserStats>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStoreUserStats {
    fn new() -> CMsgClientStoreUserStats {
        CMsgClientStoreUserStats::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStoreUserStats>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientStoreUserStats::has_game_id,
                    CMsgClientStoreUserStats::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "explicit_reset",
                    CMsgClientStoreUserStats::has_explicit_reset,
                    CMsgClientStoreUserStats::get_explicit_reset,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "stats_to_store",
                    CMsgClientStoreUserStats::get_stats_to_store,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStats>(
                    "CMsgClientStoreUserStats",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats {
    fn clear(&mut self) {
        self.clear_game_id();
        self.clear_explicit_reset();
        self.clear_stats_to_store();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStoreUserStats {
    fn eq(&self, other: &CMsgClientStoreUserStats) -> bool {
        self.game_id == other.game_id &&
        self.explicit_reset == other.explicit_reset &&
        self.stats_to_store == other.stats_to_store &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientStoreUserStats_Stats_To_Store {
    // message fields
    stat_id: ::std::option::Option<u32>,
    stat_value: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientStoreUserStats_Stats_To_Store {}

impl CMsgClientStoreUserStats_Stats_To_Store {
    pub fn new() -> CMsgClientStoreUserStats_Stats_To_Store {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientStoreUserStats_Stats_To_Store {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientStoreUserStats_Stats_To_Store> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientStoreUserStats_Stats_To_Store,
        };
        unsafe {
            instance.get(|| {
                CMsgClientStoreUserStats_Stats_To_Store {
                    stat_id: ::std::option::Option::None,
                    stat_value: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 stat_id = 1;

    pub fn clear_stat_id(&mut self) {
        self.stat_id = ::std::option::Option::None;
    }

    pub fn has_stat_id(&self) -> bool {
        self.stat_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_id(&mut self, v: u32) {
        self.stat_id = ::std::option::Option::Some(v);
    }

    pub fn get_stat_id<'a>(&self) -> u32 {
        self.stat_id.unwrap_or(0)
    }

    // optional uint32 stat_value = 2;

    pub fn clear_stat_value(&mut self) {
        self.stat_value = ::std::option::Option::None;
    }

    pub fn has_stat_value(&self) -> bool {
        self.stat_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stat_value(&mut self, v: u32) {
        self.stat_value = ::std::option::Option::Some(v);
    }

    pub fn get_stat_value<'a>(&self) -> u32 {
        self.stat_value.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientStoreUserStats_Stats_To_Store {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.stat_value = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.stat_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.stat_value.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stat_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.stat_value {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientStoreUserStats_Stats_To_Store>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientStoreUserStats_Stats_To_Store {
    fn new() -> CMsgClientStoreUserStats_Stats_To_Store {
        CMsgClientStoreUserStats_Stats_To_Store::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientStoreUserStats_Stats_To_Store>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_id",
                    CMsgClientStoreUserStats_Stats_To_Store::has_stat_id,
                    CMsgClientStoreUserStats_Stats_To_Store::get_stat_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "stat_value",
                    CMsgClientStoreUserStats_Stats_To_Store::has_stat_value,
                    CMsgClientStoreUserStats_Stats_To_Store::get_stat_value,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientStoreUserStats_Stats_To_Store>(
                    "CMsgClientStoreUserStats_Stats_To_Store",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientStoreUserStats_Stats_To_Store {
    fn clear(&mut self) {
        self.clear_stat_id();
        self.clear_stat_value();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientStoreUserStats_Stats_To_Store {
    fn eq(&self, other: &CMsgClientStoreUserStats_Stats_To_Store) -> bool {
        self.stat_id == other.stat_id &&
        self.stat_value == other.stat_value &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientStoreUserStats_Stats_To_Store {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientDetails {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientDetails {}

impl CMsgClientGetClientDetails {
    pub fn new() -> CMsgClientGetClientDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientDetails,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientDetails {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientDetails>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientDetails {
    fn new() -> CMsgClientGetClientDetails {
        CMsgClientGetClientDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientDetails>(
                    "CMsgClientGetClientDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetails {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientDetails {
    fn eq(&self, other: &CMsgClientGetClientDetails) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientReportOverlayDetourFailure {
    // message fields
    failure_strings: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientReportOverlayDetourFailure {}

impl CMsgClientReportOverlayDetourFailure {
    pub fn new() -> CMsgClientReportOverlayDetourFailure {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientReportOverlayDetourFailure {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientReportOverlayDetourFailure> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientReportOverlayDetourFailure,
        };
        unsafe {
            instance.get(|| {
                CMsgClientReportOverlayDetourFailure {
                    failure_strings: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated string failure_strings = 1;

    pub fn clear_failure_strings(&mut self) {
        self.failure_strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_failure_strings(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.failure_strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failure_strings<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.failure_strings
    }

    // Take field
    pub fn take_failure_strings(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.failure_strings, ::protobuf::RepeatedField::new())
    }

    pub fn get_failure_strings<'a>(&'a self) -> &'a [::std::string::String] {
        &self.failure_strings
    }
}

impl ::protobuf::Message for CMsgClientReportOverlayDetourFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.failure_strings));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.failure_strings.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.failure_strings.iter() {
            try!(os.write_string(1, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientReportOverlayDetourFailure>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientReportOverlayDetourFailure {
    fn new() -> CMsgClientReportOverlayDetourFailure {
        CMsgClientReportOverlayDetourFailure::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientReportOverlayDetourFailure>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "failure_strings",
                    CMsgClientReportOverlayDetourFailure::get_failure_strings,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientReportOverlayDetourFailure>(
                    "CMsgClientReportOverlayDetourFailure",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientReportOverlayDetourFailure {
    fn clear(&mut self) {
        self.clear_failure_strings();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientReportOverlayDetourFailure {
    fn eq(&self, other: &CMsgClientReportOverlayDetourFailure) -> bool {
        self.failure_strings == other.failure_strings &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientReportOverlayDetourFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientDetailsResponse {
    // message fields
    package_version: ::std::option::Option<u32>,
    protocol_version: ::std::option::Option<u32>,
    os: ::protobuf::SingularField<::std::string::String>,
    machine_name: ::protobuf::SingularField<::std::string::String>,
    ip_public: ::protobuf::SingularField<::std::string::String>,
    ip_private: ::protobuf::SingularField<::std::string::String>,
    bytes_available: ::std::option::Option<u64>,
    games_running: ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientDetailsResponse {}

impl CMsgClientGetClientDetailsResponse {
    pub fn new() -> CMsgClientGetClientDetailsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientDetailsResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientDetailsResponse {
                    package_version: ::std::option::Option::None,
                    protocol_version: ::std::option::Option::None,
                    os: ::protobuf::SingularField::none(),
                    machine_name: ::protobuf::SingularField::none(),
                    ip_public: ::protobuf::SingularField::none(),
                    ip_private: ::protobuf::SingularField::none(),
                    bytes_available: ::std::option::Option::None,
                    games_running: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 package_version = 1;

    pub fn clear_package_version(&mut self) {
        self.package_version = ::std::option::Option::None;
    }

    pub fn has_package_version(&self) -> bool {
        self.package_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_version(&mut self, v: u32) {
        self.package_version = ::std::option::Option::Some(v);
    }

    pub fn get_package_version<'a>(&self) -> u32 {
        self.package_version.unwrap_or(0)
    }

    // optional uint32 protocol_version = 8;

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    pub fn get_protocol_version<'a>(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    // optional string os = 2;

    pub fn clear_os(&mut self) {
        self.os.clear();
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: ::std::string::String) {
        self.os = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_os<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.os.is_none() {
            self.os.set_default();
        };
        self.os.as_mut().unwrap()
    }

    // Take field
    pub fn take_os(&mut self) -> ::std::string::String {
        self.os.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_os<'a>(&'a self) -> &'a str {
        match self.os.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string machine_name = 3;

    pub fn clear_machine_name(&mut self) {
        self.machine_name.clear();
    }

    pub fn has_machine_name(&self) -> bool {
        self.machine_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machine_name(&mut self, v: ::std::string::String) {
        self.machine_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.machine_name.is_none() {
            self.machine_name.set_default();
        };
        self.machine_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_machine_name(&mut self) -> ::std::string::String {
        self.machine_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_machine_name<'a>(&'a self) -> &'a str {
        match self.machine_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ip_public = 4;

    pub fn clear_ip_public(&mut self) {
        self.ip_public.clear();
    }

    pub fn has_ip_public(&self) -> bool {
        self.ip_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_public(&mut self, v: ::std::string::String) {
        self.ip_public = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_public<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip_public.is_none() {
            self.ip_public.set_default();
        };
        self.ip_public.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_public(&mut self) -> ::std::string::String {
        self.ip_public.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_public<'a>(&'a self) -> &'a str {
        match self.ip_public.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string ip_private = 5;

    pub fn clear_ip_private(&mut self) {
        self.ip_private.clear();
    }

    pub fn has_ip_private(&self) -> bool {
        self.ip_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_private(&mut self, v: ::std::string::String) {
        self.ip_private = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_private<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.ip_private.is_none() {
            self.ip_private.set_default();
        };
        self.ip_private.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_private(&mut self) -> ::std::string::String {
        self.ip_private.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_ip_private<'a>(&'a self) -> &'a str {
        match self.ip_private.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint64 bytes_available = 7;

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_available<'a>(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }

    // repeated .CMsgClientGetClientDetailsResponse.Game games_running = 6;

    pub fn clear_games_running(&mut self) {
        self.games_running.clear();
    }

    // Param is passed by value, moved
    pub fn set_games_running(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game>) {
        self.games_running = v;
    }

    // Mutable pointer to the field.
    pub fn mut_games_running<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game> {
        &mut self.games_running
    }

    // Take field
    pub fn take_games_running(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetClientDetailsResponse_Game> {
        ::std::mem::replace(&mut self.games_running, ::protobuf::RepeatedField::new())
    }

    pub fn get_games_running<'a>(&'a self) -> &'a [CMsgClientGetClientDetailsResponse_Game] {
        &self.games_running
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.package_version = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.os));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machine_name));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_public));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip_private));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes_available = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.games_running));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.package_version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.protocol_version.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.os.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.machine_name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.ip_public.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.ip_private.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.bytes_available.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.games_running.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_version {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.protocol_version {
            try!(os.write_uint32(8, v));
        };
        if let Some(v) = self.os.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.machine_name.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.ip_public.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.ip_private.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.bytes_available {
            try!(os.write_uint64(7, v));
        };
        for v in self.games_running.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientDetailsResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientDetailsResponse {
    fn new() -> CMsgClientGetClientDetailsResponse {
        CMsgClientGetClientDetailsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientDetailsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "package_version",
                    CMsgClientGetClientDetailsResponse::has_package_version,
                    CMsgClientGetClientDetailsResponse::get_package_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "protocol_version",
                    CMsgClientGetClientDetailsResponse::has_protocol_version,
                    CMsgClientGetClientDetailsResponse::get_protocol_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "os",
                    CMsgClientGetClientDetailsResponse::has_os,
                    CMsgClientGetClientDetailsResponse::get_os,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "machine_name",
                    CMsgClientGetClientDetailsResponse::has_machine_name,
                    CMsgClientGetClientDetailsResponse::get_machine_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip_public",
                    CMsgClientGetClientDetailsResponse::has_ip_public,
                    CMsgClientGetClientDetailsResponse::get_ip_public,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "ip_private",
                    CMsgClientGetClientDetailsResponse::has_ip_private,
                    CMsgClientGetClientDetailsResponse::get_ip_private,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes_available",
                    CMsgClientGetClientDetailsResponse::has_bytes_available,
                    CMsgClientGetClientDetailsResponse::get_bytes_available,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "games_running",
                    CMsgClientGetClientDetailsResponse::get_games_running,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientDetailsResponse>(
                    "CMsgClientGetClientDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetailsResponse {
    fn clear(&mut self) {
        self.clear_package_version();
        self.clear_protocol_version();
        self.clear_os();
        self.clear_machine_name();
        self.clear_ip_public();
        self.clear_ip_private();
        self.clear_bytes_available();
        self.clear_games_running();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientDetailsResponse {
    fn eq(&self, other: &CMsgClientGetClientDetailsResponse) -> bool {
        self.package_version == other.package_version &&
        self.protocol_version == other.protocol_version &&
        self.os == other.os &&
        self.machine_name == other.machine_name &&
        self.ip_public == other.ip_public &&
        self.ip_private == other.ip_private &&
        self.bytes_available == other.bytes_available &&
        self.games_running == other.games_running &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientDetailsResponse_Game {
    // message fields
    appid: ::std::option::Option<u32>,
    extra_info: ::protobuf::SingularField<::std::string::String>,
    time_running_sec: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientDetailsResponse_Game {}

impl CMsgClientGetClientDetailsResponse_Game {
    pub fn new() -> CMsgClientGetClientDetailsResponse_Game {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientDetailsResponse_Game {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientDetailsResponse_Game> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientDetailsResponse_Game,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientDetailsResponse_Game {
                    appid: ::std::option::Option::None,
                    extra_info: ::protobuf::SingularField::none(),
                    time_running_sec: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional string extra_info = 2;

    pub fn clear_extra_info(&mut self) {
        self.extra_info.clear();
    }

    pub fn has_extra_info(&self) -> bool {
        self.extra_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_info(&mut self, v: ::std::string::String) {
        self.extra_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_info<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.extra_info.is_none() {
            self.extra_info.set_default();
        };
        self.extra_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_info(&mut self) -> ::std::string::String {
        self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_extra_info<'a>(&'a self) -> &'a str {
        match self.extra_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 time_running_sec = 3;

    pub fn clear_time_running_sec(&mut self) {
        self.time_running_sec = ::std::option::Option::None;
    }

    pub fn has_time_running_sec(&self) -> bool {
        self.time_running_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_running_sec(&mut self, v: u32) {
        self.time_running_sec = ::std::option::Option::Some(v);
    }

    pub fn get_time_running_sec<'a>(&self) -> u32 {
        self.time_running_sec.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGetClientDetailsResponse_Game {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.extra_info));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.time_running_sec = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.extra_info.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.time_running_sec.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.extra_info.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.time_running_sec {
            try!(os.write_uint32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientDetailsResponse_Game>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientDetailsResponse_Game {
    fn new() -> CMsgClientGetClientDetailsResponse_Game {
        CMsgClientGetClientDetailsResponse_Game::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientDetailsResponse_Game>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientGetClientDetailsResponse_Game::has_appid,
                    CMsgClientGetClientDetailsResponse_Game::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "extra_info",
                    CMsgClientGetClientDetailsResponse_Game::has_extra_info,
                    CMsgClientGetClientDetailsResponse_Game::get_extra_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "time_running_sec",
                    CMsgClientGetClientDetailsResponse_Game::has_time_running_sec,
                    CMsgClientGetClientDetailsResponse_Game::get_time_running_sec,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientDetailsResponse_Game>(
                    "CMsgClientGetClientDetailsResponse_Game",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientDetailsResponse_Game {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_extra_info();
        self.clear_time_running_sec();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientDetailsResponse_Game {
    fn eq(&self, other: &CMsgClientGetClientDetailsResponse_Game) -> bool {
        self.appid == other.appid &&
        self.extra_info == other.extra_info &&
        self.time_running_sec == other.time_running_sec &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientDetailsResponse_Game {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientAppList {
    // message fields
    media: ::std::option::Option<bool>,
    tools: ::std::option::Option<bool>,
    games: ::std::option::Option<bool>,
    only_installed: ::std::option::Option<bool>,
    only_changing: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientAppList {}

impl CMsgClientGetClientAppList {
    pub fn new() -> CMsgClientGetClientAppList {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientAppList {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientAppList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientAppList,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientAppList {
                    media: ::std::option::Option::None,
                    tools: ::std::option::Option::None,
                    games: ::std::option::Option::None,
                    only_installed: ::std::option::Option::None,
                    only_changing: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool media = 1;

    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    pub fn get_media<'a>(&self) -> bool {
        self.media.unwrap_or(false)
    }

    // optional bool tools = 2;

    pub fn clear_tools(&mut self) {
        self.tools = ::std::option::Option::None;
    }

    pub fn has_tools(&self) -> bool {
        self.tools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tools(&mut self, v: bool) {
        self.tools = ::std::option::Option::Some(v);
    }

    pub fn get_tools<'a>(&self) -> bool {
        self.tools.unwrap_or(false)
    }

    // optional bool games = 3;

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: bool) {
        self.games = ::std::option::Option::Some(v);
    }

    pub fn get_games<'a>(&self) -> bool {
        self.games.unwrap_or(false)
    }

    // optional bool only_installed = 4;

    pub fn clear_only_installed(&mut self) {
        self.only_installed = ::std::option::Option::None;
    }

    pub fn has_only_installed(&self) -> bool {
        self.only_installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_installed(&mut self, v: bool) {
        self.only_installed = ::std::option::Option::Some(v);
    }

    pub fn get_only_installed<'a>(&self) -> bool {
        self.only_installed.unwrap_or(false)
    }

    // optional bool only_changing = 5;

    pub fn clear_only_changing(&mut self) {
        self.only_changing = ::std::option::Option::None;
    }

    pub fn has_only_changing(&self) -> bool {
        self.only_changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_changing(&mut self, v: bool) {
        self.only_changing = ::std::option::Option::Some(v);
    }

    pub fn get_only_changing<'a>(&self) -> bool {
        self.only_changing.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.media = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.tools = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.games = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.only_installed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.only_changing = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.media.is_some() {
            my_size += 2;
        };
        if self.tools.is_some() {
            my_size += 2;
        };
        if self.games.is_some() {
            my_size += 2;
        };
        if self.only_installed.is_some() {
            my_size += 2;
        };
        if self.only_changing.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.media {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.tools {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.games {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.only_installed {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.only_changing {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientAppList>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientAppList {
    fn new() -> CMsgClientGetClientAppList {
        CMsgClientGetClientAppList::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientAppList>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "media",
                    CMsgClientGetClientAppList::has_media,
                    CMsgClientGetClientAppList::get_media,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "tools",
                    CMsgClientGetClientAppList::has_tools,
                    CMsgClientGetClientAppList::get_tools,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "games",
                    CMsgClientGetClientAppList::has_games,
                    CMsgClientGetClientAppList::get_games,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "only_installed",
                    CMsgClientGetClientAppList::has_only_installed,
                    CMsgClientGetClientAppList::get_only_installed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "only_changing",
                    CMsgClientGetClientAppList::has_only_changing,
                    CMsgClientGetClientAppList::get_only_changing,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientAppList>(
                    "CMsgClientGetClientAppList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppList {
    fn clear(&mut self) {
        self.clear_media();
        self.clear_tools();
        self.clear_games();
        self.clear_only_installed();
        self.clear_only_changing();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientAppList {
    fn eq(&self, other: &CMsgClientGetClientAppList) -> bool {
        self.media == other.media &&
        self.tools == other.tools &&
        self.games == other.games &&
        self.only_installed == other.only_installed &&
        self.only_changing == other.only_changing &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientAppListResponse {
    // message fields
    apps: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App>,
    bytes_available: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientAppListResponse {}

impl CMsgClientGetClientAppListResponse {
    pub fn new() -> CMsgClientGetClientAppListResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientAppListResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientAppListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientAppListResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientAppListResponse {
                    apps: ::protobuf::RepeatedField::new(),
                    bytes_available: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientGetClientAppListResponse.App apps = 1;

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    pub fn get_apps<'a>(&'a self) -> &'a [CMsgClientGetClientAppListResponse_App] {
        &self.apps
    }

    // optional uint64 bytes_available = 2;

    pub fn clear_bytes_available(&mut self) {
        self.bytes_available = ::std::option::Option::None;
    }

    pub fn has_bytes_available(&self) -> bool {
        self.bytes_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_available(&mut self, v: u64) {
        self.bytes_available = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_available<'a>(&self) -> u64 {
        self.bytes_available.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes_available = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.apps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.bytes_available.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.apps.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.bytes_available {
            try!(os.write_uint64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientAppListResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientAppListResponse {
    fn new() -> CMsgClientGetClientAppListResponse {
        CMsgClientGetClientAppListResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientAppListResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "apps",
                    CMsgClientGetClientAppListResponse::get_apps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes_available",
                    CMsgClientGetClientAppListResponse::has_bytes_available,
                    CMsgClientGetClientAppListResponse::get_bytes_available,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientAppListResponse>(
                    "CMsgClientGetClientAppListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse {
    fn clear(&mut self) {
        self.clear_apps();
        self.clear_bytes_available();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientAppListResponse {
    fn eq(&self, other: &CMsgClientGetClientAppListResponse) -> bool {
        self.apps == other.apps &&
        self.bytes_available == other.bytes_available &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientAppListResponse_App {
    // message fields
    appid: ::std::option::Option<u32>,
    category: ::protobuf::SingularField<::std::string::String>,
    app_type: ::protobuf::SingularField<::std::string::String>,
    favorite: ::std::option::Option<bool>,
    installed: ::std::option::Option<bool>,
    auto_update: ::std::option::Option<bool>,
    bytes_downloaded: ::std::option::Option<u64>,
    bytes_needed: ::std::option::Option<u64>,
    bytes_download_rate: ::std::option::Option<u32>,
    download_paused: ::std::option::Option<bool>,
    num_downloading: ::std::option::Option<u32>,
    num_paused: ::std::option::Option<u32>,
    changing: ::std::option::Option<bool>,
    available_on_platform: ::std::option::Option<bool>,
    dlcs: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientAppListResponse_App {}

impl CMsgClientGetClientAppListResponse_App {
    pub fn new() -> CMsgClientGetClientAppListResponse_App {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientAppListResponse_App {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientAppListResponse_App> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientAppListResponse_App,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientAppListResponse_App {
                    appid: ::std::option::Option::None,
                    category: ::protobuf::SingularField::none(),
                    app_type: ::protobuf::SingularField::none(),
                    favorite: ::std::option::Option::None,
                    installed: ::std::option::Option::None,
                    auto_update: ::std::option::Option::None,
                    bytes_downloaded: ::std::option::Option::None,
                    bytes_needed: ::std::option::Option::None,
                    bytes_download_rate: ::std::option::Option::None,
                    download_paused: ::std::option::Option::None,
                    num_downloading: ::std::option::Option::None,
                    num_paused: ::std::option::Option::None,
                    changing: ::std::option::Option::None,
                    available_on_platform: ::std::option::Option::None,
                    dlcs: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional string category = 2;

    pub fn clear_category(&mut self) {
        self.category.clear();
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.category.is_none() {
            self.category.set_default();
        };
        self.category.as_mut().unwrap()
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        self.category.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_category<'a>(&'a self) -> &'a str {
        match self.category.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string app_type = 10;

    pub fn clear_app_type(&mut self) {
        self.app_type.clear();
    }

    pub fn has_app_type(&self) -> bool {
        self.app_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_type(&mut self, v: ::std::string::String) {
        self.app_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_app_type<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.app_type.is_none() {
            self.app_type.set_default();
        };
        self.app_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_app_type(&mut self) -> ::std::string::String {
        self.app_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_app_type<'a>(&'a self) -> &'a str {
        match self.app_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool favorite = 3;

    pub fn clear_favorite(&mut self) {
        self.favorite = ::std::option::Option::None;
    }

    pub fn has_favorite(&self) -> bool {
        self.favorite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite(&mut self, v: bool) {
        self.favorite = ::std::option::Option::Some(v);
    }

    pub fn get_favorite<'a>(&self) -> bool {
        self.favorite.unwrap_or(false)
    }

    // optional bool installed = 4;

    pub fn clear_installed(&mut self) {
        self.installed = ::std::option::Option::None;
    }

    pub fn has_installed(&self) -> bool {
        self.installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_installed(&mut self, v: bool) {
        self.installed = ::std::option::Option::Some(v);
    }

    pub fn get_installed<'a>(&self) -> bool {
        self.installed.unwrap_or(false)
    }

    // optional bool auto_update = 5;

    pub fn clear_auto_update(&mut self) {
        self.auto_update = ::std::option::Option::None;
    }

    pub fn has_auto_update(&self) -> bool {
        self.auto_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_update(&mut self, v: bool) {
        self.auto_update = ::std::option::Option::Some(v);
    }

    pub fn get_auto_update<'a>(&self) -> bool {
        self.auto_update.unwrap_or(false)
    }

    // optional uint64 bytes_downloaded = 6;

    pub fn clear_bytes_downloaded(&mut self) {
        self.bytes_downloaded = ::std::option::Option::None;
    }

    pub fn has_bytes_downloaded(&self) -> bool {
        self.bytes_downloaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_downloaded(&mut self, v: u64) {
        self.bytes_downloaded = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_downloaded<'a>(&self) -> u64 {
        self.bytes_downloaded.unwrap_or(0)
    }

    // optional uint64 bytes_needed = 7;

    pub fn clear_bytes_needed(&mut self) {
        self.bytes_needed = ::std::option::Option::None;
    }

    pub fn has_bytes_needed(&self) -> bool {
        self.bytes_needed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_needed(&mut self, v: u64) {
        self.bytes_needed = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_needed<'a>(&self) -> u64 {
        self.bytes_needed.unwrap_or(0)
    }

    // optional uint32 bytes_download_rate = 8;

    pub fn clear_bytes_download_rate(&mut self) {
        self.bytes_download_rate = ::std::option::Option::None;
    }

    pub fn has_bytes_download_rate(&self) -> bool {
        self.bytes_download_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_download_rate(&mut self, v: u32) {
        self.bytes_download_rate = ::std::option::Option::Some(v);
    }

    pub fn get_bytes_download_rate<'a>(&self) -> u32 {
        self.bytes_download_rate.unwrap_or(0)
    }

    // optional bool download_paused = 11;

    pub fn clear_download_paused(&mut self) {
        self.download_paused = ::std::option::Option::None;
    }

    pub fn has_download_paused(&self) -> bool {
        self.download_paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download_paused(&mut self, v: bool) {
        self.download_paused = ::std::option::Option::Some(v);
    }

    pub fn get_download_paused<'a>(&self) -> bool {
        self.download_paused.unwrap_or(false)
    }

    // optional uint32 num_downloading = 12;

    pub fn clear_num_downloading(&mut self) {
        self.num_downloading = ::std::option::Option::None;
    }

    pub fn has_num_downloading(&self) -> bool {
        self.num_downloading.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_downloading(&mut self, v: u32) {
        self.num_downloading = ::std::option::Option::Some(v);
    }

    pub fn get_num_downloading<'a>(&self) -> u32 {
        self.num_downloading.unwrap_or(0)
    }

    // optional uint32 num_paused = 13;

    pub fn clear_num_paused(&mut self) {
        self.num_paused = ::std::option::Option::None;
    }

    pub fn has_num_paused(&self) -> bool {
        self.num_paused.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_paused(&mut self, v: u32) {
        self.num_paused = ::std::option::Option::Some(v);
    }

    pub fn get_num_paused<'a>(&self) -> u32 {
        self.num_paused.unwrap_or(0)
    }

    // optional bool changing = 14;

    pub fn clear_changing(&mut self) {
        self.changing = ::std::option::Option::None;
    }

    pub fn has_changing(&self) -> bool {
        self.changing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changing(&mut self, v: bool) {
        self.changing = ::std::option::Option::Some(v);
    }

    pub fn get_changing<'a>(&self) -> bool {
        self.changing.unwrap_or(false)
    }

    // optional bool available_on_platform = 15;

    pub fn clear_available_on_platform(&mut self) {
        self.available_on_platform = ::std::option::Option::None;
    }

    pub fn has_available_on_platform(&self) -> bool {
        self.available_on_platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_on_platform(&mut self, v: bool) {
        self.available_on_platform = ::std::option::Option::Some(v);
    }

    pub fn get_available_on_platform<'a>(&self) -> bool {
        self.available_on_platform.unwrap_or(false)
    }

    // repeated .CMsgClientGetClientAppListResponse.App.DLC dlcs = 9;

    pub fn clear_dlcs(&mut self) {
        self.dlcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_dlcs(&mut self, v: ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC>) {
        self.dlcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dlcs<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC> {
        &mut self.dlcs
    }

    // Take field
    pub fn take_dlcs(&mut self) -> ::protobuf::RepeatedField<CMsgClientGetClientAppListResponse_App_DLC> {
        ::std::mem::replace(&mut self.dlcs, ::protobuf::RepeatedField::new())
    }

    pub fn get_dlcs<'a>(&'a self) -> &'a [CMsgClientGetClientAppListResponse_App_DLC] {
        &self.dlcs
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse_App {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.category));
                },
                10 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.app_type));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.favorite = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.installed = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.auto_update = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes_downloaded = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.bytes_needed = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.bytes_download_rate = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.download_paused = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.num_downloading = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.num_paused = ::std::option::Option::Some(tmp);
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.changing = ::std::option::Option::Some(tmp);
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.available_on_platform = ::std::option::Option::Some(tmp);
                },
                9 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dlcs));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.category.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.app_type.iter() {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if self.favorite.is_some() {
            my_size += 2;
        };
        if self.installed.is_some() {
            my_size += 2;
        };
        if self.auto_update.is_some() {
            my_size += 2;
        };
        for value in self.bytes_downloaded.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_needed.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.bytes_download_rate.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.download_paused.is_some() {
            my_size += 2;
        };
        for value in self.num_downloading.iter() {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_paused.iter() {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.changing.is_some() {
            my_size += 2;
        };
        if self.available_on_platform.is_some() {
            my_size += 2;
        };
        for value in self.dlcs.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.category.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.app_type.as_ref() {
            try!(os.write_string(10, &v));
        };
        if let Some(v) = self.favorite {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.installed {
            try!(os.write_bool(4, v));
        };
        if let Some(v) = self.auto_update {
            try!(os.write_bool(5, v));
        };
        if let Some(v) = self.bytes_downloaded {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.bytes_needed {
            try!(os.write_uint64(7, v));
        };
        if let Some(v) = self.bytes_download_rate {
            try!(os.write_uint32(8, v));
        };
        if let Some(v) = self.download_paused {
            try!(os.write_bool(11, v));
        };
        if let Some(v) = self.num_downloading {
            try!(os.write_uint32(12, v));
        };
        if let Some(v) = self.num_paused {
            try!(os.write_uint32(13, v));
        };
        if let Some(v) = self.changing {
            try!(os.write_bool(14, v));
        };
        if let Some(v) = self.available_on_platform {
            try!(os.write_bool(15, v));
        };
        for v in self.dlcs.iter() {
            try!(os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientAppListResponse_App>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientAppListResponse_App {
    fn new() -> CMsgClientGetClientAppListResponse_App {
        CMsgClientGetClientAppListResponse_App::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientAppListResponse_App>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientGetClientAppListResponse_App::has_appid,
                    CMsgClientGetClientAppListResponse_App::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "category",
                    CMsgClientGetClientAppListResponse_App::has_category,
                    CMsgClientGetClientAppListResponse_App::get_category,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "app_type",
                    CMsgClientGetClientAppListResponse_App::has_app_type,
                    CMsgClientGetClientAppListResponse_App::get_app_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "favorite",
                    CMsgClientGetClientAppListResponse_App::has_favorite,
                    CMsgClientGetClientAppListResponse_App::get_favorite,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "installed",
                    CMsgClientGetClientAppListResponse_App::has_installed,
                    CMsgClientGetClientAppListResponse_App::get_installed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "auto_update",
                    CMsgClientGetClientAppListResponse_App::has_auto_update,
                    CMsgClientGetClientAppListResponse_App::get_auto_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes_downloaded",
                    CMsgClientGetClientAppListResponse_App::has_bytes_downloaded,
                    CMsgClientGetClientAppListResponse_App::get_bytes_downloaded,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "bytes_needed",
                    CMsgClientGetClientAppListResponse_App::has_bytes_needed,
                    CMsgClientGetClientAppListResponse_App::get_bytes_needed,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "bytes_download_rate",
                    CMsgClientGetClientAppListResponse_App::has_bytes_download_rate,
                    CMsgClientGetClientAppListResponse_App::get_bytes_download_rate,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "download_paused",
                    CMsgClientGetClientAppListResponse_App::has_download_paused,
                    CMsgClientGetClientAppListResponse_App::get_download_paused,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "num_downloading",
                    CMsgClientGetClientAppListResponse_App::has_num_downloading,
                    CMsgClientGetClientAppListResponse_App::get_num_downloading,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "num_paused",
                    CMsgClientGetClientAppListResponse_App::has_num_paused,
                    CMsgClientGetClientAppListResponse_App::get_num_paused,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "changing",
                    CMsgClientGetClientAppListResponse_App::has_changing,
                    CMsgClientGetClientAppListResponse_App::get_changing,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "available_on_platform",
                    CMsgClientGetClientAppListResponse_App::has_available_on_platform,
                    CMsgClientGetClientAppListResponse_App::get_available_on_platform,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "dlcs",
                    CMsgClientGetClientAppListResponse_App::get_dlcs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientAppListResponse_App>(
                    "CMsgClientGetClientAppListResponse_App",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse_App {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_category();
        self.clear_app_type();
        self.clear_favorite();
        self.clear_installed();
        self.clear_auto_update();
        self.clear_bytes_downloaded();
        self.clear_bytes_needed();
        self.clear_bytes_download_rate();
        self.clear_download_paused();
        self.clear_num_downloading();
        self.clear_num_paused();
        self.clear_changing();
        self.clear_available_on_platform();
        self.clear_dlcs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientAppListResponse_App {
    fn eq(&self, other: &CMsgClientGetClientAppListResponse_App) -> bool {
        self.appid == other.appid &&
        self.category == other.category &&
        self.app_type == other.app_type &&
        self.favorite == other.favorite &&
        self.installed == other.installed &&
        self.auto_update == other.auto_update &&
        self.bytes_downloaded == other.bytes_downloaded &&
        self.bytes_needed == other.bytes_needed &&
        self.bytes_download_rate == other.bytes_download_rate &&
        self.download_paused == other.download_paused &&
        self.num_downloading == other.num_downloading &&
        self.num_paused == other.num_paused &&
        self.changing == other.changing &&
        self.available_on_platform == other.available_on_platform &&
        self.dlcs == other.dlcs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientGetClientAppListResponse_App_DLC {
    // message fields
    appid: ::std::option::Option<u32>,
    installed: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientGetClientAppListResponse_App_DLC {}

impl CMsgClientGetClientAppListResponse_App_DLC {
    pub fn new() -> CMsgClientGetClientAppListResponse_App_DLC {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientGetClientAppListResponse_App_DLC {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientGetClientAppListResponse_App_DLC> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientGetClientAppListResponse_App_DLC,
        };
        unsafe {
            instance.get(|| {
                CMsgClientGetClientAppListResponse_App_DLC {
                    appid: ::std::option::Option::None,
                    installed: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional bool installed = 2;

    pub fn clear_installed(&mut self) {
        self.installed = ::std::option::Option::None;
    }

    pub fn has_installed(&self) -> bool {
        self.installed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_installed(&mut self, v: bool) {
        self.installed = ::std::option::Option::Some(v);
    }

    pub fn get_installed<'a>(&self) -> bool {
        self.installed.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientGetClientAppListResponse_App_DLC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.installed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.installed.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.installed {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientGetClientAppListResponse_App_DLC>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientGetClientAppListResponse_App_DLC {
    fn new() -> CMsgClientGetClientAppListResponse_App_DLC {
        CMsgClientGetClientAppListResponse_App_DLC::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientGetClientAppListResponse_App_DLC>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientGetClientAppListResponse_App_DLC::has_appid,
                    CMsgClientGetClientAppListResponse_App_DLC::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "installed",
                    CMsgClientGetClientAppListResponse_App_DLC::has_installed,
                    CMsgClientGetClientAppListResponse_App_DLC::get_installed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientGetClientAppListResponse_App_DLC>(
                    "CMsgClientGetClientAppListResponse_App_DLC",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientGetClientAppListResponse_App_DLC {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_installed();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientGetClientAppListResponse_App_DLC {
    fn eq(&self, other: &CMsgClientGetClientAppListResponse_App_DLC) -> bool {
        self.appid == other.appid &&
        self.installed == other.installed &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientGetClientAppListResponse_App_DLC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientInstallClientApp {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientInstallClientApp {}

impl CMsgClientInstallClientApp {
    pub fn new() -> CMsgClientInstallClientApp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientInstallClientApp {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientInstallClientApp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientInstallClientApp,
        };
        unsafe {
            instance.get(|| {
                CMsgClientInstallClientApp {
                    appid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientInstallClientApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientInstallClientApp>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientInstallClientApp {
    fn new() -> CMsgClientInstallClientApp {
        CMsgClientInstallClientApp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientInstallClientApp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientInstallClientApp::has_appid,
                    CMsgClientInstallClientApp::get_appid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientInstallClientApp>(
                    "CMsgClientInstallClientApp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientInstallClientApp {
    fn clear(&mut self) {
        self.clear_appid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientInstallClientApp {
    fn eq(&self, other: &CMsgClientInstallClientApp) -> bool {
        self.appid == other.appid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientInstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientInstallClientAppResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientInstallClientAppResponse {}

impl CMsgClientInstallClientAppResponse {
    pub fn new() -> CMsgClientInstallClientAppResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientInstallClientAppResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientInstallClientAppResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientInstallClientAppResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientInstallClientAppResponse {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> u32 {
        self.result.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientInstallClientAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.result.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientInstallClientAppResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientInstallClientAppResponse {
    fn new() -> CMsgClientInstallClientAppResponse {
        CMsgClientInstallClientAppResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientInstallClientAppResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "result",
                    CMsgClientInstallClientAppResponse::has_result,
                    CMsgClientInstallClientAppResponse::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientInstallClientAppResponse>(
                    "CMsgClientInstallClientAppResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientInstallClientAppResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientInstallClientAppResponse {
    fn eq(&self, other: &CMsgClientInstallClientAppResponse) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientInstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUninstallClientApp {
    // message fields
    appid: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUninstallClientApp {}

impl CMsgClientUninstallClientApp {
    pub fn new() -> CMsgClientUninstallClientApp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUninstallClientApp {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUninstallClientApp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUninstallClientApp,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUninstallClientApp {
                    appid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUninstallClientApp>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUninstallClientApp {
    fn new() -> CMsgClientUninstallClientApp {
        CMsgClientUninstallClientApp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUninstallClientApp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientUninstallClientApp::has_appid,
                    CMsgClientUninstallClientApp::get_appid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUninstallClientApp>(
                    "CMsgClientUninstallClientApp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUninstallClientApp {
    fn clear(&mut self) {
        self.clear_appid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUninstallClientApp {
    fn eq(&self, other: &CMsgClientUninstallClientApp) -> bool {
        self.appid == other.appid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUninstallClientApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUninstallClientAppResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUninstallClientAppResponse {}

impl CMsgClientUninstallClientAppResponse {
    pub fn new() -> CMsgClientUninstallClientAppResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUninstallClientAppResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUninstallClientAppResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUninstallClientAppResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUninstallClientAppResponse {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> u32 {
        self.result.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientUninstallClientAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.result.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUninstallClientAppResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUninstallClientAppResponse {
    fn new() -> CMsgClientUninstallClientAppResponse {
        CMsgClientUninstallClientAppResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUninstallClientAppResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "result",
                    CMsgClientUninstallClientAppResponse::has_result,
                    CMsgClientUninstallClientAppResponse::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUninstallClientAppResponse>(
                    "CMsgClientUninstallClientAppResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUninstallClientAppResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUninstallClientAppResponse {
    fn eq(&self, other: &CMsgClientUninstallClientAppResponse) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUninstallClientAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientSetClientAppUpdateState {
    // message fields
    appid: ::std::option::Option<u32>,
    update: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientSetClientAppUpdateState {}

impl CMsgClientSetClientAppUpdateState {
    pub fn new() -> CMsgClientSetClientAppUpdateState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientSetClientAppUpdateState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientSetClientAppUpdateState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientSetClientAppUpdateState,
        };
        unsafe {
            instance.get(|| {
                CMsgClientSetClientAppUpdateState {
                    appid: ::std::option::Option::None,
                    update: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional bool update = 2;

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: bool) {
        self.update = ::std::option::Option::Some(v);
    }

    pub fn get_update<'a>(&self) -> bool {
        self.update.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.update = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.update.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.update {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientSetClientAppUpdateState>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientSetClientAppUpdateState {
    fn new() -> CMsgClientSetClientAppUpdateState {
        CMsgClientSetClientAppUpdateState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientSetClientAppUpdateState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientSetClientAppUpdateState::has_appid,
                    CMsgClientSetClientAppUpdateState::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "update",
                    CMsgClientSetClientAppUpdateState::has_update,
                    CMsgClientSetClientAppUpdateState::get_update,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetClientAppUpdateState>(
                    "CMsgClientSetClientAppUpdateState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientSetClientAppUpdateState {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_update();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientSetClientAppUpdateState {
    fn eq(&self, other: &CMsgClientSetClientAppUpdateState) -> bool {
        self.appid == other.appid &&
        self.update == other.update &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientSetClientAppUpdateState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientSetClientAppUpdateStateResponse {
    // message fields
    result: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientSetClientAppUpdateStateResponse {}

impl CMsgClientSetClientAppUpdateStateResponse {
    pub fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientSetClientAppUpdateStateResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientSetClientAppUpdateStateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientSetClientAppUpdateStateResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientSetClientAppUpdateStateResponse {
                    result: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 result = 1;

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    pub fn get_result<'a>(&self) -> u32 {
        self.result.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientSetClientAppUpdateStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.result = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.result.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.result {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientSetClientAppUpdateStateResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientSetClientAppUpdateStateResponse {
    fn new() -> CMsgClientSetClientAppUpdateStateResponse {
        CMsgClientSetClientAppUpdateStateResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientSetClientAppUpdateStateResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "result",
                    CMsgClientSetClientAppUpdateStateResponse::has_result,
                    CMsgClientSetClientAppUpdateStateResponse::get_result,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientSetClientAppUpdateStateResponse>(
                    "CMsgClientSetClientAppUpdateStateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientSetClientAppUpdateStateResponse {
    fn clear(&mut self) {
        self.clear_result();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientSetClientAppUpdateStateResponse {
    fn eq(&self, other: &CMsgClientSetClientAppUpdateStateResponse) -> bool {
        self.result == other.result &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientSetClientAppUpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadFileRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_size: ::std::option::Option<u32>,
    raw_file_size: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    platforms_to_sync_deprecated: ::std::option::Option<u32>,
    platforms_to_sync: ::std::option::Option<u32>,
    cell_id: ::std::option::Option<u32>,
    can_encrypt: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadFileRequest {}

impl CMsgClientUFSUploadFileRequest {
    pub fn new() -> CMsgClientUFSUploadFileRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadFileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadFileRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadFileRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadFileRequest {
                    app_id: ::std::option::Option::None,
                    file_size: ::std::option::Option::None,
                    raw_file_size: ::std::option::Option::None,
                    sha_file: ::protobuf::SingularField::none(),
                    time_stamp: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    platforms_to_sync_deprecated: ::std::option::Option::None,
                    platforms_to_sync: ::std::option::Option::None,
                    cell_id: ::std::option::Option::None,
                    can_encrypt: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional uint32 file_size = 2;

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    pub fn get_file_size<'a>(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    // optional uint32 raw_file_size = 3;

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    pub fn get_raw_file_size<'a>(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    // optional bytes sha_file = 4;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint64 time_stamp = 5;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_time_stamp<'a>(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    // optional string file_name = 6;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 platforms_to_sync_deprecated = 7;

    pub fn clear_platforms_to_sync_deprecated(&mut self) {
        self.platforms_to_sync_deprecated = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync_deprecated(&self) -> bool {
        self.platforms_to_sync_deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync_deprecated(&mut self, v: u32) {
        self.platforms_to_sync_deprecated = ::std::option::Option::Some(v);
    }

    pub fn get_platforms_to_sync_deprecated<'a>(&self) -> u32 {
        self.platforms_to_sync_deprecated.unwrap_or(0)
    }

    // optional uint32 platforms_to_sync = 8;

    pub fn clear_platforms_to_sync(&mut self) {
        self.platforms_to_sync = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync(&self) -> bool {
        self.platforms_to_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync(&mut self, v: u32) {
        self.platforms_to_sync = ::std::option::Option::Some(v);
    }

    pub fn get_platforms_to_sync<'a>(&self) -> u32 {
        self.platforms_to_sync.unwrap_or(4294967295u32)
    }

    // optional uint32 cell_id = 9;

    pub fn clear_cell_id(&mut self) {
        self.cell_id = ::std::option::Option::None;
    }

    pub fn has_cell_id(&self) -> bool {
        self.cell_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cell_id(&mut self, v: u32) {
        self.cell_id = ::std::option::Option::Some(v);
    }

    pub fn get_cell_id<'a>(&self) -> u32 {
        self.cell_id.unwrap_or(0)
    }

    // optional bool can_encrypt = 10;

    pub fn clear_can_encrypt(&mut self) {
        self.can_encrypt = ::std::option::Option::None;
    }

    pub fn has_can_encrypt(&self) -> bool {
        self.can_encrypt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_encrypt(&mut self, v: bool) {
        self.can_encrypt = ::std::option::Option::Some(v);
    }

    pub fn get_can_encrypt<'a>(&self) -> bool {
        self.can_encrypt.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.platforms_to_sync_deprecated = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.platforms_to_sync = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cell_id = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.can_encrypt = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_size.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.raw_file_size.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.time_stamp.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in self.platforms_to_sync_deprecated.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.platforms_to_sync.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.cell_id.iter() {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.can_encrypt.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.file_size {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.raw_file_size {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.time_stamp {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(6, &v));
        };
        if let Some(v) = self.platforms_to_sync_deprecated {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.platforms_to_sync {
            try!(os.write_uint32(8, v));
        };
        if let Some(v) = self.cell_id {
            try!(os.write_uint32(9, v));
        };
        if let Some(v) = self.can_encrypt {
            try!(os.write_bool(10, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadFileRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadFileRequest {
    fn new() -> CMsgClientUFSUploadFileRequest {
        CMsgClientUFSUploadFileRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadFileRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSUploadFileRequest::has_app_id,
                    CMsgClientUFSUploadFileRequest::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "file_size",
                    CMsgClientUFSUploadFileRequest::has_file_size,
                    CMsgClientUFSUploadFileRequest::get_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "raw_file_size",
                    CMsgClientUFSUploadFileRequest::has_raw_file_size,
                    CMsgClientUFSUploadFileRequest::get_raw_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSUploadFileRequest::has_sha_file,
                    CMsgClientUFSUploadFileRequest::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "time_stamp",
                    CMsgClientUFSUploadFileRequest::has_time_stamp,
                    CMsgClientUFSUploadFileRequest::get_time_stamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSUploadFileRequest::has_file_name,
                    CMsgClientUFSUploadFileRequest::get_file_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "platforms_to_sync_deprecated",
                    CMsgClientUFSUploadFileRequest::has_platforms_to_sync_deprecated,
                    CMsgClientUFSUploadFileRequest::get_platforms_to_sync_deprecated,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "platforms_to_sync",
                    CMsgClientUFSUploadFileRequest::has_platforms_to_sync,
                    CMsgClientUFSUploadFileRequest::get_platforms_to_sync,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cell_id",
                    CMsgClientUFSUploadFileRequest::has_cell_id,
                    CMsgClientUFSUploadFileRequest::get_cell_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "can_encrypt",
                    CMsgClientUFSUploadFileRequest::has_can_encrypt,
                    CMsgClientUFSUploadFileRequest::get_can_encrypt,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadFileRequest>(
                    "CMsgClientUFSUploadFileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileRequest {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_file_size();
        self.clear_raw_file_size();
        self.clear_sha_file();
        self.clear_time_stamp();
        self.clear_file_name();
        self.clear_platforms_to_sync_deprecated();
        self.clear_platforms_to_sync();
        self.clear_cell_id();
        self.clear_can_encrypt();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadFileRequest {
    fn eq(&self, other: &CMsgClientUFSUploadFileRequest) -> bool {
        self.app_id == other.app_id &&
        self.file_size == other.file_size &&
        self.raw_file_size == other.raw_file_size &&
        self.sha_file == other.sha_file &&
        self.time_stamp == other.time_stamp &&
        self.file_name == other.file_name &&
        self.platforms_to_sync_deprecated == other.platforms_to_sync_deprecated &&
        self.platforms_to_sync == other.platforms_to_sync &&
        self.cell_id == other.cell_id &&
        self.can_encrypt == other.can_encrypt &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_http: ::std::option::Option<bool>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    http_url: ::protobuf::SingularField<::std::string::String>,
    kv_headers: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_https: ::std::option::Option<bool>,
    encrypt_file: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadFileResponse {}

impl CMsgClientUFSUploadFileResponse {
    pub fn new() -> CMsgClientUFSUploadFileResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadFileResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadFileResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadFileResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadFileResponse {
                    eresult: ::std::option::Option::None,
                    sha_file: ::protobuf::SingularField::none(),
                    use_http: ::std::option::Option::None,
                    http_host: ::protobuf::SingularField::none(),
                    http_url: ::protobuf::SingularField::none(),
                    kv_headers: ::protobuf::SingularField::none(),
                    use_https: ::std::option::Option::None,
                    encrypt_file: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional bytes sha_file = 2;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool use_http = 3;

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    pub fn get_use_http<'a>(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    // optional string http_host = 4;

    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        };
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_http_host<'a>(&'a self) -> &'a str {
        match self.http_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string http_url = 5;

    pub fn clear_http_url(&mut self) {
        self.http_url.clear();
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url.set_default();
        };
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_http_url<'a>(&'a self) -> &'a str {
        match self.http_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes kv_headers = 6;

    pub fn clear_kv_headers(&mut self) {
        self.kv_headers.clear();
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers.set_default();
        };
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_kv_headers<'a>(&'a self) -> &'a [u8] {
        match self.kv_headers.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool use_https = 7;

    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    pub fn get_use_https<'a>(&self) -> bool {
        self.use_https.unwrap_or(false)
    }

    // optional bool encrypt_file = 8;

    pub fn clear_encrypt_file(&mut self) {
        self.encrypt_file = ::std::option::Option::None;
    }

    pub fn has_encrypt_file(&self) -> bool {
        self.encrypt_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypt_file(&mut self, v: bool) {
        self.encrypt_file = ::std::option::Option::Some(v);
    }

    pub fn get_encrypt_file<'a>(&self) -> bool {
        self.encrypt_file.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.use_http = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_url));
                },
                6 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.kv_headers));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.use_https = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.encrypt_file = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        if self.use_http.is_some() {
            my_size += 2;
        };
        for value in self.http_host.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in self.http_url.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in self.kv_headers.iter() {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if self.use_https.is_some() {
            my_size += 2;
        };
        if self.encrypt_file.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        if let Some(v) = self.use_http {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.http_host.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.http_url.as_ref() {
            try!(os.write_string(5, &v));
        };
        if let Some(v) = self.kv_headers.as_ref() {
            try!(os.write_bytes(6, &v));
        };
        if let Some(v) = self.use_https {
            try!(os.write_bool(7, v));
        };
        if let Some(v) = self.encrypt_file {
            try!(os.write_bool(8, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadFileResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadFileResponse {
    fn new() -> CMsgClientUFSUploadFileResponse {
        CMsgClientUFSUploadFileResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadFileResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSUploadFileResponse::has_eresult,
                    CMsgClientUFSUploadFileResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSUploadFileResponse::has_sha_file,
                    CMsgClientUFSUploadFileResponse::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "use_http",
                    CMsgClientUFSUploadFileResponse::has_use_http,
                    CMsgClientUFSUploadFileResponse::get_use_http,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "http_host",
                    CMsgClientUFSUploadFileResponse::has_http_host,
                    CMsgClientUFSUploadFileResponse::get_http_host,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "http_url",
                    CMsgClientUFSUploadFileResponse::has_http_url,
                    CMsgClientUFSUploadFileResponse::get_http_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "kv_headers",
                    CMsgClientUFSUploadFileResponse::has_kv_headers,
                    CMsgClientUFSUploadFileResponse::get_kv_headers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "use_https",
                    CMsgClientUFSUploadFileResponse::has_use_https,
                    CMsgClientUFSUploadFileResponse::get_use_https,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "encrypt_file",
                    CMsgClientUFSUploadFileResponse::has_encrypt_file,
                    CMsgClientUFSUploadFileResponse::get_encrypt_file,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadFileResponse>(
                    "CMsgClientUFSUploadFileResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_sha_file();
        self.clear_use_http();
        self.clear_http_host();
        self.clear_http_url();
        self.clear_kv_headers();
        self.clear_use_https();
        self.clear_encrypt_file();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadFileResponse {
    fn eq(&self, other: &CMsgClientUFSUploadFileResponse) -> bool {
        self.eresult == other.eresult &&
        self.sha_file == other.sha_file &&
        self.use_http == other.use_http &&
        self.http_host == other.http_host &&
        self.http_url == other.http_url &&
        self.kv_headers == other.kv_headers &&
        self.use_https == other.use_https &&
        self.encrypt_file == other.encrypt_file &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadCommit {
    // message fields
    files: ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadCommit {}

impl CMsgClientUFSUploadCommit {
    pub fn new() -> CMsgClientUFSUploadCommit {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadCommit {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadCommit> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadCommit,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadCommit {
                    files: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientUFSUploadCommit.File files = 1;

    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUFSUploadCommit_File> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }

    pub fn get_files<'a>(&'a self) -> &'a [CMsgClientUFSUploadCommit_File] {
        &self.files
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.files.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.files.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadCommit>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadCommit {
    fn new() -> CMsgClientUFSUploadCommit {
        CMsgClientUFSUploadCommit::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadCommit>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "files",
                    CMsgClientUFSUploadCommit::get_files,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadCommit>(
                    "CMsgClientUFSUploadCommit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommit {
    fn clear(&mut self) {
        self.clear_files();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadCommit {
    fn eq(&self, other: &CMsgClientUFSUploadCommit) -> bool {
        self.files == other.files &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadCommit_File {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    cub_file: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadCommit_File {}

impl CMsgClientUFSUploadCommit_File {
    pub fn new() -> CMsgClientUFSUploadCommit_File {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadCommit_File {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadCommit_File> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadCommit_File,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadCommit_File {
                    eresult: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    sha_file: ::protobuf::SingularField::none(),
                    cub_file: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional uint32 app_id = 2;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional bytes sha_file = 3;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 cub_file = 4;

    pub fn clear_cub_file(&mut self) {
        self.cub_file = ::std::option::Option::None;
    }

    pub fn has_cub_file(&self) -> bool {
        self.cub_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cub_file(&mut self, v: u32) {
        self.cub_file = ::std::option::Option::Some(v);
    }

    pub fn get_cub_file<'a>(&self) -> u32 {
        self.cub_file.unwrap_or(0)
    }

    // optional string file_name = 5;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommit_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.cub_file = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.cub_file.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.cub_file {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(5, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadCommit_File>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadCommit_File {
    fn new() -> CMsgClientUFSUploadCommit_File {
        CMsgClientUFSUploadCommit_File::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadCommit_File>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSUploadCommit_File::has_eresult,
                    CMsgClientUFSUploadCommit_File::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSUploadCommit_File::has_app_id,
                    CMsgClientUFSUploadCommit_File::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSUploadCommit_File::has_sha_file,
                    CMsgClientUFSUploadCommit_File::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "cub_file",
                    CMsgClientUFSUploadCommit_File::has_cub_file,
                    CMsgClientUFSUploadCommit_File::get_cub_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSUploadCommit_File::has_file_name,
                    CMsgClientUFSUploadCommit_File::get_file_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadCommit_File>(
                    "CMsgClientUFSUploadCommit_File",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommit_File {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_app_id();
        self.clear_sha_file();
        self.clear_cub_file();
        self.clear_file_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadCommit_File {
    fn eq(&self, other: &CMsgClientUFSUploadCommit_File) -> bool {
        self.eresult == other.eresult &&
        self.app_id == other.app_id &&
        self.sha_file == other.sha_file &&
        self.cub_file == other.cub_file &&
        self.file_name == other.file_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommit_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadCommitResponse {
    // message fields
    files: ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadCommitResponse {}

impl CMsgClientUFSUploadCommitResponse {
    pub fn new() -> CMsgClientUFSUploadCommitResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadCommitResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadCommitResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadCommitResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadCommitResponse {
                    files: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientUFSUploadCommitResponse.File files = 1;

    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUFSUploadCommitResponse_File> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }

    pub fn get_files<'a>(&'a self) -> &'a [CMsgClientUFSUploadCommitResponse_File] {
        &self.files
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.files.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.files.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadCommitResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadCommitResponse {
    fn new() -> CMsgClientUFSUploadCommitResponse {
        CMsgClientUFSUploadCommitResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadCommitResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "files",
                    CMsgClientUFSUploadCommitResponse::get_files,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadCommitResponse>(
                    "CMsgClientUFSUploadCommitResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommitResponse {
    fn clear(&mut self) {
        self.clear_files();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadCommitResponse {
    fn eq(&self, other: &CMsgClientUFSUploadCommitResponse) -> bool {
        self.files == other.files &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadCommitResponse_File {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadCommitResponse_File {}

impl CMsgClientUFSUploadCommitResponse_File {
    pub fn new() -> CMsgClientUFSUploadCommitResponse_File {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadCommitResponse_File {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadCommitResponse_File> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadCommitResponse_File,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadCommitResponse_File {
                    eresult: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    sha_file: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional uint32 app_id = 2;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional bytes sha_file = 3;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadCommitResponse_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadCommitResponse_File>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadCommitResponse_File {
    fn new() -> CMsgClientUFSUploadCommitResponse_File {
        CMsgClientUFSUploadCommitResponse_File::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadCommitResponse_File>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSUploadCommitResponse_File::has_eresult,
                    CMsgClientUFSUploadCommitResponse_File::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSUploadCommitResponse_File::has_app_id,
                    CMsgClientUFSUploadCommitResponse_File::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSUploadCommitResponse_File::has_sha_file,
                    CMsgClientUFSUploadCommitResponse_File::get_sha_file,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadCommitResponse_File>(
                    "CMsgClientUFSUploadCommitResponse_File",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadCommitResponse_File {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_app_id();
        self.clear_sha_file();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadCommitResponse_File {
    fn eq(&self, other: &CMsgClientUFSUploadCommitResponse_File) -> bool {
        self.eresult == other.eresult &&
        self.app_id == other.app_id &&
        self.sha_file == other.sha_file &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadCommitResponse_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSFileChunk {
    // message fields
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    file_start: ::std::option::Option<u32>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSFileChunk {}

impl CMsgClientUFSFileChunk {
    pub fn new() -> CMsgClientUFSFileChunk {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSFileChunk {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSFileChunk> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSFileChunk,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSFileChunk {
                    sha_file: ::protobuf::SingularField::none(),
                    file_start: ::std::option::Option::None,
                    data: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bytes sha_file = 1;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 file_start = 2;

    pub fn clear_file_start(&mut self) {
        self.file_start = ::std::option::Option::None;
    }

    pub fn has_file_start(&self) -> bool {
        self.file_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_start(&mut self, v: u32) {
        self.file_start = ::std::option::Option::Some(v);
    }

    pub fn get_file_start<'a>(&self) -> u32 {
        self.file_start.unwrap_or(0)
    }

    // optional bytes data = 3;

    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        };
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_data<'a>(&'a self) -> &'a [u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSFileChunk {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.file_start = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        for value in self.file_start.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.data.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(1, &v));
        };
        if let Some(v) = self.file_start {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.data.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSFileChunk>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSFileChunk {
    fn new() -> CMsgClientUFSFileChunk {
        CMsgClientUFSFileChunk::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSFileChunk>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSFileChunk::has_sha_file,
                    CMsgClientUFSFileChunk::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "file_start",
                    CMsgClientUFSFileChunk::has_file_start,
                    CMsgClientUFSFileChunk::get_file_start,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "data",
                    CMsgClientUFSFileChunk::has_data,
                    CMsgClientUFSFileChunk::get_data,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSFileChunk>(
                    "CMsgClientUFSFileChunk",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSFileChunk {
    fn clear(&mut self) {
        self.clear_sha_file();
        self.clear_file_start();
        self.clear_data();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSFileChunk {
    fn eq(&self, other: &CMsgClientUFSFileChunk) -> bool {
        self.sha_file == other.sha_file &&
        self.file_start == other.file_start &&
        self.data == other.data &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSFileChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSTransferHeartbeat {
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSTransferHeartbeat {}

impl CMsgClientUFSTransferHeartbeat {
    pub fn new() -> CMsgClientUFSTransferHeartbeat {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSTransferHeartbeat {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSTransferHeartbeat> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSTransferHeartbeat,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSTransferHeartbeat {
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSTransferHeartbeat {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSTransferHeartbeat>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSTransferHeartbeat {
    fn new() -> CMsgClientUFSTransferHeartbeat {
        CMsgClientUFSTransferHeartbeat::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSTransferHeartbeat>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSTransferHeartbeat>(
                    "CMsgClientUFSTransferHeartbeat",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSTransferHeartbeat {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSTransferHeartbeat {
    fn eq(&self, other: &CMsgClientUFSTransferHeartbeat) -> bool {
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSTransferHeartbeat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSUploadFileFinished {
    // message fields
    eresult: ::std::option::Option<i32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSUploadFileFinished {}

impl CMsgClientUFSUploadFileFinished {
    pub fn new() -> CMsgClientUFSUploadFileFinished {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSUploadFileFinished {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSUploadFileFinished> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSUploadFileFinished,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSUploadFileFinished {
                    eresult: ::std::option::Option::None,
                    sha_file: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional bytes sha_file = 2;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSUploadFileFinished {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSUploadFileFinished>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSUploadFileFinished {
    fn new() -> CMsgClientUFSUploadFileFinished {
        CMsgClientUFSUploadFileFinished::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSUploadFileFinished>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSUploadFileFinished::has_eresult,
                    CMsgClientUFSUploadFileFinished::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSUploadFileFinished::has_sha_file,
                    CMsgClientUFSUploadFileFinished::get_sha_file,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSUploadFileFinished>(
                    "CMsgClientUFSUploadFileFinished",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSUploadFileFinished {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_sha_file();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSUploadFileFinished {
    fn eq(&self, other: &CMsgClientUFSUploadFileFinished) -> bool {
        self.eresult == other.eresult &&
        self.sha_file == other.sha_file &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSUploadFileFinished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSDeleteFileRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSDeleteFileRequest {}

impl CMsgClientUFSDeleteFileRequest {
    pub fn new() -> CMsgClientUFSDeleteFileRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSDeleteFileRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSDeleteFileRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSDeleteFileRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSDeleteFileRequest {
                    app_id: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    is_explicit_delete: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string file_name = 2;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool is_explicit_delete = 3;

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    pub fn get_is_explicit_delete<'a>(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.is_explicit_delete.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.is_explicit_delete {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSDeleteFileRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSDeleteFileRequest {
    fn new() -> CMsgClientUFSDeleteFileRequest {
        CMsgClientUFSDeleteFileRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSDeleteFileRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSDeleteFileRequest::has_app_id,
                    CMsgClientUFSDeleteFileRequest::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSDeleteFileRequest::has_file_name,
                    CMsgClientUFSDeleteFileRequest::get_file_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_explicit_delete",
                    CMsgClientUFSDeleteFileRequest::has_is_explicit_delete,
                    CMsgClientUFSDeleteFileRequest::get_is_explicit_delete,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDeleteFileRequest>(
                    "CMsgClientUFSDeleteFileRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSDeleteFileRequest {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_file_name();
        self.clear_is_explicit_delete();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSDeleteFileRequest {
    fn eq(&self, other: &CMsgClientUFSDeleteFileRequest) -> bool {
        self.app_id == other.app_id &&
        self.file_name == other.file_name &&
        self.is_explicit_delete == other.is_explicit_delete &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDeleteFileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSDeleteFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSDeleteFileResponse {}

impl CMsgClientUFSDeleteFileResponse {
    pub fn new() -> CMsgClientUFSDeleteFileResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSDeleteFileResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSDeleteFileResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSDeleteFileResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSDeleteFileResponse {
                    eresult: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional string file_name = 2;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSDeleteFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSDeleteFileResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSDeleteFileResponse {
    fn new() -> CMsgClientUFSDeleteFileResponse {
        CMsgClientUFSDeleteFileResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSDeleteFileResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSDeleteFileResponse::has_eresult,
                    CMsgClientUFSDeleteFileResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSDeleteFileResponse::has_file_name,
                    CMsgClientUFSDeleteFileResponse::get_file_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDeleteFileResponse>(
                    "CMsgClientUFSDeleteFileResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSDeleteFileResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_file_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSDeleteFileResponse {
    fn eq(&self, other: &CMsgClientUFSDeleteFileResponse) -> bool {
        self.eresult == other.eresult &&
        self.file_name == other.file_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDeleteFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetFileListForApp {
    // message fields
    apps_to_query: ::std::vec::Vec<u32>,
    send_path_prefixes: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetFileListForApp {}

impl CMsgClientUFSGetFileListForApp {
    pub fn new() -> CMsgClientUFSGetFileListForApp {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetFileListForApp {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetFileListForApp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetFileListForApp,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetFileListForApp {
                    apps_to_query: ::std::vec::Vec::new(),
                    send_path_prefixes: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 apps_to_query = 1;

    pub fn clear_apps_to_query(&mut self) {
        self.apps_to_query.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps_to_query(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps_to_query = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps_to_query<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.apps_to_query
    }

    // Take field
    pub fn take_apps_to_query(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps_to_query, ::std::vec::Vec::new())
    }

    pub fn get_apps_to_query<'a>(&'a self) -> &'a [u32] {
        &self.apps_to_query
    }

    // optional bool send_path_prefixes = 2;

    pub fn clear_send_path_prefixes(&mut self) {
        self.send_path_prefixes = ::std::option::Option::None;
    }

    pub fn has_send_path_prefixes(&self) -> bool {
        self.send_path_prefixes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_path_prefixes(&mut self, v: bool) {
        self.send_path_prefixes = ::std::option::Option::Some(v);
    }

    pub fn get_send_path_prefixes<'a>(&self) -> bool {
        self.send_path_prefixes.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForApp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps_to_query));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.send_path_prefixes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.apps_to_query.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.send_path_prefixes.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.apps_to_query.iter() {
            try!(os.write_uint32(1, *v));
        };
        if let Some(v) = self.send_path_prefixes {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetFileListForApp>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetFileListForApp {
    fn new() -> CMsgClientUFSGetFileListForApp {
        CMsgClientUFSGetFileListForApp::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetFileListForApp>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "apps_to_query",
                    CMsgClientUFSGetFileListForApp::get_apps_to_query,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "send_path_prefixes",
                    CMsgClientUFSGetFileListForApp::has_send_path_prefixes,
                    CMsgClientUFSGetFileListForApp::get_send_path_prefixes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetFileListForApp>(
                    "CMsgClientUFSGetFileListForApp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForApp {
    fn clear(&mut self) {
        self.clear_apps_to_query();
        self.clear_send_path_prefixes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetFileListForApp {
    fn eq(&self, other: &CMsgClientUFSGetFileListForApp) -> bool {
        self.apps_to_query == other.apps_to_query &&
        self.send_path_prefixes == other.send_path_prefixes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForApp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetFileListForAppResponse {
    // message fields
    files: ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File>,
    path_prefixes: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetFileListForAppResponse {}

impl CMsgClientUFSGetFileListForAppResponse {
    pub fn new() -> CMsgClientUFSGetFileListForAppResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetFileListForAppResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetFileListForAppResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetFileListForAppResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetFileListForAppResponse {
                    files: ::protobuf::RepeatedField::new(),
                    path_prefixes: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientUFSGetFileListForAppResponse.File files = 1;

    pub fn clear_files(&mut self) {
        self.files.clear();
    }

    // Param is passed by value, moved
    pub fn set_files(&mut self, v: ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File>) {
        self.files = v;
    }

    // Mutable pointer to the field.
    pub fn mut_files<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File> {
        &mut self.files
    }

    // Take field
    pub fn take_files(&mut self) -> ::protobuf::RepeatedField<CMsgClientUFSGetFileListForAppResponse_File> {
        ::std::mem::replace(&mut self.files, ::protobuf::RepeatedField::new())
    }

    pub fn get_files<'a>(&'a self) -> &'a [CMsgClientUFSGetFileListForAppResponse_File] {
        &self.files
    }

    // repeated string path_prefixes = 2;

    pub fn clear_path_prefixes(&mut self) {
        self.path_prefixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_prefixes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.path_prefixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path_prefixes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.path_prefixes
    }

    // Take field
    pub fn take_path_prefixes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.path_prefixes, ::protobuf::RepeatedField::new())
    }

    pub fn get_path_prefixes<'a>(&'a self) -> &'a [::std::string::String] {
        &self.path_prefixes
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForAppResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.files));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.path_prefixes));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.files.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.path_prefixes.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.files.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.path_prefixes.iter() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetFileListForAppResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetFileListForAppResponse {
    fn new() -> CMsgClientUFSGetFileListForAppResponse {
        CMsgClientUFSGetFileListForAppResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetFileListForAppResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "files",
                    CMsgClientUFSGetFileListForAppResponse::get_files,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_string_accessor(
                    "path_prefixes",
                    CMsgClientUFSGetFileListForAppResponse::get_path_prefixes,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetFileListForAppResponse>(
                    "CMsgClientUFSGetFileListForAppResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForAppResponse {
    fn clear(&mut self) {
        self.clear_files();
        self.clear_path_prefixes();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetFileListForAppResponse {
    fn eq(&self, other: &CMsgClientUFSGetFileListForAppResponse) -> bool {
        self.files == other.files &&
        self.path_prefixes == other.path_prefixes &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForAppResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetFileListForAppResponse_File {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    raw_file_size: ::std::option::Option<u32>,
    is_explicit_delete: ::std::option::Option<bool>,
    platforms_to_sync: ::std::option::Option<u32>,
    path_prefix_index: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetFileListForAppResponse_File {}

impl CMsgClientUFSGetFileListForAppResponse_File {
    pub fn new() -> CMsgClientUFSGetFileListForAppResponse_File {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetFileListForAppResponse_File {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetFileListForAppResponse_File> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetFileListForAppResponse_File,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetFileListForAppResponse_File {
                    app_id: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    sha_file: ::protobuf::SingularField::none(),
                    time_stamp: ::std::option::Option::None,
                    raw_file_size: ::std::option::Option::None,
                    is_explicit_delete: ::std::option::Option::None,
                    platforms_to_sync: ::std::option::Option::None,
                    path_prefix_index: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string file_name = 2;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes sha_file = 3;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint64 time_stamp = 4;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_time_stamp<'a>(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    // optional uint32 raw_file_size = 5;

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    pub fn get_raw_file_size<'a>(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    // optional bool is_explicit_delete = 6;

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    pub fn get_is_explicit_delete<'a>(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    // optional uint32 platforms_to_sync = 7;

    pub fn clear_platforms_to_sync(&mut self) {
        self.platforms_to_sync = ::std::option::Option::None;
    }

    pub fn has_platforms_to_sync(&self) -> bool {
        self.platforms_to_sync.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platforms_to_sync(&mut self, v: u32) {
        self.platforms_to_sync = ::std::option::Option::Some(v);
    }

    pub fn get_platforms_to_sync<'a>(&self) -> u32 {
        self.platforms_to_sync.unwrap_or(0)
    }

    // optional uint32 path_prefix_index = 8;

    pub fn clear_path_prefix_index(&mut self) {
        self.path_prefix_index = ::std::option::Option::None;
    }

    pub fn has_path_prefix_index(&self) -> bool {
        self.path_prefix_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path_prefix_index(&mut self, v: u32) {
        self.path_prefix_index = ::std::option::Option::Some(v);
    }

    pub fn get_path_prefix_index<'a>(&self) -> u32 {
        self.path_prefix_index.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientUFSGetFileListForAppResponse_File {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.platforms_to_sync = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.path_prefix_index = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.time_stamp.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.raw_file_size.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_explicit_delete.is_some() {
            my_size += 2;
        };
        for value in self.platforms_to_sync.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.path_prefix_index.iter() {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.time_stamp {
            try!(os.write_uint64(4, v));
        };
        if let Some(v) = self.raw_file_size {
            try!(os.write_uint32(5, v));
        };
        if let Some(v) = self.is_explicit_delete {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.platforms_to_sync {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.path_prefix_index {
            try!(os.write_uint32(8, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetFileListForAppResponse_File>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetFileListForAppResponse_File {
    fn new() -> CMsgClientUFSGetFileListForAppResponse_File {
        CMsgClientUFSGetFileListForAppResponse_File::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetFileListForAppResponse_File>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSGetFileListForAppResponse_File::has_app_id,
                    CMsgClientUFSGetFileListForAppResponse_File::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSGetFileListForAppResponse_File::has_file_name,
                    CMsgClientUFSGetFileListForAppResponse_File::get_file_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSGetFileListForAppResponse_File::has_sha_file,
                    CMsgClientUFSGetFileListForAppResponse_File::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "time_stamp",
                    CMsgClientUFSGetFileListForAppResponse_File::has_time_stamp,
                    CMsgClientUFSGetFileListForAppResponse_File::get_time_stamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "raw_file_size",
                    CMsgClientUFSGetFileListForAppResponse_File::has_raw_file_size,
                    CMsgClientUFSGetFileListForAppResponse_File::get_raw_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_explicit_delete",
                    CMsgClientUFSGetFileListForAppResponse_File::has_is_explicit_delete,
                    CMsgClientUFSGetFileListForAppResponse_File::get_is_explicit_delete,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "platforms_to_sync",
                    CMsgClientUFSGetFileListForAppResponse_File::has_platforms_to_sync,
                    CMsgClientUFSGetFileListForAppResponse_File::get_platforms_to_sync,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "path_prefix_index",
                    CMsgClientUFSGetFileListForAppResponse_File::has_path_prefix_index,
                    CMsgClientUFSGetFileListForAppResponse_File::get_path_prefix_index,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetFileListForAppResponse_File>(
                    "CMsgClientUFSGetFileListForAppResponse_File",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetFileListForAppResponse_File {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_file_name();
        self.clear_sha_file();
        self.clear_time_stamp();
        self.clear_raw_file_size();
        self.clear_is_explicit_delete();
        self.clear_platforms_to_sync();
        self.clear_path_prefix_index();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetFileListForAppResponse_File {
    fn eq(&self, other: &CMsgClientUFSGetFileListForAppResponse_File) -> bool {
        self.app_id == other.app_id &&
        self.file_name == other.file_name &&
        self.sha_file == other.sha_file &&
        self.time_stamp == other.time_stamp &&
        self.raw_file_size == other.raw_file_size &&
        self.is_explicit_delete == other.is_explicit_delete &&
        self.platforms_to_sync == other.platforms_to_sync &&
        self.path_prefix_index == other.path_prefix_index &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetFileListForAppResponse_File {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSDownloadRequest {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    can_handle_http: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSDownloadRequest {}

impl CMsgClientUFSDownloadRequest {
    pub fn new() -> CMsgClientUFSDownloadRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSDownloadRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSDownloadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSDownloadRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSDownloadRequest {
                    app_id: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    can_handle_http: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string file_name = 2;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bool can_handle_http = 3;

    pub fn clear_can_handle_http(&mut self) {
        self.can_handle_http = ::std::option::Option::None;
    }

    pub fn has_can_handle_http(&self) -> bool {
        self.can_handle_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_handle_http(&mut self, v: bool) {
        self.can_handle_http = ::std::option::Option::Some(v);
    }

    pub fn get_can_handle_http<'a>(&self) -> bool {
        self.can_handle_http.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.can_handle_http = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.can_handle_http.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.can_handle_http {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSDownloadRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSDownloadRequest {
    fn new() -> CMsgClientUFSDownloadRequest {
        CMsgClientUFSDownloadRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSDownloadRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSDownloadRequest::has_app_id,
                    CMsgClientUFSDownloadRequest::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSDownloadRequest::has_file_name,
                    CMsgClientUFSDownloadRequest::get_file_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "can_handle_http",
                    CMsgClientUFSDownloadRequest::has_can_handle_http,
                    CMsgClientUFSDownloadRequest::get_can_handle_http,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDownloadRequest>(
                    "CMsgClientUFSDownloadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSDownloadRequest {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_file_name();
        self.clear_can_handle_http();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSDownloadRequest {
    fn eq(&self, other: &CMsgClientUFSDownloadRequest) -> bool {
        self.app_id == other.app_id &&
        self.file_name == other.file_name &&
        self.can_handle_http == other.can_handle_http &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSDownloadResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    file_size: ::std::option::Option<u32>,
    raw_file_size: ::std::option::Option<u32>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    is_explicit_delete: ::std::option::Option<bool>,
    use_http: ::std::option::Option<bool>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    http_url: ::protobuf::SingularField<::std::string::String>,
    kv_headers: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    use_https: ::std::option::Option<bool>,
    encrypted: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSDownloadResponse {}

impl CMsgClientUFSDownloadResponse {
    pub fn new() -> CMsgClientUFSDownloadResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSDownloadResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSDownloadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSDownloadResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSDownloadResponse {
                    eresult: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    file_size: ::std::option::Option::None,
                    raw_file_size: ::std::option::Option::None,
                    sha_file: ::protobuf::SingularField::none(),
                    time_stamp: ::std::option::Option::None,
                    is_explicit_delete: ::std::option::Option::None,
                    use_http: ::std::option::Option::None,
                    http_host: ::protobuf::SingularField::none(),
                    http_url: ::protobuf::SingularField::none(),
                    kv_headers: ::protobuf::SingularField::none(),
                    use_https: ::std::option::Option::None,
                    encrypted: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional uint32 app_id = 2;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional uint32 file_size = 3;

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    pub fn get_file_size<'a>(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    // optional uint32 raw_file_size = 4;

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    pub fn get_raw_file_size<'a>(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    // optional bytes sha_file = 5;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint64 time_stamp = 6;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_time_stamp<'a>(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    // optional bool is_explicit_delete = 7;

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    pub fn get_is_explicit_delete<'a>(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }

    // optional bool use_http = 8;

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }

    pub fn get_use_http<'a>(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    // optional string http_host = 9;

    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        };
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_http_host<'a>(&'a self) -> &'a str {
        match self.http_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string http_url = 10;

    pub fn clear_http_url(&mut self) {
        self.http_url.clear();
    }

    pub fn has_http_url(&self) -> bool {
        self.http_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_url(&mut self, v: ::std::string::String) {
        self.http_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_url<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.http_url.is_none() {
            self.http_url.set_default();
        };
        self.http_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_url(&mut self) -> ::std::string::String {
        self.http_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_http_url<'a>(&'a self) -> &'a str {
        match self.http_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes kv_headers = 11;

    pub fn clear_kv_headers(&mut self) {
        self.kv_headers.clear();
    }

    pub fn has_kv_headers(&self) -> bool {
        self.kv_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kv_headers(&mut self, v: ::std::vec::Vec<u8>) {
        self.kv_headers = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kv_headers<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.kv_headers.is_none() {
            self.kv_headers.set_default();
        };
        self.kv_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_kv_headers(&mut self) -> ::std::vec::Vec<u8> {
        self.kv_headers.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_kv_headers<'a>(&'a self) -> &'a [u8] {
        match self.kv_headers.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool use_https = 12;

    pub fn clear_use_https(&mut self) {
        self.use_https = ::std::option::Option::None;
    }

    pub fn has_use_https(&self) -> bool {
        self.use_https.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_https(&mut self, v: bool) {
        self.use_https = ::std::option::Option::Some(v);
    }

    pub fn get_use_https<'a>(&self) -> bool {
        self.use_https.unwrap_or(false)
    }

    // optional bool encrypted = 13;

    pub fn clear_encrypted(&mut self) {
        self.encrypted = ::std::option::Option::None;
    }

    pub fn has_encrypted(&self) -> bool {
        self.encrypted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted(&mut self, v: bool) {
        self.encrypted = ::std::option::Option::Some(v);
    }

    pub fn get_encrypted<'a>(&self) -> bool {
        self.encrypted.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSDownloadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                5 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.use_http = ::std::option::Option::Some(tmp);
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host));
                },
                10 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_url));
                },
                11 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.kv_headers));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.use_https = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.encrypted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_size.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.raw_file_size.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in self.time_stamp.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_explicit_delete.is_some() {
            my_size += 2;
        };
        if self.use_http.is_some() {
            my_size += 2;
        };
        for value in self.http_host.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in self.http_url.iter() {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        for value in self.kv_headers.iter() {
            my_size += ::protobuf::rt::bytes_size(11, &value);
        };
        if self.use_https.is_some() {
            my_size += 2;
        };
        if self.encrypted.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.file_size {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.raw_file_size {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(5, &v));
        };
        if let Some(v) = self.time_stamp {
            try!(os.write_uint64(6, v));
        };
        if let Some(v) = self.is_explicit_delete {
            try!(os.write_bool(7, v));
        };
        if let Some(v) = self.use_http {
            try!(os.write_bool(8, v));
        };
        if let Some(v) = self.http_host.as_ref() {
            try!(os.write_string(9, &v));
        };
        if let Some(v) = self.http_url.as_ref() {
            try!(os.write_string(10, &v));
        };
        if let Some(v) = self.kv_headers.as_ref() {
            try!(os.write_bytes(11, &v));
        };
        if let Some(v) = self.use_https {
            try!(os.write_bool(12, v));
        };
        if let Some(v) = self.encrypted {
            try!(os.write_bool(13, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSDownloadResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSDownloadResponse {
    fn new() -> CMsgClientUFSDownloadResponse {
        CMsgClientUFSDownloadResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSDownloadResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSDownloadResponse::has_eresult,
                    CMsgClientUFSDownloadResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSDownloadResponse::has_app_id,
                    CMsgClientUFSDownloadResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "file_size",
                    CMsgClientUFSDownloadResponse::has_file_size,
                    CMsgClientUFSDownloadResponse::get_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "raw_file_size",
                    CMsgClientUFSDownloadResponse::has_raw_file_size,
                    CMsgClientUFSDownloadResponse::get_raw_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSDownloadResponse::has_sha_file,
                    CMsgClientUFSDownloadResponse::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "time_stamp",
                    CMsgClientUFSDownloadResponse::has_time_stamp,
                    CMsgClientUFSDownloadResponse::get_time_stamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_explicit_delete",
                    CMsgClientUFSDownloadResponse::has_is_explicit_delete,
                    CMsgClientUFSDownloadResponse::get_is_explicit_delete,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "use_http",
                    CMsgClientUFSDownloadResponse::has_use_http,
                    CMsgClientUFSDownloadResponse::get_use_http,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "http_host",
                    CMsgClientUFSDownloadResponse::has_http_host,
                    CMsgClientUFSDownloadResponse::get_http_host,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "http_url",
                    CMsgClientUFSDownloadResponse::has_http_url,
                    CMsgClientUFSDownloadResponse::get_http_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "kv_headers",
                    CMsgClientUFSDownloadResponse::has_kv_headers,
                    CMsgClientUFSDownloadResponse::get_kv_headers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "use_https",
                    CMsgClientUFSDownloadResponse::has_use_https,
                    CMsgClientUFSDownloadResponse::get_use_https,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "encrypted",
                    CMsgClientUFSDownloadResponse::has_encrypted,
                    CMsgClientUFSDownloadResponse::get_encrypted,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSDownloadResponse>(
                    "CMsgClientUFSDownloadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSDownloadResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_app_id();
        self.clear_file_size();
        self.clear_raw_file_size();
        self.clear_sha_file();
        self.clear_time_stamp();
        self.clear_is_explicit_delete();
        self.clear_use_http();
        self.clear_http_host();
        self.clear_http_url();
        self.clear_kv_headers();
        self.clear_use_https();
        self.clear_encrypted();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSDownloadResponse {
    fn eq(&self, other: &CMsgClientUFSDownloadResponse) -> bool {
        self.eresult == other.eresult &&
        self.app_id == other.app_id &&
        self.file_size == other.file_size &&
        self.raw_file_size == other.raw_file_size &&
        self.sha_file == other.sha_file &&
        self.time_stamp == other.time_stamp &&
        self.is_explicit_delete == other.is_explicit_delete &&
        self.use_http == other.use_http &&
        self.http_host == other.http_host &&
        self.http_url == other.http_url &&
        self.kv_headers == other.kv_headers &&
        self.use_https == other.use_https &&
        self.encrypted == other.encrypted &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSLoginRequest {
    // message fields
    protocol_version: ::std::option::Option<u32>,
    am_session_token: ::std::option::Option<u64>,
    apps: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSLoginRequest {}

impl CMsgClientUFSLoginRequest {
    pub fn new() -> CMsgClientUFSLoginRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSLoginRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSLoginRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSLoginRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSLoginRequest {
                    protocol_version: ::std::option::Option::None,
                    am_session_token: ::std::option::Option::None,
                    apps: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 protocol_version = 1;

    pub fn clear_protocol_version(&mut self) {
        self.protocol_version = ::std::option::Option::None;
    }

    pub fn has_protocol_version(&self) -> bool {
        self.protocol_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol_version(&mut self, v: u32) {
        self.protocol_version = ::std::option::Option::Some(v);
    }

    pub fn get_protocol_version<'a>(&self) -> u32 {
        self.protocol_version.unwrap_or(0)
    }

    // optional uint64 am_session_token = 2;

    pub fn clear_am_session_token(&mut self) {
        self.am_session_token = ::std::option::Option::None;
    }

    pub fn has_am_session_token(&self) -> bool {
        self.am_session_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_am_session_token(&mut self, v: u64) {
        self.am_session_token = ::std::option::Option::Some(v);
    }

    pub fn get_am_session_token<'a>(&self) -> u64 {
        self.am_session_token.unwrap_or(0)
    }

    // repeated uint32 apps = 3;

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps, ::std::vec::Vec::new())
    }

    pub fn get_apps<'a>(&'a self) -> &'a [u32] {
        &self.apps
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.protocol_version = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.am_session_token = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.protocol_version.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.am_session_token.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.apps.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.protocol_version {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.am_session_token {
            try!(os.write_uint64(2, v));
        };
        for v in self.apps.iter() {
            try!(os.write_uint32(3, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSLoginRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSLoginRequest {
    fn new() -> CMsgClientUFSLoginRequest {
        CMsgClientUFSLoginRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSLoginRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "protocol_version",
                    CMsgClientUFSLoginRequest::has_protocol_version,
                    CMsgClientUFSLoginRequest::get_protocol_version,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "am_session_token",
                    CMsgClientUFSLoginRequest::has_am_session_token,
                    CMsgClientUFSLoginRequest::get_am_session_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "apps",
                    CMsgClientUFSLoginRequest::get_apps,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSLoginRequest>(
                    "CMsgClientUFSLoginRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSLoginRequest {
    fn clear(&mut self) {
        self.clear_protocol_version();
        self.clear_am_session_token();
        self.clear_apps();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSLoginRequest {
    fn eq(&self, other: &CMsgClientUFSLoginRequest) -> bool {
        self.protocol_version == other.protocol_version &&
        self.am_session_token == other.am_session_token &&
        self.apps == other.apps &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSLoginRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSLoginResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSLoginResponse {}

impl CMsgClientUFSLoginResponse {
    pub fn new() -> CMsgClientUFSLoginResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSLoginResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSLoginResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSLoginResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSLoginResponse {
                    eresult: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
}

impl ::protobuf::Message for CMsgClientUFSLoginResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSLoginResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSLoginResponse {
    fn new() -> CMsgClientUFSLoginResponse {
        CMsgClientUFSLoginResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSLoginResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSLoginResponse::has_eresult,
                    CMsgClientUFSLoginResponse::get_eresult,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSLoginResponse>(
                    "CMsgClientUFSLoginResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSLoginResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSLoginResponse {
    fn eq(&self, other: &CMsgClientUFSLoginResponse) -> bool {
        self.eresult == other.eresult &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSLoginResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestEncryptedAppTicket {
    // message fields
    app_id: ::std::option::Option<u32>,
    userdata: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestEncryptedAppTicket {}

impl CMsgClientRequestEncryptedAppTicket {
    pub fn new() -> CMsgClientRequestEncryptedAppTicket {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicket {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestEncryptedAppTicket> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestEncryptedAppTicket,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestEncryptedAppTicket {
                    app_id: ::std::option::Option::None,
                    userdata: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional bytes userdata = 2;

    pub fn clear_userdata(&mut self) {
        self.userdata.clear();
    }

    pub fn has_userdata(&self) -> bool {
        self.userdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userdata(&mut self, v: ::std::vec::Vec<u8>) {
        self.userdata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userdata<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.userdata.is_none() {
            self.userdata.set_default();
        };
        self.userdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_userdata(&mut self) -> ::std::vec::Vec<u8> {
        self.userdata.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_userdata<'a>(&'a self) -> &'a [u8] {
        match self.userdata.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.userdata));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.userdata.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.userdata.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestEncryptedAppTicket>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestEncryptedAppTicket {
    fn new() -> CMsgClientRequestEncryptedAppTicket {
        CMsgClientRequestEncryptedAppTicket::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestEncryptedAppTicket>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientRequestEncryptedAppTicket::has_app_id,
                    CMsgClientRequestEncryptedAppTicket::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "userdata",
                    CMsgClientRequestEncryptedAppTicket::has_userdata,
                    CMsgClientRequestEncryptedAppTicket::get_userdata,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestEncryptedAppTicket>(
                    "CMsgClientRequestEncryptedAppTicket",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestEncryptedAppTicket {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_userdata();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestEncryptedAppTicket {
    fn eq(&self, other: &CMsgClientRequestEncryptedAppTicket) -> bool {
        self.app_id == other.app_id &&
        self.userdata == other.userdata &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestEncryptedAppTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRequestEncryptedAppTicketResponse {
    // message fields
    app_id: ::std::option::Option<u32>,
    eresult: ::std::option::Option<i32>,
    encrypted_app_ticket: ::protobuf::SingularPtrField<super::encrypted_app_ticket::EncryptedAppTicket>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRequestEncryptedAppTicketResponse {}

impl CMsgClientRequestEncryptedAppTicketResponse {
    pub fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRequestEncryptedAppTicketResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRequestEncryptedAppTicketResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRequestEncryptedAppTicketResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRequestEncryptedAppTicketResponse {
                    app_id: ::std::option::Option::None,
                    eresult: ::std::option::Option::None,
                    encrypted_app_ticket: ::protobuf::SingularPtrField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional int32 eresult = 2;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional .EncryptedAppTicket encrypted_app_ticket = 3;

    pub fn clear_encrypted_app_ticket(&mut self) {
        self.encrypted_app_ticket.clear();
    }

    pub fn has_encrypted_app_ticket(&self) -> bool {
        self.encrypted_app_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encrypted_app_ticket(&mut self, v: super::encrypted_app_ticket::EncryptedAppTicket) {
        self.encrypted_app_ticket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encrypted_app_ticket<'a>(&'a mut self) -> &'a mut super::encrypted_app_ticket::EncryptedAppTicket {
        if self.encrypted_app_ticket.is_none() {
            self.encrypted_app_ticket.set_default();
        };
        self.encrypted_app_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_encrypted_app_ticket(&mut self) -> super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.take().unwrap_or_else(|| super::encrypted_app_ticket::EncryptedAppTicket::new())
    }

    pub fn get_encrypted_app_ticket<'a>(&'a self) -> &'a super::encrypted_app_ticket::EncryptedAppTicket {
        self.encrypted_app_ticket.as_ref().unwrap_or_else(|| super::encrypted_app_ticket::EncryptedAppTicket::default_instance())
    }
}

impl ::protobuf::Message for CMsgClientRequestEncryptedAppTicketResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encrypted_app_ticket));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.encrypted_app_ticket.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.eresult {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.encrypted_app_ticket.as_ref() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRequestEncryptedAppTicketResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRequestEncryptedAppTicketResponse {
    fn new() -> CMsgClientRequestEncryptedAppTicketResponse {
        CMsgClientRequestEncryptedAppTicketResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRequestEncryptedAppTicketResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientRequestEncryptedAppTicketResponse::has_app_id,
                    CMsgClientRequestEncryptedAppTicketResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientRequestEncryptedAppTicketResponse::has_eresult,
                    CMsgClientRequestEncryptedAppTicketResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "encrypted_app_ticket",
                    CMsgClientRequestEncryptedAppTicketResponse::has_encrypted_app_ticket,
                    CMsgClientRequestEncryptedAppTicketResponse::get_encrypted_app_ticket,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRequestEncryptedAppTicketResponse>(
                    "CMsgClientRequestEncryptedAppTicketResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRequestEncryptedAppTicketResponse {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_eresult();
        self.clear_encrypted_app_ticket();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRequestEncryptedAppTicketResponse {
    fn eq(&self, other: &CMsgClientRequestEncryptedAppTicketResponse) -> bool {
        self.app_id == other.app_id &&
        self.eresult == other.eresult &&
        self.encrypted_app_ticket == other.encrypted_app_ticket &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRequestEncryptedAppTicketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientWalletInfoUpdate {
    // message fields
    has_wallet: ::std::option::Option<bool>,
    balance: ::std::option::Option<i32>,
    currency: ::std::option::Option<i32>,
    balance_delayed: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientWalletInfoUpdate {}

impl CMsgClientWalletInfoUpdate {
    pub fn new() -> CMsgClientWalletInfoUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientWalletInfoUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientWalletInfoUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientWalletInfoUpdate,
        };
        unsafe {
            instance.get(|| {
                CMsgClientWalletInfoUpdate {
                    has_wallet: ::std::option::Option::None,
                    balance: ::std::option::Option::None,
                    currency: ::std::option::Option::None,
                    balance_delayed: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional bool has_wallet = 1;

    pub fn clear_has_wallet(&mut self) {
        self.has_wallet = ::std::option::Option::None;
    }

    pub fn has_has_wallet(&self) -> bool {
        self.has_wallet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_wallet(&mut self, v: bool) {
        self.has_wallet = ::std::option::Option::Some(v);
    }

    pub fn get_has_wallet<'a>(&self) -> bool {
        self.has_wallet.unwrap_or(false)
    }

    // optional int32 balance = 2;

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i32) {
        self.balance = ::std::option::Option::Some(v);
    }

    pub fn get_balance<'a>(&self) -> i32 {
        self.balance.unwrap_or(0)
    }

    // optional int32 currency = 3;

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }

    pub fn get_currency<'a>(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    // optional int32 balance_delayed = 4;

    pub fn clear_balance_delayed(&mut self) {
        self.balance_delayed = ::std::option::Option::None;
    }

    pub fn has_balance_delayed(&self) -> bool {
        self.balance_delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_delayed(&mut self, v: i32) {
        self.balance_delayed = ::std::option::Option::Some(v);
    }

    pub fn get_balance_delayed<'a>(&self) -> i32 {
        self.balance_delayed.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientWalletInfoUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.has_wallet = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.balance = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.currency = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.balance_delayed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.has_wallet.is_some() {
            my_size += 2;
        };
        for value in self.balance.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.currency.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.balance_delayed.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.has_wallet {
            try!(os.write_bool(1, v));
        };
        if let Some(v) = self.balance {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.currency {
            try!(os.write_int32(3, v));
        };
        if let Some(v) = self.balance_delayed {
            try!(os.write_int32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientWalletInfoUpdate>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientWalletInfoUpdate {
    fn new() -> CMsgClientWalletInfoUpdate {
        CMsgClientWalletInfoUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientWalletInfoUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "has_wallet",
                    CMsgClientWalletInfoUpdate::has_has_wallet,
                    CMsgClientWalletInfoUpdate::get_has_wallet,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "balance",
                    CMsgClientWalletInfoUpdate::has_balance,
                    CMsgClientWalletInfoUpdate::get_balance,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "currency",
                    CMsgClientWalletInfoUpdate::has_currency,
                    CMsgClientWalletInfoUpdate::get_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "balance_delayed",
                    CMsgClientWalletInfoUpdate::has_balance_delayed,
                    CMsgClientWalletInfoUpdate::get_balance_delayed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientWalletInfoUpdate>(
                    "CMsgClientWalletInfoUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientWalletInfoUpdate {
    fn clear(&mut self) {
        self.clear_has_wallet();
        self.clear_balance();
        self.clear_currency();
        self.clear_balance_delayed();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientWalletInfoUpdate {
    fn eq(&self, other: &CMsgClientWalletInfoUpdate) -> bool {
        self.has_wallet == other.has_wallet &&
        self.balance == other.balance &&
        self.currency == other.currency &&
        self.balance_delayed == other.balance_delayed &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientWalletInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoUpdate {
    // message fields
    last_changenumber: ::std::option::Option<u32>,
    send_changelist: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoUpdate {}

impl CMsgClientAppInfoUpdate {
    pub fn new() -> CMsgClientAppInfoUpdate {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoUpdate {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoUpdate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoUpdate,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoUpdate {
                    last_changenumber: ::std::option::Option::None,
                    send_changelist: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 last_changenumber = 1;

    pub fn clear_last_changenumber(&mut self) {
        self.last_changenumber = ::std::option::Option::None;
    }

    pub fn has_last_changenumber(&self) -> bool {
        self.last_changenumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_changenumber(&mut self, v: u32) {
        self.last_changenumber = ::std::option::Option::Some(v);
    }

    pub fn get_last_changenumber<'a>(&self) -> u32 {
        self.last_changenumber.unwrap_or(0)
    }

    // optional bool send_changelist = 2;

    pub fn clear_send_changelist(&mut self) {
        self.send_changelist = ::std::option::Option::None;
    }

    pub fn has_send_changelist(&self) -> bool {
        self.send_changelist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_changelist(&mut self, v: bool) {
        self.send_changelist = ::std::option::Option::Some(v);
    }

    pub fn get_send_changelist<'a>(&self) -> bool {
        self.send_changelist.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientAppInfoUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.last_changenumber = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.send_changelist = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.last_changenumber.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.send_changelist.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.last_changenumber {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.send_changelist {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoUpdate>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoUpdate {
    fn new() -> CMsgClientAppInfoUpdate {
        CMsgClientAppInfoUpdate::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoUpdate>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "last_changenumber",
                    CMsgClientAppInfoUpdate::has_last_changenumber,
                    CMsgClientAppInfoUpdate::get_last_changenumber,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "send_changelist",
                    CMsgClientAppInfoUpdate::has_send_changelist,
                    CMsgClientAppInfoUpdate::get_send_changelist,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoUpdate>(
                    "CMsgClientAppInfoUpdate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoUpdate {
    fn clear(&mut self) {
        self.clear_last_changenumber();
        self.clear_send_changelist();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoUpdate {
    fn eq(&self, other: &CMsgClientAppInfoUpdate) -> bool {
        self.last_changenumber == other.last_changenumber &&
        self.send_changelist == other.send_changelist &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoChanges {
    // message fields
    current_change_number: ::std::option::Option<u32>,
    force_full_update: ::std::option::Option<bool>,
    appIDs: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoChanges {}

impl CMsgClientAppInfoChanges {
    pub fn new() -> CMsgClientAppInfoChanges {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoChanges {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoChanges> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoChanges,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoChanges {
                    current_change_number: ::std::option::Option::None,
                    force_full_update: ::std::option::Option::None,
                    appIDs: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 current_change_number = 1;

    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    pub fn get_current_change_number<'a>(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }

    // optional bool force_full_update = 2;

    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    pub fn get_force_full_update<'a>(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }

    // repeated uint32 appIDs = 3;

    pub fn clear_appIDs(&mut self) {
        self.appIDs.clear();
    }

    // Param is passed by value, moved
    pub fn set_appIDs(&mut self, v: ::std::vec::Vec<u32>) {
        self.appIDs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appIDs<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.appIDs
    }

    // Take field
    pub fn take_appIDs(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appIDs, ::std::vec::Vec::new())
    }

    pub fn get_appIDs<'a>(&'a self) -> &'a [u32] {
        &self.appIDs
    }
}

impl ::protobuf::Message for CMsgClientAppInfoChanges {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.current_change_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.force_full_update = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appIDs));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.current_change_number.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.force_full_update.is_some() {
            my_size += 2;
        };
        for value in self.appIDs.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_change_number {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.force_full_update {
            try!(os.write_bool(2, v));
        };
        for v in self.appIDs.iter() {
            try!(os.write_uint32(3, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoChanges>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoChanges {
    fn new() -> CMsgClientAppInfoChanges {
        CMsgClientAppInfoChanges::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoChanges>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "current_change_number",
                    CMsgClientAppInfoChanges::has_current_change_number,
                    CMsgClientAppInfoChanges::get_current_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force_full_update",
                    CMsgClientAppInfoChanges::has_force_full_update,
                    CMsgClientAppInfoChanges::get_force_full_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "appIDs",
                    CMsgClientAppInfoChanges::get_appIDs,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoChanges>(
                    "CMsgClientAppInfoChanges",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoChanges {
    fn clear(&mut self) {
        self.clear_current_change_number();
        self.clear_force_full_update();
        self.clear_appIDs();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoChanges {
    fn eq(&self, other: &CMsgClientAppInfoChanges) -> bool {
        self.current_change_number == other.current_change_number &&
        self.force_full_update == other.force_full_update &&
        self.appIDs == other.appIDs &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoChanges {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoRequest {
    // message fields
    apps: ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App>,
    supports_batches: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoRequest {}

impl CMsgClientAppInfoRequest {
    pub fn new() -> CMsgClientAppInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoRequest {
                    apps: ::protobuf::RepeatedField::new(),
                    supports_batches: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientAppInfoRequest.App apps = 1;

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppInfoRequest_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    pub fn get_apps<'a>(&'a self) -> &'a [CMsgClientAppInfoRequest_App] {
        &self.apps
    }

    // optional bool supports_batches = 2;

    pub fn clear_supports_batches(&mut self) {
        self.supports_batches = ::std::option::Option::None;
    }

    pub fn has_supports_batches(&self) -> bool {
        self.supports_batches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supports_batches(&mut self, v: bool) {
        self.supports_batches = ::std::option::Option::Some(v);
    }

    pub fn get_supports_batches<'a>(&self) -> bool {
        self.supports_batches.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientAppInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.supports_batches = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.apps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.supports_batches.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.apps.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.supports_batches {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoRequest {
    fn new() -> CMsgClientAppInfoRequest {
        CMsgClientAppInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "apps",
                    CMsgClientAppInfoRequest::get_apps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "supports_batches",
                    CMsgClientAppInfoRequest::has_supports_batches,
                    CMsgClientAppInfoRequest::get_supports_batches,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoRequest>(
                    "CMsgClientAppInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoRequest {
    fn clear(&mut self) {
        self.clear_apps();
        self.clear_supports_batches();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoRequest {
    fn eq(&self, other: &CMsgClientAppInfoRequest) -> bool {
        self.apps == other.apps &&
        self.supports_batches == other.supports_batches &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoRequest_App {
    // message fields
    app_id: ::std::option::Option<u32>,
    section_flags: ::std::option::Option<u32>,
    section_CRC: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoRequest_App {}

impl CMsgClientAppInfoRequest_App {
    pub fn new() -> CMsgClientAppInfoRequest_App {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoRequest_App {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoRequest_App> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoRequest_App,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoRequest_App {
                    app_id: ::std::option::Option::None,
                    section_flags: ::std::option::Option::None,
                    section_CRC: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional uint32 section_flags = 2;

    pub fn clear_section_flags(&mut self) {
        self.section_flags = ::std::option::Option::None;
    }

    pub fn has_section_flags(&self) -> bool {
        self.section_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_flags(&mut self, v: u32) {
        self.section_flags = ::std::option::Option::Some(v);
    }

    pub fn get_section_flags<'a>(&self) -> u32 {
        self.section_flags.unwrap_or(0)
    }

    // repeated uint32 section_CRC = 3;

    pub fn clear_section_CRC(&mut self) {
        self.section_CRC.clear();
    }

    // Param is passed by value, moved
    pub fn set_section_CRC(&mut self, v: ::std::vec::Vec<u32>) {
        self.section_CRC = v;
    }

    // Mutable pointer to the field.
    pub fn mut_section_CRC<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.section_CRC
    }

    // Take field
    pub fn take_section_CRC(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.section_CRC, ::std::vec::Vec::new())
    }

    pub fn get_section_CRC<'a>(&'a self) -> &'a [u32] {
        &self.section_CRC
    }
}

impl ::protobuf::Message for CMsgClientAppInfoRequest_App {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.section_flags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.section_CRC));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.section_flags.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.section_CRC.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.section_flags {
            try!(os.write_uint32(2, v));
        };
        for v in self.section_CRC.iter() {
            try!(os.write_uint32(3, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoRequest_App>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoRequest_App {
    fn new() -> CMsgClientAppInfoRequest_App {
        CMsgClientAppInfoRequest_App::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoRequest_App>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientAppInfoRequest_App::has_app_id,
                    CMsgClientAppInfoRequest_App::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "section_flags",
                    CMsgClientAppInfoRequest_App::has_section_flags,
                    CMsgClientAppInfoRequest_App::get_section_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "section_CRC",
                    CMsgClientAppInfoRequest_App::get_section_CRC,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoRequest_App>(
                    "CMsgClientAppInfoRequest_App",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoRequest_App {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_section_flags();
        self.clear_section_CRC();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoRequest_App {
    fn eq(&self, other: &CMsgClientAppInfoRequest_App) -> bool {
        self.app_id == other.app_id &&
        self.section_flags == other.section_flags &&
        self.section_CRC == other.section_CRC &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoRequest_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoResponse {
    // message fields
    apps: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App>,
    apps_unknown: ::std::vec::Vec<u32>,
    apps_pending: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoResponse {}

impl CMsgClientAppInfoResponse {
    pub fn new() -> CMsgClientAppInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoResponse {
                    apps: ::protobuf::RepeatedField::new(),
                    apps_unknown: ::std::vec::Vec::new(),
                    apps_pending: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientAppInfoResponse.App apps = 1;

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    pub fn get_apps<'a>(&'a self) -> &'a [CMsgClientAppInfoResponse_App] {
        &self.apps
    }

    // repeated uint32 apps_unknown = 2;

    pub fn clear_apps_unknown(&mut self) {
        self.apps_unknown.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps_unknown(&mut self, v: ::std::vec::Vec<u32>) {
        self.apps_unknown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps_unknown<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.apps_unknown
    }

    // Take field
    pub fn take_apps_unknown(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.apps_unknown, ::std::vec::Vec::new())
    }

    pub fn get_apps_unknown<'a>(&'a self) -> &'a [u32] {
        &self.apps_unknown
    }

    // optional uint32 apps_pending = 3;

    pub fn clear_apps_pending(&mut self) {
        self.apps_pending = ::std::option::Option::None;
    }

    pub fn has_apps_pending(&self) -> bool {
        self.apps_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apps_pending(&mut self, v: u32) {
        self.apps_pending = ::std::option::Option::Some(v);
    }

    pub fn get_apps_pending<'a>(&self) -> u32 {
        self.apps_pending.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.apps_unknown));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.apps_pending = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.apps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.apps_unknown.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.apps_pending.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.apps.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.apps_unknown.iter() {
            try!(os.write_uint32(2, *v));
        };
        if let Some(v) = self.apps_pending {
            try!(os.write_uint32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoResponse {
    fn new() -> CMsgClientAppInfoResponse {
        CMsgClientAppInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "apps",
                    CMsgClientAppInfoResponse::get_apps,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "apps_unknown",
                    CMsgClientAppInfoResponse::get_apps_unknown,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "apps_pending",
                    CMsgClientAppInfoResponse::has_apps_pending,
                    CMsgClientAppInfoResponse::get_apps_pending,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoResponse>(
                    "CMsgClientAppInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse {
    fn clear(&mut self) {
        self.clear_apps();
        self.clear_apps_unknown();
        self.clear_apps_pending();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoResponse {
    fn eq(&self, other: &CMsgClientAppInfoResponse) -> bool {
        self.apps == other.apps &&
        self.apps_unknown == other.apps_unknown &&
        self.apps_pending == other.apps_pending &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoResponse_App {
    // message fields
    app_id: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    sections: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoResponse_App {}

impl CMsgClientAppInfoResponse_App {
    pub fn new() -> CMsgClientAppInfoResponse_App {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoResponse_App {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoResponse_App> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoResponse_App,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoResponse_App {
                    app_id: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    sections: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional uint32 change_number = 2;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }

    // repeated .CMsgClientAppInfoResponse.App.Section sections = 3;

    pub fn clear_sections(&mut self) {
        self.sections.clear();
    }

    // Param is passed by value, moved
    pub fn set_sections(&mut self, v: ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section>) {
        self.sections = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sections<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section> {
        &mut self.sections
    }

    // Take field
    pub fn take_sections(&mut self) -> ::protobuf::RepeatedField<CMsgClientAppInfoResponse_App_Section> {
        ::std::mem::replace(&mut self.sections, ::protobuf::RepeatedField::new())
    }

    pub fn get_sections<'a>(&'a self) -> &'a [CMsgClientAppInfoResponse_App_Section] {
        &self.sections
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse_App {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sections));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sections.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_uint32(2, v));
        };
        for v in self.sections.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoResponse_App>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoResponse_App {
    fn new() -> CMsgClientAppInfoResponse_App {
        CMsgClientAppInfoResponse_App::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoResponse_App>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientAppInfoResponse_App::has_app_id,
                    CMsgClientAppInfoResponse_App::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "change_number",
                    CMsgClientAppInfoResponse_App::has_change_number,
                    CMsgClientAppInfoResponse_App::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "sections",
                    CMsgClientAppInfoResponse_App::get_sections,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoResponse_App>(
                    "CMsgClientAppInfoResponse_App",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse_App {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_change_number();
        self.clear_sections();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoResponse_App {
    fn eq(&self, other: &CMsgClientAppInfoResponse_App) -> bool {
        self.app_id == other.app_id &&
        self.change_number == other.change_number &&
        self.sections == other.sections &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse_App {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAppInfoResponse_App_Section {
    // message fields
    section_id: ::std::option::Option<u32>,
    section_kv: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAppInfoResponse_App_Section {}

impl CMsgClientAppInfoResponse_App_Section {
    pub fn new() -> CMsgClientAppInfoResponse_App_Section {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAppInfoResponse_App_Section {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAppInfoResponse_App_Section> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAppInfoResponse_App_Section,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAppInfoResponse_App_Section {
                    section_id: ::std::option::Option::None,
                    section_kv: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 section_id = 1;

    pub fn clear_section_id(&mut self) {
        self.section_id = ::std::option::Option::None;
    }

    pub fn has_section_id(&self) -> bool {
        self.section_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_id(&mut self, v: u32) {
        self.section_id = ::std::option::Option::Some(v);
    }

    pub fn get_section_id<'a>(&self) -> u32 {
        self.section_id.unwrap_or(0)
    }

    // optional bytes section_kv = 2;

    pub fn clear_section_kv(&mut self) {
        self.section_kv.clear();
    }

    pub fn has_section_kv(&self) -> bool {
        self.section_kv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_section_kv(&mut self, v: ::std::vec::Vec<u8>) {
        self.section_kv = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_section_kv<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.section_kv.is_none() {
            self.section_kv.set_default();
        };
        self.section_kv.as_mut().unwrap()
    }

    // Take field
    pub fn take_section_kv(&mut self) -> ::std::vec::Vec<u8> {
        self.section_kv.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_section_kv<'a>(&'a self) -> &'a [u8] {
        match self.section_kv.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientAppInfoResponse_App_Section {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.section_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.section_kv));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.section_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.section_kv.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.section_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.section_kv.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAppInfoResponse_App_Section>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAppInfoResponse_App_Section {
    fn new() -> CMsgClientAppInfoResponse_App_Section {
        CMsgClientAppInfoResponse_App_Section::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAppInfoResponse_App_Section>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "section_id",
                    CMsgClientAppInfoResponse_App_Section::has_section_id,
                    CMsgClientAppInfoResponse_App_Section::get_section_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "section_kv",
                    CMsgClientAppInfoResponse_App_Section::has_section_kv,
                    CMsgClientAppInfoResponse_App_Section::get_section_kv,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAppInfoResponse_App_Section>(
                    "CMsgClientAppInfoResponse_App_Section",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAppInfoResponse_App_Section {
    fn clear(&mut self) {
        self.clear_section_id();
        self.clear_section_kv();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAppInfoResponse_App_Section {
    fn eq(&self, other: &CMsgClientAppInfoResponse_App_Section) -> bool {
        self.section_id == other.section_id &&
        self.section_kv == other.section_kv &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAppInfoResponse_App_Section {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPackageInfoRequest {
    // message fields
    package_ids: ::std::vec::Vec<u32>,
    meta_data_only: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPackageInfoRequest {}

impl CMsgClientPackageInfoRequest {
    pub fn new() -> CMsgClientPackageInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPackageInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPackageInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPackageInfoRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPackageInfoRequest {
                    package_ids: ::std::vec::Vec::new(),
                    meta_data_only: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 package_ids = 1;

    pub fn clear_package_ids(&mut self) {
        self.package_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_ids(&mut self, v: ::std::vec::Vec<u32>) {
        self.package_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_ids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.package_ids
    }

    // Take field
    pub fn take_package_ids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.package_ids, ::std::vec::Vec::new())
    }

    pub fn get_package_ids<'a>(&'a self) -> &'a [u32] {
        &self.package_ids
    }

    // optional bool meta_data_only = 2;

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    pub fn get_meta_data_only<'a>(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.package_ids));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.meta_data_only = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.package_ids.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.meta_data_only.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.package_ids.iter() {
            try!(os.write_uint32(1, *v));
        };
        if let Some(v) = self.meta_data_only {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPackageInfoRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPackageInfoRequest {
    fn new() -> CMsgClientPackageInfoRequest {
        CMsgClientPackageInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPackageInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "package_ids",
                    CMsgClientPackageInfoRequest::get_package_ids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "meta_data_only",
                    CMsgClientPackageInfoRequest::has_meta_data_only,
                    CMsgClientPackageInfoRequest::get_meta_data_only,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPackageInfoRequest>(
                    "CMsgClientPackageInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoRequest {
    fn clear(&mut self) {
        self.clear_package_ids();
        self.clear_meta_data_only();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPackageInfoRequest {
    fn eq(&self, other: &CMsgClientPackageInfoRequest) -> bool {
        self.package_ids == other.package_ids &&
        self.meta_data_only == other.meta_data_only &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPackageInfoResponse {
    // message fields
    packages: ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package>,
    packages_unknown: ::std::vec::Vec<u32>,
    packages_pending: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPackageInfoResponse {}

impl CMsgClientPackageInfoResponse {
    pub fn new() -> CMsgClientPackageInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPackageInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPackageInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPackageInfoResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPackageInfoResponse {
                    packages: ::protobuf::RepeatedField::new(),
                    packages_unknown: ::std::vec::Vec::new(),
                    packages_pending: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientPackageInfoResponse.Package packages = 1;

    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<CMsgClientPackageInfoResponse_Package> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }

    pub fn get_packages<'a>(&'a self) -> &'a [CMsgClientPackageInfoResponse_Package] {
        &self.packages
    }

    // repeated uint32 packages_unknown = 2;

    pub fn clear_packages_unknown(&mut self) {
        self.packages_unknown.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages_unknown(&mut self, v: ::std::vec::Vec<u32>) {
        self.packages_unknown = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages_unknown<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.packages_unknown
    }

    // Take field
    pub fn take_packages_unknown(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packages_unknown, ::std::vec::Vec::new())
    }

    pub fn get_packages_unknown<'a>(&'a self) -> &'a [u32] {
        &self.packages_unknown
    }

    // optional uint32 packages_pending = 3;

    pub fn clear_packages_pending(&mut self) {
        self.packages_pending = ::std::option::Option::None;
    }

    pub fn has_packages_pending(&self) -> bool {
        self.packages_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packages_pending(&mut self, v: u32) {
        self.packages_pending = ::std::option::Option::Some(v);
    }

    pub fn get_packages_pending<'a>(&self) -> u32 {
        self.packages_pending.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packages));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packages_unknown));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.packages_pending = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packages.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.packages_unknown.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.packages_pending.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.packages.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.packages_unknown.iter() {
            try!(os.write_uint32(2, *v));
        };
        if let Some(v) = self.packages_pending {
            try!(os.write_uint32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPackageInfoResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPackageInfoResponse {
    fn new() -> CMsgClientPackageInfoResponse {
        CMsgClientPackageInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPackageInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "packages",
                    CMsgClientPackageInfoResponse::get_packages,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "packages_unknown",
                    CMsgClientPackageInfoResponse::get_packages_unknown,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "packages_pending",
                    CMsgClientPackageInfoResponse::has_packages_pending,
                    CMsgClientPackageInfoResponse::get_packages_pending,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPackageInfoResponse>(
                    "CMsgClientPackageInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoResponse {
    fn clear(&mut self) {
        self.clear_packages();
        self.clear_packages_unknown();
        self.clear_packages_pending();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPackageInfoResponse {
    fn eq(&self, other: &CMsgClientPackageInfoResponse) -> bool {
        self.packages == other.packages &&
        self.packages_unknown == other.packages_unknown &&
        self.packages_pending == other.packages_pending &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPackageInfoResponse_Package {
    // message fields
    package_id: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPackageInfoResponse_Package {}

impl CMsgClientPackageInfoResponse_Package {
    pub fn new() -> CMsgClientPackageInfoResponse_Package {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPackageInfoResponse_Package {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPackageInfoResponse_Package> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPackageInfoResponse_Package,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPackageInfoResponse_Package {
                    package_id: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    sha: ::protobuf::SingularField::none(),
                    buffer: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 package_id = 1;

    pub fn clear_package_id(&mut self) {
        self.package_id = ::std::option::Option::None;
    }

    pub fn has_package_id(&self) -> bool {
        self.package_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package_id(&mut self, v: u32) {
        self.package_id = ::std::option::Option::Some(v);
    }

    pub fn get_package_id<'a>(&self) -> u32 {
        self.package_id.unwrap_or(0)
    }

    // optional uint32 change_number = 2;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }

    // optional bytes sha = 3;

    pub fn clear_sha(&mut self) {
        self.sha.clear();
    }

    pub fn has_sha(&self) -> bool {
        self.sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha.is_none() {
            self.sha.set_default();
        };
        self.sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha<'a>(&'a self) -> &'a [u8] {
        match self.sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes buffer = 4;

    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    pub fn has_buffer(&self) -> bool {
        self.buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.buffer.is_none() {
            self.buffer.set_default();
        };
        self.buffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_buffer<'a>(&'a self) -> &'a [u8] {
        match self.buffer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientPackageInfoResponse_Package {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.package_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.package_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.sha.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        for value in self.buffer.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.package_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.sha.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.buffer.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPackageInfoResponse_Package>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPackageInfoResponse_Package {
    fn new() -> CMsgClientPackageInfoResponse_Package {
        CMsgClientPackageInfoResponse_Package::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPackageInfoResponse_Package>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "package_id",
                    CMsgClientPackageInfoResponse_Package::has_package_id,
                    CMsgClientPackageInfoResponse_Package::get_package_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "change_number",
                    CMsgClientPackageInfoResponse_Package::has_change_number,
                    CMsgClientPackageInfoResponse_Package::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha",
                    CMsgClientPackageInfoResponse_Package::has_sha,
                    CMsgClientPackageInfoResponse_Package::get_sha,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "buffer",
                    CMsgClientPackageInfoResponse_Package::has_buffer,
                    CMsgClientPackageInfoResponse_Package::get_buffer,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPackageInfoResponse_Package>(
                    "CMsgClientPackageInfoResponse_Package",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPackageInfoResponse_Package {
    fn clear(&mut self) {
        self.clear_package_id();
        self.clear_change_number();
        self.clear_sha();
        self.clear_buffer();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPackageInfoResponse_Package {
    fn eq(&self, other: &CMsgClientPackageInfoResponse_Package) -> bool {
        self.package_id == other.package_id &&
        self.change_number == other.change_number &&
        self.sha == other.sha &&
        self.buffer == other.buffer &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPackageInfoResponse_Package {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSChangesSinceRequest {
    // message fields
    since_change_number: ::std::option::Option<u32>,
    send_app_info_changes: ::std::option::Option<bool>,
    send_package_info_changes: ::std::option::Option<bool>,
    num_app_info_cached: ::std::option::Option<u32>,
    num_package_info_cached: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSChangesSinceRequest {}

impl CMsgClientPICSChangesSinceRequest {
    pub fn new() -> CMsgClientPICSChangesSinceRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSChangesSinceRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSChangesSinceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSChangesSinceRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSChangesSinceRequest {
                    since_change_number: ::std::option::Option::None,
                    send_app_info_changes: ::std::option::Option::None,
                    send_package_info_changes: ::std::option::Option::None,
                    num_app_info_cached: ::std::option::Option::None,
                    num_package_info_cached: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 since_change_number = 1;

    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    pub fn get_since_change_number<'a>(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }

    // optional bool send_app_info_changes = 2;

    pub fn clear_send_app_info_changes(&mut self) {
        self.send_app_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_app_info_changes(&self) -> bool {
        self.send_app_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_app_info_changes(&mut self, v: bool) {
        self.send_app_info_changes = ::std::option::Option::Some(v);
    }

    pub fn get_send_app_info_changes<'a>(&self) -> bool {
        self.send_app_info_changes.unwrap_or(false)
    }

    // optional bool send_package_info_changes = 3;

    pub fn clear_send_package_info_changes(&mut self) {
        self.send_package_info_changes = ::std::option::Option::None;
    }

    pub fn has_send_package_info_changes(&self) -> bool {
        self.send_package_info_changes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_package_info_changes(&mut self, v: bool) {
        self.send_package_info_changes = ::std::option::Option::Some(v);
    }

    pub fn get_send_package_info_changes<'a>(&self) -> bool {
        self.send_package_info_changes.unwrap_or(false)
    }

    // optional uint32 num_app_info_cached = 4;

    pub fn clear_num_app_info_cached(&mut self) {
        self.num_app_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_app_info_cached(&self) -> bool {
        self.num_app_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_app_info_cached(&mut self, v: u32) {
        self.num_app_info_cached = ::std::option::Option::Some(v);
    }

    pub fn get_num_app_info_cached<'a>(&self) -> u32 {
        self.num_app_info_cached.unwrap_or(0)
    }

    // optional uint32 num_package_info_cached = 5;

    pub fn clear_num_package_info_cached(&mut self) {
        self.num_package_info_cached = ::std::option::Option::None;
    }

    pub fn has_num_package_info_cached(&self) -> bool {
        self.num_package_info_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_package_info_cached(&mut self, v: u32) {
        self.num_package_info_cached = ::std::option::Option::Some(v);
    }

    pub fn get_num_package_info_cached<'a>(&self) -> u32 {
        self.num_package_info_cached.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.since_change_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.send_app_info_changes = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.send_package_info_changes = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.num_app_info_cached = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.num_package_info_cached = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.since_change_number.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.send_app_info_changes.is_some() {
            my_size += 2;
        };
        if self.send_package_info_changes.is_some() {
            my_size += 2;
        };
        for value in self.num_app_info_cached.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.num_package_info_cached.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.since_change_number {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.send_app_info_changes {
            try!(os.write_bool(2, v));
        };
        if let Some(v) = self.send_package_info_changes {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.num_app_info_cached {
            try!(os.write_uint32(4, v));
        };
        if let Some(v) = self.num_package_info_cached {
            try!(os.write_uint32(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSChangesSinceRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSChangesSinceRequest {
    fn new() -> CMsgClientPICSChangesSinceRequest {
        CMsgClientPICSChangesSinceRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSChangesSinceRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "since_change_number",
                    CMsgClientPICSChangesSinceRequest::has_since_change_number,
                    CMsgClientPICSChangesSinceRequest::get_since_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "send_app_info_changes",
                    CMsgClientPICSChangesSinceRequest::has_send_app_info_changes,
                    CMsgClientPICSChangesSinceRequest::get_send_app_info_changes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "send_package_info_changes",
                    CMsgClientPICSChangesSinceRequest::has_send_package_info_changes,
                    CMsgClientPICSChangesSinceRequest::get_send_package_info_changes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "num_app_info_cached",
                    CMsgClientPICSChangesSinceRequest::has_num_app_info_cached,
                    CMsgClientPICSChangesSinceRequest::get_num_app_info_cached,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "num_package_info_cached",
                    CMsgClientPICSChangesSinceRequest::has_num_package_info_cached,
                    CMsgClientPICSChangesSinceRequest::get_num_package_info_cached,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSChangesSinceRequest>(
                    "CMsgClientPICSChangesSinceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceRequest {
    fn clear(&mut self) {
        self.clear_since_change_number();
        self.clear_send_app_info_changes();
        self.clear_send_package_info_changes();
        self.clear_num_app_info_cached();
        self.clear_num_package_info_cached();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSChangesSinceRequest {
    fn eq(&self, other: &CMsgClientPICSChangesSinceRequest) -> bool {
        self.since_change_number == other.since_change_number &&
        self.send_app_info_changes == other.send_app_info_changes &&
        self.send_package_info_changes == other.send_package_info_changes &&
        self.num_app_info_cached == other.num_app_info_cached &&
        self.num_package_info_cached == other.num_package_info_cached &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse {
    // message fields
    current_change_number: ::std::option::Option<u32>,
    since_change_number: ::std::option::Option<u32>,
    force_full_update: ::std::option::Option<bool>,
    package_changes: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange>,
    app_changes: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange>,
    force_full_app_update: ::std::option::Option<bool>,
    force_full_package_update: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSChangesSinceResponse {}

impl CMsgClientPICSChangesSinceResponse {
    pub fn new() -> CMsgClientPICSChangesSinceResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSChangesSinceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSChangesSinceResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSChangesSinceResponse {
                    current_change_number: ::std::option::Option::None,
                    since_change_number: ::std::option::Option::None,
                    force_full_update: ::std::option::Option::None,
                    package_changes: ::protobuf::RepeatedField::new(),
                    app_changes: ::protobuf::RepeatedField::new(),
                    force_full_app_update: ::std::option::Option::None,
                    force_full_package_update: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 current_change_number = 1;

    pub fn clear_current_change_number(&mut self) {
        self.current_change_number = ::std::option::Option::None;
    }

    pub fn has_current_change_number(&self) -> bool {
        self.current_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_change_number(&mut self, v: u32) {
        self.current_change_number = ::std::option::Option::Some(v);
    }

    pub fn get_current_change_number<'a>(&self) -> u32 {
        self.current_change_number.unwrap_or(0)
    }

    // optional uint32 since_change_number = 2;

    pub fn clear_since_change_number(&mut self) {
        self.since_change_number = ::std::option::Option::None;
    }

    pub fn has_since_change_number(&self) -> bool {
        self.since_change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_since_change_number(&mut self, v: u32) {
        self.since_change_number = ::std::option::Option::Some(v);
    }

    pub fn get_since_change_number<'a>(&self) -> u32 {
        self.since_change_number.unwrap_or(0)
    }

    // optional bool force_full_update = 3;

    pub fn clear_force_full_update(&mut self) {
        self.force_full_update = ::std::option::Option::None;
    }

    pub fn has_force_full_update(&self) -> bool {
        self.force_full_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_update(&mut self, v: bool) {
        self.force_full_update = ::std::option::Option::Some(v);
    }

    pub fn get_force_full_update<'a>(&self) -> bool {
        self.force_full_update.unwrap_or(false)
    }

    // repeated .CMsgClientPICSChangesSinceResponse.PackageChange package_changes = 4;

    pub fn clear_package_changes(&mut self) {
        self.package_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_changes(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange>) {
        self.package_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_changes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange> {
        &mut self.package_changes
    }

    // Take field
    pub fn take_package_changes(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_PackageChange> {
        ::std::mem::replace(&mut self.package_changes, ::protobuf::RepeatedField::new())
    }

    pub fn get_package_changes<'a>(&'a self) -> &'a [CMsgClientPICSChangesSinceResponse_PackageChange] {
        &self.package_changes
    }

    // repeated .CMsgClientPICSChangesSinceResponse.AppChange app_changes = 5;

    pub fn clear_app_changes(&mut self) {
        self.app_changes.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_changes(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange>) {
        self.app_changes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_changes<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange> {
        &mut self.app_changes
    }

    // Take field
    pub fn take_app_changes(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSChangesSinceResponse_AppChange> {
        ::std::mem::replace(&mut self.app_changes, ::protobuf::RepeatedField::new())
    }

    pub fn get_app_changes<'a>(&'a self) -> &'a [CMsgClientPICSChangesSinceResponse_AppChange] {
        &self.app_changes
    }

    // optional bool force_full_app_update = 6;

    pub fn clear_force_full_app_update(&mut self) {
        self.force_full_app_update = ::std::option::Option::None;
    }

    pub fn has_force_full_app_update(&self) -> bool {
        self.force_full_app_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_app_update(&mut self, v: bool) {
        self.force_full_app_update = ::std::option::Option::Some(v);
    }

    pub fn get_force_full_app_update<'a>(&self) -> bool {
        self.force_full_app_update.unwrap_or(false)
    }

    // optional bool force_full_package_update = 7;

    pub fn clear_force_full_package_update(&mut self) {
        self.force_full_package_update = ::std::option::Option::None;
    }

    pub fn has_force_full_package_update(&self) -> bool {
        self.force_full_package_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_full_package_update(&mut self, v: bool) {
        self.force_full_package_update = ::std::option::Option::Some(v);
    }

    pub fn get_force_full_package_update<'a>(&self) -> bool {
        self.force_full_package_update.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.current_change_number = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.since_change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.force_full_update = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package_changes));
                },
                5 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_changes));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.force_full_app_update = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.force_full_package_update = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.current_change_number.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.since_change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.force_full_update.is_some() {
            my_size += 2;
        };
        for value in self.package_changes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.app_changes.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.force_full_app_update.is_some() {
            my_size += 2;
        };
        if self.force_full_package_update.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.current_change_number {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.since_change_number {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.force_full_update {
            try!(os.write_bool(3, v));
        };
        for v in self.package_changes.iter() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.app_changes.iter() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.force_full_app_update {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.force_full_package_update {
            try!(os.write_bool(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSChangesSinceResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSChangesSinceResponse {
    fn new() -> CMsgClientPICSChangesSinceResponse {
        CMsgClientPICSChangesSinceResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSChangesSinceResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "current_change_number",
                    CMsgClientPICSChangesSinceResponse::has_current_change_number,
                    CMsgClientPICSChangesSinceResponse::get_current_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "since_change_number",
                    CMsgClientPICSChangesSinceResponse::has_since_change_number,
                    CMsgClientPICSChangesSinceResponse::get_since_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force_full_update",
                    CMsgClientPICSChangesSinceResponse::has_force_full_update,
                    CMsgClientPICSChangesSinceResponse::get_force_full_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "package_changes",
                    CMsgClientPICSChangesSinceResponse::get_package_changes,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "app_changes",
                    CMsgClientPICSChangesSinceResponse::get_app_changes,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force_full_app_update",
                    CMsgClientPICSChangesSinceResponse::has_force_full_app_update,
                    CMsgClientPICSChangesSinceResponse::get_force_full_app_update,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "force_full_package_update",
                    CMsgClientPICSChangesSinceResponse::has_force_full_package_update,
                    CMsgClientPICSChangesSinceResponse::get_force_full_package_update,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSChangesSinceResponse>(
                    "CMsgClientPICSChangesSinceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse {
    fn clear(&mut self) {
        self.clear_current_change_number();
        self.clear_since_change_number();
        self.clear_force_full_update();
        self.clear_package_changes();
        self.clear_app_changes();
        self.clear_force_full_app_update();
        self.clear_force_full_package_update();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSChangesSinceResponse {
    fn eq(&self, other: &CMsgClientPICSChangesSinceResponse) -> bool {
        self.current_change_number == other.current_change_number &&
        self.since_change_number == other.since_change_number &&
        self.force_full_update == other.force_full_update &&
        self.package_changes == other.package_changes &&
        self.app_changes == other.app_changes &&
        self.force_full_app_update == other.force_full_app_update &&
        self.force_full_package_update == other.force_full_package_update &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse_PackageChange {
    // message fields
    packageid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    needs_token: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSChangesSinceResponse_PackageChange {}

impl CMsgClientPICSChangesSinceResponse_PackageChange {
    pub fn new() -> CMsgClientPICSChangesSinceResponse_PackageChange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse_PackageChange {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSChangesSinceResponse_PackageChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSChangesSinceResponse_PackageChange,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSChangesSinceResponse_PackageChange {
                    packageid: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    needs_token: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 packageid = 1;

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    pub fn get_packageid<'a>(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    // optional uint32 change_number = 2;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }

    // optional bool needs_token = 3;

    pub fn clear_needs_token(&mut self) {
        self.needs_token = ::std::option::Option::None;
    }

    pub fn has_needs_token(&self) -> bool {
        self.needs_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_token(&mut self, v: bool) {
        self.needs_token = ::std::option::Option::Some(v);
    }

    pub fn get_needs_token<'a>(&self) -> bool {
        self.needs_token.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.needs_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packageid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.needs_token.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.needs_token {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSChangesSinceResponse_PackageChange>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn new() -> CMsgClientPICSChangesSinceResponse_PackageChange {
        CMsgClientPICSChangesSinceResponse_PackageChange::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSChangesSinceResponse_PackageChange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "packageid",
                    CMsgClientPICSChangesSinceResponse_PackageChange::has_packageid,
                    CMsgClientPICSChangesSinceResponse_PackageChange::get_packageid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "change_number",
                    CMsgClientPICSChangesSinceResponse_PackageChange::has_change_number,
                    CMsgClientPICSChangesSinceResponse_PackageChange::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "needs_token",
                    CMsgClientPICSChangesSinceResponse_PackageChange::has_needs_token,
                    CMsgClientPICSChangesSinceResponse_PackageChange::get_needs_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSChangesSinceResponse_PackageChange>(
                    "CMsgClientPICSChangesSinceResponse_PackageChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn clear(&mut self) {
        self.clear_packageid();
        self.clear_change_number();
        self.clear_needs_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn eq(&self, other: &CMsgClientPICSChangesSinceResponse_PackageChange) -> bool {
        self.packageid == other.packageid &&
        self.change_number == other.change_number &&
        self.needs_token == other.needs_token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse_PackageChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSChangesSinceResponse_AppChange {
    // message fields
    appid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    needs_token: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSChangesSinceResponse_AppChange {}

impl CMsgClientPICSChangesSinceResponse_AppChange {
    pub fn new() -> CMsgClientPICSChangesSinceResponse_AppChange {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSChangesSinceResponse_AppChange {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSChangesSinceResponse_AppChange> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSChangesSinceResponse_AppChange,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSChangesSinceResponse_AppChange {
                    appid: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    needs_token: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional uint32 change_number = 2;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }

    // optional bool needs_token = 3;

    pub fn clear_needs_token(&mut self) {
        self.needs_token = ::std::option::Option::None;
    }

    pub fn has_needs_token(&self) -> bool {
        self.needs_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needs_token(&mut self, v: bool) {
        self.needs_token = ::std::option::Option::Some(v);
    }

    pub fn get_needs_token<'a>(&self) -> bool {
        self.needs_token.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientPICSChangesSinceResponse_AppChange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.needs_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.needs_token.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.needs_token {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSChangesSinceResponse_AppChange>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSChangesSinceResponse_AppChange {
    fn new() -> CMsgClientPICSChangesSinceResponse_AppChange {
        CMsgClientPICSChangesSinceResponse_AppChange::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSChangesSinceResponse_AppChange>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientPICSChangesSinceResponse_AppChange::has_appid,
                    CMsgClientPICSChangesSinceResponse_AppChange::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "change_number",
                    CMsgClientPICSChangesSinceResponse_AppChange::has_change_number,
                    CMsgClientPICSChangesSinceResponse_AppChange::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "needs_token",
                    CMsgClientPICSChangesSinceResponse_AppChange::has_needs_token,
                    CMsgClientPICSChangesSinceResponse_AppChange::get_needs_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSChangesSinceResponse_AppChange>(
                    "CMsgClientPICSChangesSinceResponse_AppChange",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSChangesSinceResponse_AppChange {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_change_number();
        self.clear_needs_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSChangesSinceResponse_AppChange {
    fn eq(&self, other: &CMsgClientPICSChangesSinceResponse_AppChange) -> bool {
        self.appid == other.appid &&
        self.change_number == other.change_number &&
        self.needs_token == other.needs_token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSChangesSinceResponse_AppChange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest {
    // message fields
    packages: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo>,
    apps: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo>,
    meta_data_only: ::std::option::Option<bool>,
    num_prev_failed: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSProductInfoRequest {}

impl CMsgClientPICSProductInfoRequest {
    pub fn new() -> CMsgClientPICSProductInfoRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSProductInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSProductInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSProductInfoRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSProductInfoRequest {
                    packages: ::protobuf::RepeatedField::new(),
                    apps: ::protobuf::RepeatedField::new(),
                    meta_data_only: ::std::option::Option::None,
                    num_prev_failed: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientPICSProductInfoRequest.PackageInfo packages = 1;

    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_PackageInfo> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }

    pub fn get_packages<'a>(&'a self) -> &'a [CMsgClientPICSProductInfoRequest_PackageInfo] {
        &self.packages
    }

    // repeated .CMsgClientPICSProductInfoRequest.AppInfo apps = 2;

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoRequest_AppInfo> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    pub fn get_apps<'a>(&'a self) -> &'a [CMsgClientPICSProductInfoRequest_AppInfo] {
        &self.apps
    }

    // optional bool meta_data_only = 3;

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    pub fn get_meta_data_only<'a>(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    // optional uint32 num_prev_failed = 4;

    pub fn clear_num_prev_failed(&mut self) {
        self.num_prev_failed = ::std::option::Option::None;
    }

    pub fn has_num_prev_failed(&self) -> bool {
        self.num_prev_failed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_prev_failed(&mut self, v: u32) {
        self.num_prev_failed = ::std::option::Option::Some(v);
    }

    pub fn get_num_prev_failed<'a>(&self) -> u32 {
        self.num_prev_failed.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packages));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.meta_data_only = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.num_prev_failed = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packages.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.apps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.meta_data_only.is_some() {
            my_size += 2;
        };
        for value in self.num_prev_failed.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.packages.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.apps.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.meta_data_only {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.num_prev_failed {
            try!(os.write_uint32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSProductInfoRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSProductInfoRequest {
    fn new() -> CMsgClientPICSProductInfoRequest {
        CMsgClientPICSProductInfoRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSProductInfoRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "packages",
                    CMsgClientPICSProductInfoRequest::get_packages,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "apps",
                    CMsgClientPICSProductInfoRequest::get_apps,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "meta_data_only",
                    CMsgClientPICSProductInfoRequest::has_meta_data_only,
                    CMsgClientPICSProductInfoRequest::get_meta_data_only,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "num_prev_failed",
                    CMsgClientPICSProductInfoRequest::has_num_prev_failed,
                    CMsgClientPICSProductInfoRequest::get_num_prev_failed,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoRequest>(
                    "CMsgClientPICSProductInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest {
    fn clear(&mut self) {
        self.clear_packages();
        self.clear_apps();
        self.clear_meta_data_only();
        self.clear_num_prev_failed();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSProductInfoRequest {
    fn eq(&self, other: &CMsgClientPICSProductInfoRequest) -> bool {
        self.packages == other.packages &&
        self.apps == other.apps &&
        self.meta_data_only == other.meta_data_only &&
        self.num_prev_failed == other.num_prev_failed &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest_AppInfo {
    // message fields
    appid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    only_public: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSProductInfoRequest_AppInfo {}

impl CMsgClientPICSProductInfoRequest_AppInfo {
    pub fn new() -> CMsgClientPICSProductInfoRequest_AppInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSProductInfoRequest_AppInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSProductInfoRequest_AppInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSProductInfoRequest_AppInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSProductInfoRequest_AppInfo {
                    appid: ::std::option::Option::None,
                    access_token: ::std::option::Option::None,
                    only_public: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional uint64 access_token = 2;

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    pub fn get_access_token<'a>(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }

    // optional bool only_public = 3;

    pub fn clear_only_public(&mut self) {
        self.only_public = ::std::option::Option::None;
    }

    pub fn has_only_public(&self) -> bool {
        self.only_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_public(&mut self, v: bool) {
        self.only_public = ::std::option::Option::Some(v);
    }

    pub fn get_only_public<'a>(&self) -> bool {
        self.only_public.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest_AppInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.only_public = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.access_token.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.only_public.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.access_token {
            try!(os.write_uint64(2, v));
        };
        if let Some(v) = self.only_public {
            try!(os.write_bool(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSProductInfoRequest_AppInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSProductInfoRequest_AppInfo {
    fn new() -> CMsgClientPICSProductInfoRequest_AppInfo {
        CMsgClientPICSProductInfoRequest_AppInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSProductInfoRequest_AppInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientPICSProductInfoRequest_AppInfo::has_appid,
                    CMsgClientPICSProductInfoRequest_AppInfo::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "access_token",
                    CMsgClientPICSProductInfoRequest_AppInfo::has_access_token,
                    CMsgClientPICSProductInfoRequest_AppInfo::get_access_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "only_public",
                    CMsgClientPICSProductInfoRequest_AppInfo::has_only_public,
                    CMsgClientPICSProductInfoRequest_AppInfo::get_only_public,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoRequest_AppInfo>(
                    "CMsgClientPICSProductInfoRequest_AppInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest_AppInfo {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_access_token();
        self.clear_only_public();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSProductInfoRequest_AppInfo {
    fn eq(&self, other: &CMsgClientPICSProductInfoRequest_AppInfo) -> bool {
        self.appid == other.appid &&
        self.access_token == other.access_token &&
        self.only_public == other.only_public &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest_AppInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSProductInfoRequest_PackageInfo {
    // message fields
    packageid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSProductInfoRequest_PackageInfo {}

impl CMsgClientPICSProductInfoRequest_PackageInfo {
    pub fn new() -> CMsgClientPICSProductInfoRequest_PackageInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSProductInfoRequest_PackageInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSProductInfoRequest_PackageInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSProductInfoRequest_PackageInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSProductInfoRequest_PackageInfo {
                    packageid: ::std::option::Option::None,
                    access_token: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 packageid = 1;

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    pub fn get_packageid<'a>(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    // optional uint64 access_token = 2;

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    pub fn get_access_token<'a>(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packageid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.access_token.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.access_token {
            try!(os.write_uint64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSProductInfoRequest_PackageInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn new() -> CMsgClientPICSProductInfoRequest_PackageInfo {
        CMsgClientPICSProductInfoRequest_PackageInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSProductInfoRequest_PackageInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "packageid",
                    CMsgClientPICSProductInfoRequest_PackageInfo::has_packageid,
                    CMsgClientPICSProductInfoRequest_PackageInfo::get_packageid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "access_token",
                    CMsgClientPICSProductInfoRequest_PackageInfo::has_access_token,
                    CMsgClientPICSProductInfoRequest_PackageInfo::get_access_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoRequest_PackageInfo>(
                    "CMsgClientPICSProductInfoRequest_PackageInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn clear(&mut self) {
        self.clear_packageid();
        self.clear_access_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn eq(&self, other: &CMsgClientPICSProductInfoRequest_PackageInfo) -> bool {
        self.packageid == other.packageid &&
        self.access_token == other.access_token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoRequest_PackageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse {
    // message fields
    apps: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo>,
    unknown_appids: ::std::vec::Vec<u32>,
    packages: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo>,
    unknown_packageids: ::std::vec::Vec<u32>,
    meta_data_only: ::std::option::Option<bool>,
    response_pending: ::std::option::Option<bool>,
    http_min_size: ::std::option::Option<u32>,
    http_host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSProductInfoResponse {}

impl CMsgClientPICSProductInfoResponse {
    pub fn new() -> CMsgClientPICSProductInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSProductInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSProductInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSProductInfoResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSProductInfoResponse {
                    apps: ::protobuf::RepeatedField::new(),
                    unknown_appids: ::std::vec::Vec::new(),
                    packages: ::protobuf::RepeatedField::new(),
                    unknown_packageids: ::std::vec::Vec::new(),
                    meta_data_only: ::std::option::Option::None,
                    response_pending: ::std::option::Option::None,
                    http_min_size: ::std::option::Option::None,
                    http_host: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientPICSProductInfoResponse.AppInfo apps = 1;

    pub fn clear_apps(&mut self) {
        self.apps.clear();
    }

    // Param is passed by value, moved
    pub fn set_apps(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo>) {
        self.apps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_apps<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo> {
        &mut self.apps
    }

    // Take field
    pub fn take_apps(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_AppInfo> {
        ::std::mem::replace(&mut self.apps, ::protobuf::RepeatedField::new())
    }

    pub fn get_apps<'a>(&'a self) -> &'a [CMsgClientPICSProductInfoResponse_AppInfo] {
        &self.apps
    }

    // repeated uint32 unknown_appids = 2;

    pub fn clear_unknown_appids(&mut self) {
        self.unknown_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_unknown_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.unknown_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unknown_appids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.unknown_appids
    }

    // Take field
    pub fn take_unknown_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unknown_appids, ::std::vec::Vec::new())
    }

    pub fn get_unknown_appids<'a>(&'a self) -> &'a [u32] {
        &self.unknown_appids
    }

    // repeated .CMsgClientPICSProductInfoResponse.PackageInfo packages = 3;

    pub fn clear_packages(&mut self) {
        self.packages.clear();
    }

    // Param is passed by value, moved
    pub fn set_packages(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo>) {
        self.packages = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packages<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo> {
        &mut self.packages
    }

    // Take field
    pub fn take_packages(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSProductInfoResponse_PackageInfo> {
        ::std::mem::replace(&mut self.packages, ::protobuf::RepeatedField::new())
    }

    pub fn get_packages<'a>(&'a self) -> &'a [CMsgClientPICSProductInfoResponse_PackageInfo] {
        &self.packages
    }

    // repeated uint32 unknown_packageids = 4;

    pub fn clear_unknown_packageids(&mut self) {
        self.unknown_packageids.clear();
    }

    // Param is passed by value, moved
    pub fn set_unknown_packageids(&mut self, v: ::std::vec::Vec<u32>) {
        self.unknown_packageids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unknown_packageids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.unknown_packageids
    }

    // Take field
    pub fn take_unknown_packageids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.unknown_packageids, ::std::vec::Vec::new())
    }

    pub fn get_unknown_packageids<'a>(&'a self) -> &'a [u32] {
        &self.unknown_packageids
    }

    // optional bool meta_data_only = 5;

    pub fn clear_meta_data_only(&mut self) {
        self.meta_data_only = ::std::option::Option::None;
    }

    pub fn has_meta_data_only(&self) -> bool {
        self.meta_data_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta_data_only(&mut self, v: bool) {
        self.meta_data_only = ::std::option::Option::Some(v);
    }

    pub fn get_meta_data_only<'a>(&self) -> bool {
        self.meta_data_only.unwrap_or(false)
    }

    // optional bool response_pending = 6;

    pub fn clear_response_pending(&mut self) {
        self.response_pending = ::std::option::Option::None;
    }

    pub fn has_response_pending(&self) -> bool {
        self.response_pending.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_pending(&mut self, v: bool) {
        self.response_pending = ::std::option::Option::Some(v);
    }

    pub fn get_response_pending<'a>(&self) -> bool {
        self.response_pending.unwrap_or(false)
    }

    // optional uint32 http_min_size = 7;

    pub fn clear_http_min_size(&mut self) {
        self.http_min_size = ::std::option::Option::None;
    }

    pub fn has_http_min_size(&self) -> bool {
        self.http_min_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_min_size(&mut self, v: u32) {
        self.http_min_size = ::std::option::Option::Some(v);
    }

    pub fn get_http_min_size<'a>(&self) -> u32 {
        self.http_min_size.unwrap_or(0)
    }

    // optional string http_host = 8;

    pub fn clear_http_host(&mut self) {
        self.http_host.clear();
    }

    pub fn has_http_host(&self) -> bool {
        self.http_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_host(&mut self, v: ::std::string::String) {
        self.http_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_host<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.http_host.is_none() {
            self.http_host.set_default();
        };
        self.http_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_host(&mut self) -> ::std::string::String {
        self.http_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_http_host<'a>(&'a self) -> &'a str {
        match self.http_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.apps));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unknown_appids));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.packages));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.unknown_packageids));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.meta_data_only = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.response_pending = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.http_min_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.http_host));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.apps.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.unknown_appids.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.packages.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.unknown_packageids.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.meta_data_only.is_some() {
            my_size += 2;
        };
        if self.response_pending.is_some() {
            my_size += 2;
        };
        for value in self.http_min_size.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.http_host.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.apps.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.unknown_appids.iter() {
            try!(os.write_uint32(2, *v));
        };
        for v in self.packages.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.unknown_packageids.iter() {
            try!(os.write_uint32(4, *v));
        };
        if let Some(v) = self.meta_data_only {
            try!(os.write_bool(5, v));
        };
        if let Some(v) = self.response_pending {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.http_min_size {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.http_host.as_ref() {
            try!(os.write_string(8, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSProductInfoResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSProductInfoResponse {
    fn new() -> CMsgClientPICSProductInfoResponse {
        CMsgClientPICSProductInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSProductInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "apps",
                    CMsgClientPICSProductInfoResponse::get_apps,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "unknown_appids",
                    CMsgClientPICSProductInfoResponse::get_unknown_appids,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "packages",
                    CMsgClientPICSProductInfoResponse::get_packages,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "unknown_packageids",
                    CMsgClientPICSProductInfoResponse::get_unknown_packageids,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "meta_data_only",
                    CMsgClientPICSProductInfoResponse::has_meta_data_only,
                    CMsgClientPICSProductInfoResponse::get_meta_data_only,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "response_pending",
                    CMsgClientPICSProductInfoResponse::has_response_pending,
                    CMsgClientPICSProductInfoResponse::get_response_pending,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "http_min_size",
                    CMsgClientPICSProductInfoResponse::has_http_min_size,
                    CMsgClientPICSProductInfoResponse::get_http_min_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "http_host",
                    CMsgClientPICSProductInfoResponse::has_http_host,
                    CMsgClientPICSProductInfoResponse::get_http_host,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoResponse>(
                    "CMsgClientPICSProductInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse {
    fn clear(&mut self) {
        self.clear_apps();
        self.clear_unknown_appids();
        self.clear_packages();
        self.clear_unknown_packageids();
        self.clear_meta_data_only();
        self.clear_response_pending();
        self.clear_http_min_size();
        self.clear_http_host();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSProductInfoResponse {
    fn eq(&self, other: &CMsgClientPICSProductInfoResponse) -> bool {
        self.apps == other.apps &&
        self.unknown_appids == other.unknown_appids &&
        self.packages == other.packages &&
        self.unknown_packageids == other.unknown_packageids &&
        self.meta_data_only == other.meta_data_only &&
        self.response_pending == other.response_pending &&
        self.http_min_size == other.http_min_size &&
        self.http_host == other.http_host &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse_AppInfo {
    // message fields
    appid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    missing_token: ::std::option::Option<bool>,
    sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    only_public: ::std::option::Option<bool>,
    size: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSProductInfoResponse_AppInfo {}

impl CMsgClientPICSProductInfoResponse_AppInfo {
    pub fn new() -> CMsgClientPICSProductInfoResponse_AppInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSProductInfoResponse_AppInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSProductInfoResponse_AppInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSProductInfoResponse_AppInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSProductInfoResponse_AppInfo {
                    appid: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    missing_token: ::std::option::Option::None,
                    sha: ::protobuf::SingularField::none(),
                    buffer: ::protobuf::SingularField::none(),
                    only_public: ::std::option::Option::None,
                    size: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional uint32 change_number = 2;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }

    // optional bool missing_token = 3;

    pub fn clear_missing_token(&mut self) {
        self.missing_token = ::std::option::Option::None;
    }

    pub fn has_missing_token(&self) -> bool {
        self.missing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_token(&mut self, v: bool) {
        self.missing_token = ::std::option::Option::Some(v);
    }

    pub fn get_missing_token<'a>(&self) -> bool {
        self.missing_token.unwrap_or(false)
    }

    // optional bytes sha = 4;

    pub fn clear_sha(&mut self) {
        self.sha.clear();
    }

    pub fn has_sha(&self) -> bool {
        self.sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha.is_none() {
            self.sha.set_default();
        };
        self.sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha<'a>(&'a self) -> &'a [u8] {
        match self.sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes buffer = 5;

    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    pub fn has_buffer(&self) -> bool {
        self.buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.buffer.is_none() {
            self.buffer.set_default();
        };
        self.buffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_buffer<'a>(&'a self) -> &'a [u8] {
        match self.buffer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bool only_public = 6;

    pub fn clear_only_public(&mut self) {
        self.only_public = ::std::option::Option::None;
    }

    pub fn has_only_public(&self) -> bool {
        self.only_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_public(&mut self, v: bool) {
        self.only_public = ::std::option::Option::Some(v);
    }

    pub fn get_only_public<'a>(&self) -> bool {
        self.only_public.unwrap_or(false)
    }

    // optional uint32 size = 7;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size<'a>(&self) -> u32 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse_AppInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.missing_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.only_public = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.missing_token.is_some() {
            my_size += 2;
        };
        for value in self.sha.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.buffer.iter() {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        if self.only_public.is_some() {
            my_size += 2;
        };
        for value in self.size.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.missing_token {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.sha.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.buffer.as_ref() {
            try!(os.write_bytes(5, &v));
        };
        if let Some(v) = self.only_public {
            try!(os.write_bool(6, v));
        };
        if let Some(v) = self.size {
            try!(os.write_uint32(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSProductInfoResponse_AppInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSProductInfoResponse_AppInfo {
    fn new() -> CMsgClientPICSProductInfoResponse_AppInfo {
        CMsgClientPICSProductInfoResponse_AppInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSProductInfoResponse_AppInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_appid,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "change_number",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_change_number,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "missing_token",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_missing_token,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_missing_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_sha,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_sha,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "buffer",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_buffer,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_buffer,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "only_public",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_only_public,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_only_public,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "size",
                    CMsgClientPICSProductInfoResponse_AppInfo::has_size,
                    CMsgClientPICSProductInfoResponse_AppInfo::get_size,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoResponse_AppInfo>(
                    "CMsgClientPICSProductInfoResponse_AppInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse_AppInfo {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_change_number();
        self.clear_missing_token();
        self.clear_sha();
        self.clear_buffer();
        self.clear_only_public();
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSProductInfoResponse_AppInfo {
    fn eq(&self, other: &CMsgClientPICSProductInfoResponse_AppInfo) -> bool {
        self.appid == other.appid &&
        self.change_number == other.change_number &&
        self.missing_token == other.missing_token &&
        self.sha == other.sha &&
        self.buffer == other.buffer &&
        self.only_public == other.only_public &&
        self.size == other.size &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse_AppInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSProductInfoResponse_PackageInfo {
    // message fields
    packageid: ::std::option::Option<u32>,
    change_number: ::std::option::Option<u32>,
    missing_token: ::std::option::Option<bool>,
    sha: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    buffer: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    size: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSProductInfoResponse_PackageInfo {}

impl CMsgClientPICSProductInfoResponse_PackageInfo {
    pub fn new() -> CMsgClientPICSProductInfoResponse_PackageInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSProductInfoResponse_PackageInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSProductInfoResponse_PackageInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSProductInfoResponse_PackageInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSProductInfoResponse_PackageInfo {
                    packageid: ::std::option::Option::None,
                    change_number: ::std::option::Option::None,
                    missing_token: ::std::option::Option::None,
                    sha: ::protobuf::SingularField::none(),
                    buffer: ::protobuf::SingularField::none(),
                    size: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 packageid = 1;

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    pub fn get_packageid<'a>(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    // optional uint32 change_number = 2;

    pub fn clear_change_number(&mut self) {
        self.change_number = ::std::option::Option::None;
    }

    pub fn has_change_number(&self) -> bool {
        self.change_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_change_number(&mut self, v: u32) {
        self.change_number = ::std::option::Option::Some(v);
    }

    pub fn get_change_number<'a>(&self) -> u32 {
        self.change_number.unwrap_or(0)
    }

    // optional bool missing_token = 3;

    pub fn clear_missing_token(&mut self) {
        self.missing_token = ::std::option::Option::None;
    }

    pub fn has_missing_token(&self) -> bool {
        self.missing_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_missing_token(&mut self, v: bool) {
        self.missing_token = ::std::option::Option::Some(v);
    }

    pub fn get_missing_token<'a>(&self) -> bool {
        self.missing_token.unwrap_or(false)
    }

    // optional bytes sha = 4;

    pub fn clear_sha(&mut self) {
        self.sha.clear();
    }

    pub fn has_sha(&self) -> bool {
        self.sha.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha.is_none() {
            self.sha.set_default();
        };
        self.sha.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha(&mut self) -> ::std::vec::Vec<u8> {
        self.sha.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha<'a>(&'a self) -> &'a [u8] {
        match self.sha.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional bytes buffer = 5;

    pub fn clear_buffer(&mut self) {
        self.buffer.clear();
    }

    pub fn has_buffer(&self) -> bool {
        self.buffer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer(&mut self, v: ::std::vec::Vec<u8>) {
        self.buffer = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.buffer.is_none() {
            self.buffer.set_default();
        };
        self.buffer.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer(&mut self) -> ::std::vec::Vec<u8> {
        self.buffer.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_buffer<'a>(&'a self) -> &'a [u8] {
        match self.buffer.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint32 size = 6;

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u32) {
        self.size = ::std::option::Option::Some(v);
    }

    pub fn get_size<'a>(&self) -> u32 {
        self.size.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.change_number = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.missing_token = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.buffer));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.size = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packageid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.change_number.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.missing_token.is_some() {
            my_size += 2;
        };
        for value in self.sha.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.buffer.iter() {
            my_size += ::protobuf::rt::bytes_size(5, &value);
        };
        for value in self.size.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.change_number {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.missing_token {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.sha.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.buffer.as_ref() {
            try!(os.write_bytes(5, &v));
        };
        if let Some(v) = self.size {
            try!(os.write_uint32(6, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSProductInfoResponse_PackageInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn new() -> CMsgClientPICSProductInfoResponse_PackageInfo {
        CMsgClientPICSProductInfoResponse_PackageInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSProductInfoResponse_PackageInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "packageid",
                    CMsgClientPICSProductInfoResponse_PackageInfo::has_packageid,
                    CMsgClientPICSProductInfoResponse_PackageInfo::get_packageid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "change_number",
                    CMsgClientPICSProductInfoResponse_PackageInfo::has_change_number,
                    CMsgClientPICSProductInfoResponse_PackageInfo::get_change_number,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "missing_token",
                    CMsgClientPICSProductInfoResponse_PackageInfo::has_missing_token,
                    CMsgClientPICSProductInfoResponse_PackageInfo::get_missing_token,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha",
                    CMsgClientPICSProductInfoResponse_PackageInfo::has_sha,
                    CMsgClientPICSProductInfoResponse_PackageInfo::get_sha,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "buffer",
                    CMsgClientPICSProductInfoResponse_PackageInfo::has_buffer,
                    CMsgClientPICSProductInfoResponse_PackageInfo::get_buffer,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "size",
                    CMsgClientPICSProductInfoResponse_PackageInfo::has_size,
                    CMsgClientPICSProductInfoResponse_PackageInfo::get_size,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSProductInfoResponse_PackageInfo>(
                    "CMsgClientPICSProductInfoResponse_PackageInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn clear(&mut self) {
        self.clear_packageid();
        self.clear_change_number();
        self.clear_missing_token();
        self.clear_sha();
        self.clear_buffer();
        self.clear_size();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn eq(&self, other: &CMsgClientPICSProductInfoResponse_PackageInfo) -> bool {
        self.packageid == other.packageid &&
        self.change_number == other.change_number &&
        self.missing_token == other.missing_token &&
        self.sha == other.sha &&
        self.buffer == other.buffer &&
        self.size == other.size &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSProductInfoResponse_PackageInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSAccessTokenRequest {
    // message fields
    packageids: ::std::vec::Vec<u32>,
    appids: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSAccessTokenRequest {}

impl CMsgClientPICSAccessTokenRequest {
    pub fn new() -> CMsgClientPICSAccessTokenRequest {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSAccessTokenRequest {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSAccessTokenRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSAccessTokenRequest,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSAccessTokenRequest {
                    packageids: ::std::vec::Vec::new(),
                    appids: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated uint32 packageids = 1;

    pub fn clear_packageids(&mut self) {
        self.packageids.clear();
    }

    // Param is passed by value, moved
    pub fn set_packageids(&mut self, v: ::std::vec::Vec<u32>) {
        self.packageids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_packageids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.packageids
    }

    // Take field
    pub fn take_packageids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.packageids, ::std::vec::Vec::new())
    }

    pub fn get_packageids<'a>(&'a self) -> &'a [u32] {
        &self.packageids
    }

    // repeated uint32 appids = 2;

    pub fn clear_appids(&mut self) {
        self.appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_appids<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.appids
    }

    // Take field
    pub fn take_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.appids, ::std::vec::Vec::new())
    }

    pub fn get_appids<'a>(&'a self) -> &'a [u32] {
        &self.appids
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.packageids));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.appids));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packageids.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.appids.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.packageids.iter() {
            try!(os.write_uint32(1, *v));
        };
        for v in self.appids.iter() {
            try!(os.write_uint32(2, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSAccessTokenRequest>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSAccessTokenRequest {
    fn new() -> CMsgClientPICSAccessTokenRequest {
        CMsgClientPICSAccessTokenRequest::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSAccessTokenRequest>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "packageids",
                    CMsgClientPICSAccessTokenRequest::get_packageids,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "appids",
                    CMsgClientPICSAccessTokenRequest::get_appids,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSAccessTokenRequest>(
                    "CMsgClientPICSAccessTokenRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenRequest {
    fn clear(&mut self) {
        self.clear_packageids();
        self.clear_appids();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSAccessTokenRequest {
    fn eq(&self, other: &CMsgClientPICSAccessTokenRequest) -> bool {
        self.packageids == other.packageids &&
        self.appids == other.appids &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse {
    // message fields
    package_access_tokens: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken>,
    package_denied_tokens: ::std::vec::Vec<u32>,
    app_access_tokens: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken>,
    app_denied_tokens: ::std::vec::Vec<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSAccessTokenResponse {}

impl CMsgClientPICSAccessTokenResponse {
    pub fn new() -> CMsgClientPICSAccessTokenResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSAccessTokenResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSAccessTokenResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSAccessTokenResponse {
                    package_access_tokens: ::protobuf::RepeatedField::new(),
                    package_denied_tokens: ::std::vec::Vec::new(),
                    app_access_tokens: ::protobuf::RepeatedField::new(),
                    app_denied_tokens: ::std::vec::Vec::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientPICSAccessTokenResponse.PackageToken package_access_tokens = 1;

    pub fn clear_package_access_tokens(&mut self) {
        self.package_access_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_access_tokens(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken>) {
        self.package_access_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_access_tokens<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken> {
        &mut self.package_access_tokens
    }

    // Take field
    pub fn take_package_access_tokens(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_PackageToken> {
        ::std::mem::replace(&mut self.package_access_tokens, ::protobuf::RepeatedField::new())
    }

    pub fn get_package_access_tokens<'a>(&'a self) -> &'a [CMsgClientPICSAccessTokenResponse_PackageToken] {
        &self.package_access_tokens
    }

    // repeated uint32 package_denied_tokens = 2;

    pub fn clear_package_denied_tokens(&mut self) {
        self.package_denied_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_package_denied_tokens(&mut self, v: ::std::vec::Vec<u32>) {
        self.package_denied_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_package_denied_tokens<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.package_denied_tokens
    }

    // Take field
    pub fn take_package_denied_tokens(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.package_denied_tokens, ::std::vec::Vec::new())
    }

    pub fn get_package_denied_tokens<'a>(&'a self) -> &'a [u32] {
        &self.package_denied_tokens
    }

    // repeated .CMsgClientPICSAccessTokenResponse.AppToken app_access_tokens = 3;

    pub fn clear_app_access_tokens(&mut self) {
        self.app_access_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_access_tokens(&mut self, v: ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken>) {
        self.app_access_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_access_tokens<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken> {
        &mut self.app_access_tokens
    }

    // Take field
    pub fn take_app_access_tokens(&mut self) -> ::protobuf::RepeatedField<CMsgClientPICSAccessTokenResponse_AppToken> {
        ::std::mem::replace(&mut self.app_access_tokens, ::protobuf::RepeatedField::new())
    }

    pub fn get_app_access_tokens<'a>(&'a self) -> &'a [CMsgClientPICSAccessTokenResponse_AppToken] {
        &self.app_access_tokens
    }

    // repeated uint32 app_denied_tokens = 4;

    pub fn clear_app_denied_tokens(&mut self) {
        self.app_denied_tokens.clear();
    }

    // Param is passed by value, moved
    pub fn set_app_denied_tokens(&mut self, v: ::std::vec::Vec<u32>) {
        self.app_denied_tokens = v;
    }

    // Mutable pointer to the field.
    pub fn mut_app_denied_tokens<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u32> {
        &mut self.app_denied_tokens
    }

    // Take field
    pub fn take_app_denied_tokens(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.app_denied_tokens, ::std::vec::Vec::new())
    }

    pub fn get_app_denied_tokens<'a>(&'a self) -> &'a [u32] {
        &self.app_denied_tokens
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.package_access_tokens));
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.package_denied_tokens));
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.app_access_tokens));
                },
                4 => {
                    try!(::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.app_denied_tokens));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.package_access_tokens.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.package_denied_tokens.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_access_tokens.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.app_denied_tokens.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.package_access_tokens.iter() {
            try!(os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.package_denied_tokens.iter() {
            try!(os.write_uint32(2, *v));
        };
        for v in self.app_access_tokens.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.app_denied_tokens.iter() {
            try!(os.write_uint32(4, *v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSAccessTokenResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSAccessTokenResponse {
    fn new() -> CMsgClientPICSAccessTokenResponse {
        CMsgClientPICSAccessTokenResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSAccessTokenResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "package_access_tokens",
                    CMsgClientPICSAccessTokenResponse::get_package_access_tokens,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "package_denied_tokens",
                    CMsgClientPICSAccessTokenResponse::get_package_denied_tokens,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "app_access_tokens",
                    CMsgClientPICSAccessTokenResponse::get_app_access_tokens,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_u32_accessor(
                    "app_denied_tokens",
                    CMsgClientPICSAccessTokenResponse::get_app_denied_tokens,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSAccessTokenResponse>(
                    "CMsgClientPICSAccessTokenResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse {
    fn clear(&mut self) {
        self.clear_package_access_tokens();
        self.clear_package_denied_tokens();
        self.clear_app_access_tokens();
        self.clear_app_denied_tokens();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSAccessTokenResponse {
    fn eq(&self, other: &CMsgClientPICSAccessTokenResponse) -> bool {
        self.package_access_tokens == other.package_access_tokens &&
        self.package_denied_tokens == other.package_denied_tokens &&
        self.app_access_tokens == other.app_access_tokens &&
        self.app_denied_tokens == other.app_denied_tokens &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse_PackageToken {
    // message fields
    packageid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSAccessTokenResponse_PackageToken {}

impl CMsgClientPICSAccessTokenResponse_PackageToken {
    pub fn new() -> CMsgClientPICSAccessTokenResponse_PackageToken {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse_PackageToken {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSAccessTokenResponse_PackageToken> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSAccessTokenResponse_PackageToken,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSAccessTokenResponse_PackageToken {
                    packageid: ::std::option::Option::None,
                    access_token: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 packageid = 1;

    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    pub fn get_packageid<'a>(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }

    // optional uint64 access_token = 2;

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    pub fn get_access_token<'a>(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.packageid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.packageid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.access_token.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.access_token {
            try!(os.write_uint64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSAccessTokenResponse_PackageToken>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn new() -> CMsgClientPICSAccessTokenResponse_PackageToken {
        CMsgClientPICSAccessTokenResponse_PackageToken::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSAccessTokenResponse_PackageToken>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "packageid",
                    CMsgClientPICSAccessTokenResponse_PackageToken::has_packageid,
                    CMsgClientPICSAccessTokenResponse_PackageToken::get_packageid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "access_token",
                    CMsgClientPICSAccessTokenResponse_PackageToken::has_access_token,
                    CMsgClientPICSAccessTokenResponse_PackageToken::get_access_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSAccessTokenResponse_PackageToken>(
                    "CMsgClientPICSAccessTokenResponse_PackageToken",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn clear(&mut self) {
        self.clear_packageid();
        self.clear_access_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn eq(&self, other: &CMsgClientPICSAccessTokenResponse_PackageToken) -> bool {
        self.packageid == other.packageid &&
        self.access_token == other.access_token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse_PackageToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientPICSAccessTokenResponse_AppToken {
    // message fields
    appid: ::std::option::Option<u32>,
    access_token: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientPICSAccessTokenResponse_AppToken {}

impl CMsgClientPICSAccessTokenResponse_AppToken {
    pub fn new() -> CMsgClientPICSAccessTokenResponse_AppToken {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientPICSAccessTokenResponse_AppToken {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientPICSAccessTokenResponse_AppToken> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientPICSAccessTokenResponse_AppToken,
        };
        unsafe {
            instance.get(|| {
                CMsgClientPICSAccessTokenResponse_AppToken {
                    appid: ::std::option::Option::None,
                    access_token: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 appid = 1;

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    pub fn get_appid<'a>(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    // optional uint64 access_token = 2;

    pub fn clear_access_token(&mut self) {
        self.access_token = ::std::option::Option::None;
    }

    pub fn has_access_token(&self) -> bool {
        self.access_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_access_token(&mut self, v: u64) {
        self.access_token = ::std::option::Option::Some(v);
    }

    pub fn get_access_token<'a>(&self) -> u64 {
        self.access_token.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientPICSAccessTokenResponse_AppToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.appid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.access_token = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.appid.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.access_token.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.access_token {
            try!(os.write_uint64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientPICSAccessTokenResponse_AppToken>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientPICSAccessTokenResponse_AppToken {
    fn new() -> CMsgClientPICSAccessTokenResponse_AppToken {
        CMsgClientPICSAccessTokenResponse_AppToken::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientPICSAccessTokenResponse_AppToken>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "appid",
                    CMsgClientPICSAccessTokenResponse_AppToken::has_appid,
                    CMsgClientPICSAccessTokenResponse_AppToken::get_appid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "access_token",
                    CMsgClientPICSAccessTokenResponse_AppToken::has_access_token,
                    CMsgClientPICSAccessTokenResponse_AppToken::get_access_token,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientPICSAccessTokenResponse_AppToken>(
                    "CMsgClientPICSAccessTokenResponse_AppToken",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientPICSAccessTokenResponse_AppToken {
    fn clear(&mut self) {
        self.clear_appid();
        self.clear_access_token();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientPICSAccessTokenResponse_AppToken {
    fn eq(&self, other: &CMsgClientPICSAccessTokenResponse_AppToken) -> bool {
        self.appid == other.appid &&
        self.access_token == other.access_token &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientPICSAccessTokenResponse_AppToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetUGCDetails {
    // message fields
    hcontent: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetUGCDetails {}

impl CMsgClientUFSGetUGCDetails {
    pub fn new() -> CMsgClientUFSGetUGCDetails {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetUGCDetails {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetUGCDetails> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetUGCDetails,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetUGCDetails {
                    hcontent: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 hcontent = 1;

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    pub fn get_hcontent<'a>(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetails {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.hcontent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hcontent.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.hcontent {
            try!(os.write_fixed64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetUGCDetails>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetUGCDetails {
    fn new() -> CMsgClientUFSGetUGCDetails {
        CMsgClientUFSGetUGCDetails::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetUGCDetails>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "hcontent",
                    CMsgClientUFSGetUGCDetails::has_hcontent,
                    CMsgClientUFSGetUGCDetails::get_hcontent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetUGCDetails>(
                    "CMsgClientUFSGetUGCDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetUGCDetails {
    fn clear(&mut self) {
        self.clear_hcontent();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetUGCDetails {
    fn eq(&self, other: &CMsgClientUFSGetUGCDetails) -> bool {
        self.hcontent == other.hcontent &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetUGCDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetUGCDetailsResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    url: ::protobuf::SingularField<::std::string::String>,
    app_id: ::std::option::Option<u32>,
    filename: ::protobuf::SingularField<::std::string::String>,
    steamid_creator: ::std::option::Option<u64>,
    file_size: ::std::option::Option<u32>,
    compressed_file_size: ::std::option::Option<u32>,
    rangecheck_host: ::protobuf::SingularField<::std::string::String>,
    file_encoded_sha1: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetUGCDetailsResponse {}

impl CMsgClientUFSGetUGCDetailsResponse {
    pub fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetUGCDetailsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetUGCDetailsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetUGCDetailsResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetUGCDetailsResponse {
                    eresult: ::std::option::Option::None,
                    url: ::protobuf::SingularField::none(),
                    app_id: ::std::option::Option::None,
                    filename: ::protobuf::SingularField::none(),
                    steamid_creator: ::std::option::Option::None,
                    file_size: ::std::option::Option::None,
                    compressed_file_size: ::std::option::Option::None,
                    rangecheck_host: ::protobuf::SingularField::none(),
                    file_encoded_sha1: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional string url = 2;

    pub fn clear_url(&mut self) {
        self.url.clear();
    }

    pub fn has_url(&self) -> bool {
        self.url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_url(&mut self, v: ::std::string::String) {
        self.url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_url<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.url.is_none() {
            self.url.set_default();
        };
        self.url.as_mut().unwrap()
    }

    // Take field
    pub fn take_url(&mut self) -> ::std::string::String {
        self.url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_url<'a>(&'a self) -> &'a str {
        match self.url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional uint32 app_id = 3;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string filename = 4;

    pub fn clear_filename(&mut self) {
        self.filename.clear();
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.filename.is_none() {
            self.filename.set_default();
        };
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_filename<'a>(&'a self) -> &'a str {
        match self.filename.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 steamid_creator = 5;

    pub fn clear_steamid_creator(&mut self) {
        self.steamid_creator = ::std::option::Option::None;
    }

    pub fn has_steamid_creator(&self) -> bool {
        self.steamid_creator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_creator(&mut self, v: u64) {
        self.steamid_creator = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_creator<'a>(&self) -> u64 {
        self.steamid_creator.unwrap_or(0)
    }

    // optional uint32 file_size = 6;

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    pub fn get_file_size<'a>(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    // optional uint32 compressed_file_size = 7;

    pub fn clear_compressed_file_size(&mut self) {
        self.compressed_file_size = ::std::option::Option::None;
    }

    pub fn has_compressed_file_size(&self) -> bool {
        self.compressed_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_compressed_file_size(&mut self, v: u32) {
        self.compressed_file_size = ::std::option::Option::Some(v);
    }

    pub fn get_compressed_file_size<'a>(&self) -> u32 {
        self.compressed_file_size.unwrap_or(0)
    }

    // optional string rangecheck_host = 8;

    pub fn clear_rangecheck_host(&mut self) {
        self.rangecheck_host.clear();
    }

    pub fn has_rangecheck_host(&self) -> bool {
        self.rangecheck_host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rangecheck_host(&mut self, v: ::std::string::String) {
        self.rangecheck_host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rangecheck_host<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.rangecheck_host.is_none() {
            self.rangecheck_host.set_default();
        };
        self.rangecheck_host.as_mut().unwrap()
    }

    // Take field
    pub fn take_rangecheck_host(&mut self) -> ::std::string::String {
        self.rangecheck_host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_rangecheck_host<'a>(&'a self) -> &'a str {
        match self.rangecheck_host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional string file_encoded_sha1 = 9;

    pub fn clear_file_encoded_sha1(&mut self) {
        self.file_encoded_sha1.clear();
    }

    pub fn has_file_encoded_sha1(&self) -> bool {
        self.file_encoded_sha1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_encoded_sha1(&mut self, v: ::std::string::String) {
        self.file_encoded_sha1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_encoded_sha1<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_encoded_sha1.is_none() {
            self.file_encoded_sha1.set_default();
        };
        self.file_encoded_sha1.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_encoded_sha1(&mut self) -> ::std::string::String {
        self.file_encoded_sha1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_encoded_sha1<'a>(&'a self) -> &'a str {
        match self.file_encoded_sha1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSGetUGCDetailsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.url));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.filename));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_creator = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.file_size = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.compressed_file_size = ::std::option::Option::Some(tmp);
                },
                8 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rangecheck_host));
                },
                9 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_encoded_sha1));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.url.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.filename.iter() {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.steamid_creator.is_some() {
            my_size += 9;
        };
        for value in self.file_size.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.compressed_file_size.iter() {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.rangecheck_host.iter() {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in self.file_encoded_sha1.iter() {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.url.as_ref() {
            try!(os.write_string(2, &v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.filename.as_ref() {
            try!(os.write_string(4, &v));
        };
        if let Some(v) = self.steamid_creator {
            try!(os.write_fixed64(5, v));
        };
        if let Some(v) = self.file_size {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.compressed_file_size {
            try!(os.write_uint32(7, v));
        };
        if let Some(v) = self.rangecheck_host.as_ref() {
            try!(os.write_string(8, &v));
        };
        if let Some(v) = self.file_encoded_sha1.as_ref() {
            try!(os.write_string(9, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetUGCDetailsResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetUGCDetailsResponse {
    fn new() -> CMsgClientUFSGetUGCDetailsResponse {
        CMsgClientUFSGetUGCDetailsResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetUGCDetailsResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSGetUGCDetailsResponse::has_eresult,
                    CMsgClientUFSGetUGCDetailsResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "url",
                    CMsgClientUFSGetUGCDetailsResponse::has_url,
                    CMsgClientUFSGetUGCDetailsResponse::get_url,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSGetUGCDetailsResponse::has_app_id,
                    CMsgClientUFSGetUGCDetailsResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "filename",
                    CMsgClientUFSGetUGCDetailsResponse::has_filename,
                    CMsgClientUFSGetUGCDetailsResponse::get_filename,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_creator",
                    CMsgClientUFSGetUGCDetailsResponse::has_steamid_creator,
                    CMsgClientUFSGetUGCDetailsResponse::get_steamid_creator,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "file_size",
                    CMsgClientUFSGetUGCDetailsResponse::has_file_size,
                    CMsgClientUFSGetUGCDetailsResponse::get_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "compressed_file_size",
                    CMsgClientUFSGetUGCDetailsResponse::has_compressed_file_size,
                    CMsgClientUFSGetUGCDetailsResponse::get_compressed_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "rangecheck_host",
                    CMsgClientUFSGetUGCDetailsResponse::has_rangecheck_host,
                    CMsgClientUFSGetUGCDetailsResponse::get_rangecheck_host,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_encoded_sha1",
                    CMsgClientUFSGetUGCDetailsResponse::has_file_encoded_sha1,
                    CMsgClientUFSGetUGCDetailsResponse::get_file_encoded_sha1,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetUGCDetailsResponse>(
                    "CMsgClientUFSGetUGCDetailsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetUGCDetailsResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_url();
        self.clear_app_id();
        self.clear_filename();
        self.clear_steamid_creator();
        self.clear_file_size();
        self.clear_compressed_file_size();
        self.clear_rangecheck_host();
        self.clear_file_encoded_sha1();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetUGCDetailsResponse {
    fn eq(&self, other: &CMsgClientUFSGetUGCDetailsResponse) -> bool {
        self.eresult == other.eresult &&
        self.url == other.url &&
        self.app_id == other.app_id &&
        self.filename == other.filename &&
        self.steamid_creator == other.steamid_creator &&
        self.file_size == other.file_size &&
        self.compressed_file_size == other.compressed_file_size &&
        self.rangecheck_host == other.rangecheck_host &&
        self.file_encoded_sha1 == other.file_encoded_sha1 &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetUGCDetailsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetSingleFileInfo {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetSingleFileInfo {}

impl CMsgClientUFSGetSingleFileInfo {
    pub fn new() -> CMsgClientUFSGetSingleFileInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetSingleFileInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetSingleFileInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetSingleFileInfo {
                    app_id: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string file_name = 2;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetSingleFileInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetSingleFileInfo {
    fn new() -> CMsgClientUFSGetSingleFileInfo {
        CMsgClientUFSGetSingleFileInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetSingleFileInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSGetSingleFileInfo::has_app_id,
                    CMsgClientUFSGetSingleFileInfo::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSGetSingleFileInfo::has_file_name,
                    CMsgClientUFSGetSingleFileInfo::get_file_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetSingleFileInfo>(
                    "CMsgClientUFSGetSingleFileInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetSingleFileInfo {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_file_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetSingleFileInfo {
    fn eq(&self, other: &CMsgClientUFSGetSingleFileInfo) -> bool {
        self.app_id == other.app_id &&
        self.file_name == other.file_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetSingleFileInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSGetSingleFileInfoResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    sha_file: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    time_stamp: ::std::option::Option<u64>,
    raw_file_size: ::std::option::Option<u32>,
    is_explicit_delete: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSGetSingleFileInfoResponse {}

impl CMsgClientUFSGetSingleFileInfoResponse {
    pub fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSGetSingleFileInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSGetSingleFileInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSGetSingleFileInfoResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSGetSingleFileInfoResponse {
                    eresult: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    sha_file: ::protobuf::SingularField::none(),
                    time_stamp: ::std::option::Option::None,
                    raw_file_size: ::std::option::Option::None,
                    is_explicit_delete: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional uint32 app_id = 2;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string file_name = 3;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes sha_file = 4;

    pub fn clear_sha_file(&mut self) {
        self.sha_file.clear();
    }

    pub fn has_sha_file(&self) -> bool {
        self.sha_file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_file(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_file = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_file<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_file.is_none() {
            self.sha_file.set_default();
        };
        self.sha_file.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_file(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_file.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_file<'a>(&'a self) -> &'a [u8] {
        match self.sha_file.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional uint64 time_stamp = 5;

    pub fn clear_time_stamp(&mut self) {
        self.time_stamp = ::std::option::Option::None;
    }

    pub fn has_time_stamp(&self) -> bool {
        self.time_stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_stamp(&mut self, v: u64) {
        self.time_stamp = ::std::option::Option::Some(v);
    }

    pub fn get_time_stamp<'a>(&self) -> u64 {
        self.time_stamp.unwrap_or(0)
    }

    // optional uint32 raw_file_size = 6;

    pub fn clear_raw_file_size(&mut self) {
        self.raw_file_size = ::std::option::Option::None;
    }

    pub fn has_raw_file_size(&self) -> bool {
        self.raw_file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_file_size(&mut self, v: u32) {
        self.raw_file_size = ::std::option::Option::Some(v);
    }

    pub fn get_raw_file_size<'a>(&self) -> u32 {
        self.raw_file_size.unwrap_or(0)
    }

    // optional bool is_explicit_delete = 7;

    pub fn clear_is_explicit_delete(&mut self) {
        self.is_explicit_delete = ::std::option::Option::None;
    }

    pub fn has_is_explicit_delete(&self) -> bool {
        self.is_explicit_delete.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_explicit_delete(&mut self, v: bool) {
        self.is_explicit_delete = ::std::option::Option::Some(v);
    }

    pub fn get_is_explicit_delete<'a>(&self) -> bool {
        self.is_explicit_delete.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientUFSGetSingleFileInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_file));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint64());
                    self.time_stamp = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.raw_file_size = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.is_explicit_delete = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in self.sha_file.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        for value in self.time_stamp.iter() {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.raw_file_size.iter() {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.is_explicit_delete.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.sha_file.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.time_stamp {
            try!(os.write_uint64(5, v));
        };
        if let Some(v) = self.raw_file_size {
            try!(os.write_uint32(6, v));
        };
        if let Some(v) = self.is_explicit_delete {
            try!(os.write_bool(7, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSGetSingleFileInfoResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSGetSingleFileInfoResponse {
    fn new() -> CMsgClientUFSGetSingleFileInfoResponse {
        CMsgClientUFSGetSingleFileInfoResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSGetSingleFileInfoResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSGetSingleFileInfoResponse::has_eresult,
                    CMsgClientUFSGetSingleFileInfoResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSGetSingleFileInfoResponse::has_app_id,
                    CMsgClientUFSGetSingleFileInfoResponse::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSGetSingleFileInfoResponse::has_file_name,
                    CMsgClientUFSGetSingleFileInfoResponse::get_file_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_file",
                    CMsgClientUFSGetSingleFileInfoResponse::has_sha_file,
                    CMsgClientUFSGetSingleFileInfoResponse::get_sha_file,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "time_stamp",
                    CMsgClientUFSGetSingleFileInfoResponse::has_time_stamp,
                    CMsgClientUFSGetSingleFileInfoResponse::get_time_stamp,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "raw_file_size",
                    CMsgClientUFSGetSingleFileInfoResponse::has_raw_file_size,
                    CMsgClientUFSGetSingleFileInfoResponse::get_raw_file_size,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "is_explicit_delete",
                    CMsgClientUFSGetSingleFileInfoResponse::has_is_explicit_delete,
                    CMsgClientUFSGetSingleFileInfoResponse::get_is_explicit_delete,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSGetSingleFileInfoResponse>(
                    "CMsgClientUFSGetSingleFileInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSGetSingleFileInfoResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_app_id();
        self.clear_file_name();
        self.clear_sha_file();
        self.clear_time_stamp();
        self.clear_raw_file_size();
        self.clear_is_explicit_delete();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSGetSingleFileInfoResponse {
    fn eq(&self, other: &CMsgClientUFSGetSingleFileInfoResponse) -> bool {
        self.eresult == other.eresult &&
        self.app_id == other.app_id &&
        self.file_name == other.file_name &&
        self.sha_file == other.sha_file &&
        self.time_stamp == other.time_stamp &&
        self.raw_file_size == other.raw_file_size &&
        self.is_explicit_delete == other.is_explicit_delete &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSGetSingleFileInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSShareFile {
    // message fields
    app_id: ::std::option::Option<u32>,
    file_name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSShareFile {}

impl CMsgClientUFSShareFile {
    pub fn new() -> CMsgClientUFSShareFile {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSShareFile {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSShareFile> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSShareFile,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSShareFile {
                    app_id: ::std::option::Option::None,
                    file_name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 app_id = 1;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }

    // optional string file_name = 2;

    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name.set_default();
        };
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_file_name<'a>(&'a self) -> &'a str {
        match self.file_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.file_name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.file_name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.app_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.file_name.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSShareFile>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSShareFile {
    fn new() -> CMsgClientUFSShareFile {
        CMsgClientUFSShareFile::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSShareFile>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientUFSShareFile::has_app_id,
                    CMsgClientUFSShareFile::get_app_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "file_name",
                    CMsgClientUFSShareFile::has_file_name,
                    CMsgClientUFSShareFile::get_file_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSShareFile>(
                    "CMsgClientUFSShareFile",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSShareFile {
    fn clear(&mut self) {
        self.clear_app_id();
        self.clear_file_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSShareFile {
    fn eq(&self, other: &CMsgClientUFSShareFile) -> bool {
        self.app_id == other.app_id &&
        self.file_name == other.file_name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSShareFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientUFSShareFileResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    hcontent: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientUFSShareFileResponse {}

impl CMsgClientUFSShareFileResponse {
    pub fn new() -> CMsgClientUFSShareFileResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientUFSShareFileResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientUFSShareFileResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientUFSShareFileResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientUFSShareFileResponse {
                    eresult: ::std::option::Option::None,
                    hcontent: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional fixed64 hcontent = 2;

    pub fn clear_hcontent(&mut self) {
        self.hcontent = ::std::option::Option::None;
    }

    pub fn has_hcontent(&self) -> bool {
        self.hcontent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hcontent(&mut self, v: u64) {
        self.hcontent = ::std::option::Option::Some(v);
    }

    pub fn get_hcontent<'a>(&self) -> u64 {
        self.hcontent.unwrap_or(18446744073709551615u64)
    }
}

impl ::protobuf::Message for CMsgClientUFSShareFileResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.hcontent = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.hcontent.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.hcontent {
            try!(os.write_fixed64(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientUFSShareFileResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientUFSShareFileResponse {
    fn new() -> CMsgClientUFSShareFileResponse {
        CMsgClientUFSShareFileResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientUFSShareFileResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientUFSShareFileResponse::has_eresult,
                    CMsgClientUFSShareFileResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "hcontent",
                    CMsgClientUFSShareFileResponse::has_hcontent,
                    CMsgClientUFSShareFileResponse::get_hcontent,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientUFSShareFileResponse>(
                    "CMsgClientUFSShareFileResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientUFSShareFileResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_hcontent();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientUFSShareFileResponse {
    fn eq(&self, other: &CMsgClientUFSShareFileResponse) -> bool {
        self.eresult == other.eresult &&
        self.hcontent == other.hcontent &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientUFSShareFileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientNewLoginKey {
    // message fields
    unique_id: ::std::option::Option<u32>,
    login_key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientNewLoginKey {}

impl CMsgClientNewLoginKey {
    pub fn new() -> CMsgClientNewLoginKey {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientNewLoginKey {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientNewLoginKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientNewLoginKey,
        };
        unsafe {
            instance.get(|| {
                CMsgClientNewLoginKey {
                    unique_id: ::std::option::Option::None,
                    login_key: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 unique_id = 1;

    pub fn clear_unique_id(&mut self) {
        self.unique_id = ::std::option::Option::None;
    }

    pub fn has_unique_id(&self) -> bool {
        self.unique_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: u32) {
        self.unique_id = ::std::option::Option::Some(v);
    }

    pub fn get_unique_id<'a>(&self) -> u32 {
        self.unique_id.unwrap_or(0)
    }

    // optional string login_key = 2;

    pub fn clear_login_key(&mut self) {
        self.login_key.clear();
    }

    pub fn has_login_key(&self) -> bool {
        self.login_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_login_key(&mut self, v: ::std::string::String) {
        self.login_key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_login_key<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.login_key.is_none() {
            self.login_key.set_default();
        };
        self.login_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_login_key(&mut self) -> ::std::string::String {
        self.login_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_login_key<'a>(&'a self) -> &'a str {
        match self.login_key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientNewLoginKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.unique_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.login_key));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.unique_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.login_key.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unique_id {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.login_key.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientNewLoginKey>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientNewLoginKey {
    fn new() -> CMsgClientNewLoginKey {
        CMsgClientNewLoginKey::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientNewLoginKey>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "unique_id",
                    CMsgClientNewLoginKey::has_unique_id,
                    CMsgClientNewLoginKey::get_unique_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "login_key",
                    CMsgClientNewLoginKey::has_login_key,
                    CMsgClientNewLoginKey::get_login_key,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientNewLoginKey>(
                    "CMsgClientNewLoginKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientNewLoginKey {
    fn clear(&mut self) {
        self.clear_unique_id();
        self.clear_login_key();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientNewLoginKey {
    fn eq(&self, other: &CMsgClientNewLoginKey) -> bool {
        self.unique_id == other.unique_id &&
        self.login_key == other.login_key &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientNewLoginKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientNewLoginKeyAccepted {
    // message fields
    unique_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientNewLoginKeyAccepted {}

impl CMsgClientNewLoginKeyAccepted {
    pub fn new() -> CMsgClientNewLoginKeyAccepted {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientNewLoginKeyAccepted {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientNewLoginKeyAccepted> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientNewLoginKeyAccepted,
        };
        unsafe {
            instance.get(|| {
                CMsgClientNewLoginKeyAccepted {
                    unique_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 unique_id = 1;

    pub fn clear_unique_id(&mut self) {
        self.unique_id = ::std::option::Option::None;
    }

    pub fn has_unique_id(&self) -> bool {
        self.unique_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unique_id(&mut self, v: u32) {
        self.unique_id = ::std::option::Option::Some(v);
    }

    pub fn get_unique_id<'a>(&self) -> u32 {
        self.unique_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientNewLoginKeyAccepted {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.unique_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.unique_id.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.unique_id {
            try!(os.write_uint32(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientNewLoginKeyAccepted>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientNewLoginKeyAccepted {
    fn new() -> CMsgClientNewLoginKeyAccepted {
        CMsgClientNewLoginKeyAccepted::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientNewLoginKeyAccepted>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "unique_id",
                    CMsgClientNewLoginKeyAccepted::has_unique_id,
                    CMsgClientNewLoginKeyAccepted::get_unique_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientNewLoginKeyAccepted>(
                    "CMsgClientNewLoginKeyAccepted",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientNewLoginKeyAccepted {
    fn clear(&mut self) {
        self.clear_unique_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientNewLoginKeyAccepted {
    fn eq(&self, other: &CMsgClientNewLoginKeyAccepted) -> bool {
        self.unique_id == other.unique_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientNewLoginKeyAccepted {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetClanOfficers {
    // message fields
    steamid_clan: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetClanOfficers {}

impl CMsgClientAMGetClanOfficers {
    pub fn new() -> CMsgClientAMGetClanOfficers {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetClanOfficers {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetClanOfficers> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetClanOfficers,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetClanOfficers {
                    steamid_clan: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_clan = 1;

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_clan<'a>(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_clan = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_clan.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_clan {
            try!(os.write_fixed64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetClanOfficers>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetClanOfficers {
    fn new() -> CMsgClientAMGetClanOfficers {
        CMsgClientAMGetClanOfficers::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetClanOfficers>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_clan",
                    CMsgClientAMGetClanOfficers::has_steamid_clan,
                    CMsgClientAMGetClanOfficers::get_steamid_clan,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetClanOfficers>(
                    "CMsgClientAMGetClanOfficers",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetClanOfficers {
    fn clear(&mut self) {
        self.clear_steamid_clan();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetClanOfficers {
    fn eq(&self, other: &CMsgClientAMGetClanOfficers) -> bool {
        self.steamid_clan == other.steamid_clan &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetClanOfficers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetClanOfficersResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid_clan: ::std::option::Option<u64>,
    officer_count: ::std::option::Option<i32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetClanOfficersResponse {}

impl CMsgClientAMGetClanOfficersResponse {
    pub fn new() -> CMsgClientAMGetClanOfficersResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetClanOfficersResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetClanOfficersResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetClanOfficersResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetClanOfficersResponse {
                    eresult: ::std::option::Option::None,
                    steamid_clan: ::std::option::Option::None,
                    officer_count: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional fixed64 steamid_clan = 2;

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_clan<'a>(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    // optional int32 officer_count = 3;

    pub fn clear_officer_count(&mut self) {
        self.officer_count = ::std::option::Option::None;
    }

    pub fn has_officer_count(&self) -> bool {
        self.officer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_officer_count(&mut self, v: i32) {
        self.officer_count = ::std::option::Option::Some(v);
    }

    pub fn get_officer_count<'a>(&self) -> i32 {
        self.officer_count.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAMGetClanOfficersResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_clan = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.officer_count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steamid_clan.is_some() {
            my_size += 9;
        };
        for value in self.officer_count.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.steamid_clan {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.officer_count {
            try!(os.write_int32(3, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetClanOfficersResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetClanOfficersResponse {
    fn new() -> CMsgClientAMGetClanOfficersResponse {
        CMsgClientAMGetClanOfficersResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetClanOfficersResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientAMGetClanOfficersResponse::has_eresult,
                    CMsgClientAMGetClanOfficersResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_clan",
                    CMsgClientAMGetClanOfficersResponse::has_steamid_clan,
                    CMsgClientAMGetClanOfficersResponse::get_steamid_clan,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "officer_count",
                    CMsgClientAMGetClanOfficersResponse::has_officer_count,
                    CMsgClientAMGetClanOfficersResponse::get_officer_count,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetClanOfficersResponse>(
                    "CMsgClientAMGetClanOfficersResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetClanOfficersResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_steamid_clan();
        self.clear_officer_count();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetClanOfficersResponse {
    fn eq(&self, other: &CMsgClientAMGetClanOfficersResponse) -> bool {
        self.eresult == other.eresult &&
        self.steamid_clan == other.steamid_clan &&
        self.officer_count == other.officer_count &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetClanOfficersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistory {
    // message fields
    id_count: ::std::option::Option<i32>,
    Ids: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetPersonaNameHistory {}

impl CMsgClientAMGetPersonaNameHistory {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetPersonaNameHistory> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetPersonaNameHistory,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetPersonaNameHistory {
                    id_count: ::std::option::Option::None,
                    Ids: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 id_count = 1;

    pub fn clear_id_count(&mut self) {
        self.id_count = ::std::option::Option::None;
    }

    pub fn has_id_count(&self) -> bool {
        self.id_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id_count(&mut self, v: i32) {
        self.id_count = ::std::option::Option::Some(v);
    }

    pub fn get_id_count<'a>(&self) -> i32 {
        self.id_count.unwrap_or(0)
    }

    // repeated .CMsgClientAMGetPersonaNameHistory.IdInstance Ids = 2;

    pub fn clear_Ids(&mut self) {
        self.Ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ids(&mut self, v: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance>) {
        self.Ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Ids<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance> {
        &mut self.Ids
    }

    // Take field
    pub fn take_Ids(&mut self) -> ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistory_IdInstance> {
        ::std::mem::replace(&mut self.Ids, ::protobuf::RepeatedField::new())
    }

    pub fn get_Ids<'a>(&'a self) -> &'a [CMsgClientAMGetPersonaNameHistory_IdInstance] {
        &self.Ids
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.id_count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Ids));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.id_count.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.Ids.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.id_count {
            try!(os.write_int32(1, v));
        };
        for v in self.Ids.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetPersonaNameHistory>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetPersonaNameHistory {
    fn new() -> CMsgClientAMGetPersonaNameHistory {
        CMsgClientAMGetPersonaNameHistory::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetPersonaNameHistory>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "id_count",
                    CMsgClientAMGetPersonaNameHistory::has_id_count,
                    CMsgClientAMGetPersonaNameHistory::get_id_count,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "Ids",
                    CMsgClientAMGetPersonaNameHistory::get_Ids,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistory>(
                    "CMsgClientAMGetPersonaNameHistory",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistory {
    fn clear(&mut self) {
        self.clear_id_count();
        self.clear_Ids();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetPersonaNameHistory {
    fn eq(&self, other: &CMsgClientAMGetPersonaNameHistory) -> bool {
        self.id_count == other.id_count &&
        self.Ids == other.Ids &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistory_IdInstance {
    // message fields
    steamid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetPersonaNameHistory_IdInstance {}

impl CMsgClientAMGetPersonaNameHistory_IdInstance {
    pub fn new() -> CMsgClientAMGetPersonaNameHistory_IdInstance {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistory_IdInstance {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetPersonaNameHistory_IdInstance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetPersonaNameHistory_IdInstance,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetPersonaNameHistory_IdInstance {
                    steamid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid = 1;

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    pub fn get_steamid<'a>(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            try!(os.write_fixed64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetPersonaNameHistory_IdInstance>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn new() -> CMsgClientAMGetPersonaNameHistory_IdInstance {
        CMsgClientAMGetPersonaNameHistory_IdInstance::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetPersonaNameHistory_IdInstance>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid",
                    CMsgClientAMGetPersonaNameHistory_IdInstance::has_steamid,
                    CMsgClientAMGetPersonaNameHistory_IdInstance::get_steamid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistory_IdInstance>(
                    "CMsgClientAMGetPersonaNameHistory_IdInstance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn clear(&mut self) {
        self.clear_steamid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn eq(&self, other: &CMsgClientAMGetPersonaNameHistory_IdInstance) -> bool {
        self.steamid == other.steamid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistory_IdInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse {
    // message fields
    responses: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetPersonaNameHistoryResponse {}

impl CMsgClientAMGetPersonaNameHistoryResponse {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetPersonaNameHistoryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetPersonaNameHistoryResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetPersonaNameHistoryResponse {
                    responses: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // repeated .CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance responses = 2;

    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }

    pub fn get_responses<'a>(&'a self) -> &'a [CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance] {
        &self.responses
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                2 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.responses.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in self.responses.iter() {
            try!(os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetPersonaNameHistoryResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetPersonaNameHistoryResponse {
    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse {
        CMsgClientAMGetPersonaNameHistoryResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetPersonaNameHistoryResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "responses",
                    CMsgClientAMGetPersonaNameHistoryResponse::get_responses,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistoryResponse>(
                    "CMsgClientAMGetPersonaNameHistoryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse {
    fn clear(&mut self) {
        self.clear_responses();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetPersonaNameHistoryResponse {
    fn eq(&self, other: &CMsgClientAMGetPersonaNameHistoryResponse) -> bool {
        self.responses == other.responses &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    // message fields
    eresult: ::std::option::Option<i32>,
    steamid: ::std::option::Option<u64>,
    names: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {}

impl CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
                    eresult: ::std::option::Option::None,
                    steamid: ::std::option::Option::None,
                    names: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional fixed64 steamid = 2;

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    pub fn get_steamid<'a>(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    // repeated .CMsgClientAMGetPersonaNameHistoryResponse.NameTableInstance.NameInstance names = 3;

    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    pub fn get_names<'a>(&'a self) -> &'a [CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance] {
        &self.names
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.names));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steamid.is_some() {
            my_size += 9;
        };
        for value in self.names.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.steamid {
            try!(os.write_fixed64(2, v));
        };
        for v in self.names.iter() {
            try!(os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
        CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::has_eresult,
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid",
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::has_steamid,
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::get_steamid,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "names",
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance::get_names,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance>(
                    "CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_steamid();
        self.clear_names();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn eq(&self, other: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance) -> bool {
        self.eresult == other.eresult &&
        self.steamid == other.steamid &&
        self.names == other.names &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    // message fields
    name_since: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {}

impl CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    pub fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
                    name_since: ::std::option::Option::None,
                    name: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed32 name_since = 1;

    pub fn clear_name_since(&mut self) {
        self.name_since = ::std::option::Option::None;
    }

    pub fn has_name_since(&self) -> bool {
        self.name_since.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_since(&mut self, v: u32) {
        self.name_since = ::std::option::Option::Some(v);
    }

    pub fn get_name_since<'a>(&self) -> u32 {
        self.name_since.unwrap_or(0)
    }

    // optional string name = 2;

    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        };
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_name<'a>(&'a self) -> &'a str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.name_since = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.name_since.is_some() {
            my_size += 5;
        };
        for value in self.name.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.name_since {
            try!(os.write_fixed32(1, v));
        };
        if let Some(v) = self.name.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn new() -> CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
        CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "name_since",
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::has_name_since,
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::get_name_since,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "name",
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::has_name,
                    CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance::get_name,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance>(
                    "CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn clear(&mut self) {
        self.clear_name_since();
        self.clear_name();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn eq(&self, other: &CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance) -> bool {
        self.name_since == other.name_since &&
        self.name == other.name &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAMGetPersonaNameHistoryResponse_NameTableInstance_NameInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientDeregisterWithServer {
    // message fields
    eservertype: ::std::option::Option<u32>,
    app_id: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientDeregisterWithServer {}

impl CMsgClientDeregisterWithServer {
    pub fn new() -> CMsgClientDeregisterWithServer {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientDeregisterWithServer {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientDeregisterWithServer> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientDeregisterWithServer,
        };
        unsafe {
            instance.get(|| {
                CMsgClientDeregisterWithServer {
                    eservertype: ::std::option::Option::None,
                    app_id: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 eservertype = 1;

    pub fn clear_eservertype(&mut self) {
        self.eservertype = ::std::option::Option::None;
    }

    pub fn has_eservertype(&self) -> bool {
        self.eservertype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eservertype(&mut self, v: u32) {
        self.eservertype = ::std::option::Option::Some(v);
    }

    pub fn get_eservertype<'a>(&self) -> u32 {
        self.eservertype.unwrap_or(0)
    }

    // optional uint32 app_id = 2;

    pub fn clear_app_id(&mut self) {
        self.app_id = ::std::option::Option::None;
    }

    pub fn has_app_id(&self) -> bool {
        self.app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_app_id(&mut self, v: u32) {
        self.app_id = ::std::option::Option::Some(v);
    }

    pub fn get_app_id<'a>(&self) -> u32 {
        self.app_id.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientDeregisterWithServer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.eservertype = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.app_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eservertype.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.app_id.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eservertype {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.app_id {
            try!(os.write_uint32(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientDeregisterWithServer>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientDeregisterWithServer {
    fn new() -> CMsgClientDeregisterWithServer {
        CMsgClientDeregisterWithServer::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientDeregisterWithServer>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "eservertype",
                    CMsgClientDeregisterWithServer::has_eservertype,
                    CMsgClientDeregisterWithServer::get_eservertype,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "app_id",
                    CMsgClientDeregisterWithServer::has_app_id,
                    CMsgClientDeregisterWithServer::get_app_id,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientDeregisterWithServer>(
                    "CMsgClientDeregisterWithServer",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientDeregisterWithServer {
    fn clear(&mut self) {
        self.clear_eservertype();
        self.clear_app_id();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientDeregisterWithServer {
    fn eq(&self, other: &CMsgClientDeregisterWithServer) -> bool {
        self.eservertype == other.eservertype &&
        self.app_id == other.app_id &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientDeregisterWithServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientClanState {
    // message fields
    steamid_clan: ::std::option::Option<u64>,
    m_unStatusFlags: ::std::option::Option<u32>,
    clan_account_flags: ::std::option::Option<u32>,
    name_info: ::protobuf::SingularPtrField<CMsgClientClanState_NameInfo>,
    user_counts: ::protobuf::SingularPtrField<CMsgClientClanState_UserCounts>,
    events: ::protobuf::RepeatedField<CMsgClientClanState_Event>,
    announcements: ::protobuf::RepeatedField<CMsgClientClanState_Event>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientClanState {}

impl CMsgClientClanState {
    pub fn new() -> CMsgClientClanState {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientClanState {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientClanState> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientClanState,
        };
        unsafe {
            instance.get(|| {
                CMsgClientClanState {
                    steamid_clan: ::std::option::Option::None,
                    m_unStatusFlags: ::std::option::Option::None,
                    clan_account_flags: ::std::option::Option::None,
                    name_info: ::protobuf::SingularPtrField::none(),
                    user_counts: ::protobuf::SingularPtrField::none(),
                    events: ::protobuf::RepeatedField::new(),
                    announcements: ::protobuf::RepeatedField::new(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_clan = 1;

    pub fn clear_steamid_clan(&mut self) {
        self.steamid_clan = ::std::option::Option::None;
    }

    pub fn has_steamid_clan(&self) -> bool {
        self.steamid_clan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_clan(&mut self, v: u64) {
        self.steamid_clan = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_clan<'a>(&self) -> u64 {
        self.steamid_clan.unwrap_or(0)
    }

    // optional uint32 m_unStatusFlags = 2;

    pub fn clear_m_unStatusFlags(&mut self) {
        self.m_unStatusFlags = ::std::option::Option::None;
    }

    pub fn has_m_unStatusFlags(&self) -> bool {
        self.m_unStatusFlags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_m_unStatusFlags(&mut self, v: u32) {
        self.m_unStatusFlags = ::std::option::Option::Some(v);
    }

    pub fn get_m_unStatusFlags<'a>(&self) -> u32 {
        self.m_unStatusFlags.unwrap_or(0)
    }

    // optional uint32 clan_account_flags = 3;

    pub fn clear_clan_account_flags(&mut self) {
        self.clan_account_flags = ::std::option::Option::None;
    }

    pub fn has_clan_account_flags(&self) -> bool {
        self.clan_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_account_flags(&mut self, v: u32) {
        self.clan_account_flags = ::std::option::Option::Some(v);
    }

    pub fn get_clan_account_flags<'a>(&self) -> u32 {
        self.clan_account_flags.unwrap_or(0)
    }

    // optional .CMsgClientClanState.NameInfo name_info = 4;

    pub fn clear_name_info(&mut self) {
        self.name_info.clear();
    }

    pub fn has_name_info(&self) -> bool {
        self.name_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_info(&mut self, v: CMsgClientClanState_NameInfo) {
        self.name_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name_info<'a>(&'a mut self) -> &'a mut CMsgClientClanState_NameInfo {
        if self.name_info.is_none() {
            self.name_info.set_default();
        };
        self.name_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_name_info(&mut self) -> CMsgClientClanState_NameInfo {
        self.name_info.take().unwrap_or_else(|| CMsgClientClanState_NameInfo::new())
    }

    pub fn get_name_info<'a>(&'a self) -> &'a CMsgClientClanState_NameInfo {
        self.name_info.as_ref().unwrap_or_else(|| CMsgClientClanState_NameInfo::default_instance())
    }

    // optional .CMsgClientClanState.UserCounts user_counts = 5;

    pub fn clear_user_counts(&mut self) {
        self.user_counts.clear();
    }

    pub fn has_user_counts(&self) -> bool {
        self.user_counts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_counts(&mut self, v: CMsgClientClanState_UserCounts) {
        self.user_counts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_counts<'a>(&'a mut self) -> &'a mut CMsgClientClanState_UserCounts {
        if self.user_counts.is_none() {
            self.user_counts.set_default();
        };
        self.user_counts.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_counts(&mut self) -> CMsgClientClanState_UserCounts {
        self.user_counts.take().unwrap_or_else(|| CMsgClientClanState_UserCounts::new())
    }

    pub fn get_user_counts<'a>(&'a self) -> &'a CMsgClientClanState_UserCounts {
        self.user_counts.as_ref().unwrap_or_else(|| CMsgClientClanState_UserCounts::default_instance())
    }

    // repeated .CMsgClientClanState.Event events = 6;

    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<CMsgClientClanState_Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    pub fn get_events<'a>(&'a self) -> &'a [CMsgClientClanState_Event] {
        &self.events
    }

    // repeated .CMsgClientClanState.Event announcements = 7;

    pub fn clear_announcements(&mut self) {
        self.announcements.clear();
    }

    // Param is passed by value, moved
    pub fn set_announcements(&mut self, v: ::protobuf::RepeatedField<CMsgClientClanState_Event>) {
        self.announcements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_announcements<'a>(&'a mut self) -> &'a mut ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        &mut self.announcements
    }

    // Take field
    pub fn take_announcements(&mut self) -> ::protobuf::RepeatedField<CMsgClientClanState_Event> {
        ::std::mem::replace(&mut self.announcements, ::protobuf::RepeatedField::new())
    }

    pub fn get_announcements<'a>(&'a self) -> &'a [CMsgClientClanState_Event] {
        &self.announcements
    }
}

impl ::protobuf::Message for CMsgClientClanState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_clan = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.m_unStatusFlags = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.clan_account_flags = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name_info));
                },
                5 => {
                    try!(::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.user_counts));
                },
                6 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events));
                },
                7 => {
                    try!(::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.announcements));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_clan.is_some() {
            my_size += 9;
        };
        for value in self.m_unStatusFlags.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.clan_account_flags.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.name_info.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.user_counts.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.events.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in self.announcements.iter() {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_clan {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.m_unStatusFlags {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.clan_account_flags {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.name_info.as_ref() {
            try!(os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        if let Some(v) = self.user_counts.as_ref() {
            try!(os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.events.iter() {
            try!(os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        for v in self.announcements.iter() {
            try!(os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited));
            try!(os.write_raw_varint32(v.get_cached_size()));
            try!(v.write_to_with_cached_sizes(os));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientClanState>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientClanState {
    fn new() -> CMsgClientClanState {
        CMsgClientClanState::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientClanState>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_clan",
                    CMsgClientClanState::has_steamid_clan,
                    CMsgClientClanState::get_steamid_clan,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "m_unStatusFlags",
                    CMsgClientClanState::has_m_unStatusFlags,
                    CMsgClientClanState::get_m_unStatusFlags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "clan_account_flags",
                    CMsgClientClanState::has_clan_account_flags,
                    CMsgClientClanState::get_clan_account_flags,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "name_info",
                    CMsgClientClanState::has_name_info,
                    CMsgClientClanState::get_name_info,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor(
                    "user_counts",
                    CMsgClientClanState::has_user_counts,
                    CMsgClientClanState::get_user_counts,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "events",
                    CMsgClientClanState::get_events,
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_message_accessor(
                    "announcements",
                    CMsgClientClanState::get_announcements,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientClanState>(
                    "CMsgClientClanState",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientClanState {
    fn clear(&mut self) {
        self.clear_steamid_clan();
        self.clear_m_unStatusFlags();
        self.clear_clan_account_flags();
        self.clear_name_info();
        self.clear_user_counts();
        self.clear_events();
        self.clear_announcements();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientClanState {
    fn eq(&self, other: &CMsgClientClanState) -> bool {
        self.steamid_clan == other.steamid_clan &&
        self.m_unStatusFlags == other.m_unStatusFlags &&
        self.clan_account_flags == other.clan_account_flags &&
        self.name_info == other.name_info &&
        self.user_counts == other.user_counts &&
        self.events == other.events &&
        self.announcements == other.announcements &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientClanState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientClanState_NameInfo {
    // message fields
    clan_name: ::protobuf::SingularField<::std::string::String>,
    sha_avatar: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientClanState_NameInfo {}

impl CMsgClientClanState_NameInfo {
    pub fn new() -> CMsgClientClanState_NameInfo {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientClanState_NameInfo {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientClanState_NameInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientClanState_NameInfo,
        };
        unsafe {
            instance.get(|| {
                CMsgClientClanState_NameInfo {
                    clan_name: ::protobuf::SingularField::none(),
                    sha_avatar: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional string clan_name = 1;

    pub fn clear_clan_name(&mut self) {
        self.clan_name.clear();
    }

    pub fn has_clan_name(&self) -> bool {
        self.clan_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_name(&mut self, v: ::std::string::String) {
        self.clan_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clan_name<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.clan_name.is_none() {
            self.clan_name.set_default();
        };
        self.clan_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_clan_name(&mut self) -> ::std::string::String {
        self.clan_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_clan_name<'a>(&'a self) -> &'a str {
        match self.clan_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional bytes sha_avatar = 2;

    pub fn clear_sha_avatar(&mut self) {
        self.sha_avatar.clear();
    }

    pub fn has_sha_avatar(&self) -> bool {
        self.sha_avatar.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sha_avatar(&mut self, v: ::std::vec::Vec<u8>) {
        self.sha_avatar = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sha_avatar<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.sha_avatar.is_none() {
            self.sha_avatar.set_default();
        };
        self.sha_avatar.as_mut().unwrap()
    }

    // Take field
    pub fn take_sha_avatar(&mut self) -> ::std::vec::Vec<u8> {
        self.sha_avatar.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_sha_avatar<'a>(&'a self) -> &'a [u8] {
        match self.sha_avatar.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
}

impl ::protobuf::Message for CMsgClientClanState_NameInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clan_name));
                },
                2 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.sha_avatar));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.clan_name.iter() {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in self.sha_avatar.iter() {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clan_name.as_ref() {
            try!(os.write_string(1, &v));
        };
        if let Some(v) = self.sha_avatar.as_ref() {
            try!(os.write_bytes(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientClanState_NameInfo>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientClanState_NameInfo {
    fn new() -> CMsgClientClanState_NameInfo {
        CMsgClientClanState_NameInfo::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientClanState_NameInfo>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "clan_name",
                    CMsgClientClanState_NameInfo::has_clan_name,
                    CMsgClientClanState_NameInfo::get_clan_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "sha_avatar",
                    CMsgClientClanState_NameInfo::has_sha_avatar,
                    CMsgClientClanState_NameInfo::get_sha_avatar,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientClanState_NameInfo>(
                    "CMsgClientClanState_NameInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientClanState_NameInfo {
    fn clear(&mut self) {
        self.clear_clan_name();
        self.clear_sha_avatar();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientClanState_NameInfo {
    fn eq(&self, other: &CMsgClientClanState_NameInfo) -> bool {
        self.clan_name == other.clan_name &&
        self.sha_avatar == other.sha_avatar &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientClanState_NameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientClanState_UserCounts {
    // message fields
    members: ::std::option::Option<u32>,
    online: ::std::option::Option<u32>,
    chatting: ::std::option::Option<u32>,
    in_game: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientClanState_UserCounts {}

impl CMsgClientClanState_UserCounts {
    pub fn new() -> CMsgClientClanState_UserCounts {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientClanState_UserCounts {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientClanState_UserCounts> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientClanState_UserCounts,
        };
        unsafe {
            instance.get(|| {
                CMsgClientClanState_UserCounts {
                    members: ::std::option::Option::None,
                    online: ::std::option::Option::None,
                    chatting: ::std::option::Option::None,
                    in_game: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional uint32 members = 1;

    pub fn clear_members(&mut self) {
        self.members = ::std::option::Option::None;
    }

    pub fn has_members(&self) -> bool {
        self.members.is_some()
    }

    // Param is passed by value, moved
    pub fn set_members(&mut self, v: u32) {
        self.members = ::std::option::Option::Some(v);
    }

    pub fn get_members<'a>(&self) -> u32 {
        self.members.unwrap_or(0)
    }

    // optional uint32 online = 2;

    pub fn clear_online(&mut self) {
        self.online = ::std::option::Option::None;
    }

    pub fn has_online(&self) -> bool {
        self.online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_online(&mut self, v: u32) {
        self.online = ::std::option::Option::Some(v);
    }

    pub fn get_online<'a>(&self) -> u32 {
        self.online.unwrap_or(0)
    }

    // optional uint32 chatting = 3;

    pub fn clear_chatting(&mut self) {
        self.chatting = ::std::option::Option::None;
    }

    pub fn has_chatting(&self) -> bool {
        self.chatting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chatting(&mut self, v: u32) {
        self.chatting = ::std::option::Option::Some(v);
    }

    pub fn get_chatting<'a>(&self) -> u32 {
        self.chatting.unwrap_or(0)
    }

    // optional uint32 in_game = 4;

    pub fn clear_in_game(&mut self) {
        self.in_game = ::std::option::Option::None;
    }

    pub fn has_in_game(&self) -> bool {
        self.in_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_game(&mut self, v: u32) {
        self.in_game = ::std::option::Option::Some(v);
    }

    pub fn get_in_game<'a>(&self) -> u32 {
        self.in_game.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientClanState_UserCounts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.members = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.online = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.chatting = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.in_game = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.members.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.online.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.chatting.iter() {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.in_game.iter() {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.members {
            try!(os.write_uint32(1, v));
        };
        if let Some(v) = self.online {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.chatting {
            try!(os.write_uint32(3, v));
        };
        if let Some(v) = self.in_game {
            try!(os.write_uint32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientClanState_UserCounts>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientClanState_UserCounts {
    fn new() -> CMsgClientClanState_UserCounts {
        CMsgClientClanState_UserCounts::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientClanState_UserCounts>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "members",
                    CMsgClientClanState_UserCounts::has_members,
                    CMsgClientClanState_UserCounts::get_members,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "online",
                    CMsgClientClanState_UserCounts::has_online,
                    CMsgClientClanState_UserCounts::get_online,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "chatting",
                    CMsgClientClanState_UserCounts::has_chatting,
                    CMsgClientClanState_UserCounts::get_chatting,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "in_game",
                    CMsgClientClanState_UserCounts::has_in_game,
                    CMsgClientClanState_UserCounts::get_in_game,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientClanState_UserCounts>(
                    "CMsgClientClanState_UserCounts",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientClanState_UserCounts {
    fn clear(&mut self) {
        self.clear_members();
        self.clear_online();
        self.clear_chatting();
        self.clear_in_game();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientClanState_UserCounts {
    fn eq(&self, other: &CMsgClientClanState_UserCounts) -> bool {
        self.members == other.members &&
        self.online == other.online &&
        self.chatting == other.chatting &&
        self.in_game == other.in_game &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientClanState_UserCounts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientClanState_Event {
    // message fields
    gid: ::std::option::Option<u64>,
    event_time: ::std::option::Option<u32>,
    headline: ::protobuf::SingularField<::std::string::String>,
    game_id: ::std::option::Option<u64>,
    just_posted: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientClanState_Event {}

impl CMsgClientClanState_Event {
    pub fn new() -> CMsgClientClanState_Event {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientClanState_Event {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientClanState_Event> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientClanState_Event,
        };
        unsafe {
            instance.get(|| {
                CMsgClientClanState_Event {
                    gid: ::std::option::Option::None,
                    event_time: ::std::option::Option::None,
                    headline: ::protobuf::SingularField::none(),
                    game_id: ::std::option::Option::None,
                    just_posted: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 gid = 1;

    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    pub fn get_gid<'a>(&self) -> u64 {
        self.gid.unwrap_or(0)
    }

    // optional uint32 event_time = 2;

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u32) {
        self.event_time = ::std::option::Option::Some(v);
    }

    pub fn get_event_time<'a>(&self) -> u32 {
        self.event_time.unwrap_or(0)
    }

    // optional string headline = 3;

    pub fn clear_headline(&mut self) {
        self.headline.clear();
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.headline.is_none() {
            self.headline.set_default();
        };
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_headline<'a>(&'a self) -> &'a str {
        match self.headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }

    // optional fixed64 game_id = 4;

    pub fn clear_game_id(&mut self) {
        self.game_id = ::std::option::Option::None;
    }

    pub fn has_game_id(&self) -> bool {
        self.game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_id(&mut self, v: u64) {
        self.game_id = ::std::option::Option::Some(v);
    }

    pub fn get_game_id<'a>(&self) -> u64 {
        self.game_id.unwrap_or(0)
    }

    // optional bool just_posted = 5;

    pub fn clear_just_posted(&mut self) {
        self.just_posted = ::std::option::Option::None;
    }

    pub fn has_just_posted(&self) -> bool {
        self.just_posted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_just_posted(&mut self, v: bool) {
        self.just_posted = ::std::option::Option::Some(v);
    }

    pub fn get_just_posted<'a>(&self) -> bool {
        self.just_posted.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientClanState_Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.gid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_uint32());
                    self.event_time = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.game_id = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.just_posted = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gid.is_some() {
            my_size += 9;
        };
        for value in self.event_time.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.headline.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if self.game_id.is_some() {
            my_size += 9;
        };
        if self.just_posted.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.event_time {
            try!(os.write_uint32(2, v));
        };
        if let Some(v) = self.headline.as_ref() {
            try!(os.write_string(3, &v));
        };
        if let Some(v) = self.game_id {
            try!(os.write_fixed64(4, v));
        };
        if let Some(v) = self.just_posted {
            try!(os.write_bool(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientClanState_Event>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientClanState_Event {
    fn new() -> CMsgClientClanState_Event {
        CMsgClientClanState_Event::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientClanState_Event>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "gid",
                    CMsgClientClanState_Event::has_gid,
                    CMsgClientClanState_Event::get_gid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "event_time",
                    CMsgClientClanState_Event::has_event_time,
                    CMsgClientClanState_Event::get_event_time,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "headline",
                    CMsgClientClanState_Event::has_headline,
                    CMsgClientClanState_Event::get_headline,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "game_id",
                    CMsgClientClanState_Event::has_game_id,
                    CMsgClientClanState_Event::get_game_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "just_posted",
                    CMsgClientClanState_Event::has_just_posted,
                    CMsgClientClanState_Event::get_just_posted,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientClanState_Event>(
                    "CMsgClientClanState_Event",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientClanState_Event {
    fn clear(&mut self) {
        self.clear_gid();
        self.clear_event_time();
        self.clear_headline();
        self.clear_game_id();
        self.clear_just_posted();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientClanState_Event {
    fn eq(&self, other: &CMsgClientClanState_Event) -> bool {
        self.gid == other.gid &&
        self.event_time == other.event_time &&
        self.headline == other.headline &&
        self.game_id == other.game_id &&
        self.just_posted == other.just_posted &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientClanState_Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendMsg {
    // message fields
    steamid: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendMsg {}

impl CMsgClientFriendMsg {
    pub fn new() -> CMsgClientFriendMsg {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendMsg {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendMsg> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendMsg,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendMsg {
                    steamid: ::std::option::Option::None,
                    chat_entry_type: ::std::option::Option::None,
                    message: ::protobuf::SingularField::none(),
                    rtime32_server_timestamp: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid = 1;

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    pub fn get_steamid<'a>(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    // optional int32 chat_entry_type = 2;

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    pub fn get_chat_entry_type<'a>(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    // optional bytes message = 3;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a [u8] {
        match self.message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional fixed32 rtime32_server_timestamp = 4;

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_rtime32_server_timestamp<'a>(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientFriendMsg {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.chat_entry_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.rtime32_server_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid.is_some() {
            my_size += 9;
        };
        for value in self.chat_entry_type.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if self.rtime32_server_timestamp.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.chat_entry_type {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_bytes(3, &v));
        };
        if let Some(v) = self.rtime32_server_timestamp {
            try!(os.write_fixed32(4, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendMsg>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendMsg {
    fn new() -> CMsgClientFriendMsg {
        CMsgClientFriendMsg::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendMsg>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid",
                    CMsgClientFriendMsg::has_steamid,
                    CMsgClientFriendMsg::get_steamid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "chat_entry_type",
                    CMsgClientFriendMsg::has_chat_entry_type,
                    CMsgClientFriendMsg::get_chat_entry_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "message",
                    CMsgClientFriendMsg::has_message,
                    CMsgClientFriendMsg::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "rtime32_server_timestamp",
                    CMsgClientFriendMsg::has_rtime32_server_timestamp,
                    CMsgClientFriendMsg::get_rtime32_server_timestamp,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendMsg>(
                    "CMsgClientFriendMsg",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendMsg {
    fn clear(&mut self) {
        self.clear_steamid();
        self.clear_chat_entry_type();
        self.clear_message();
        self.clear_rtime32_server_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendMsg {
    fn eq(&self, other: &CMsgClientFriendMsg) -> bool {
        self.steamid == other.steamid &&
        self.chat_entry_type == other.chat_entry_type &&
        self.message == other.message &&
        self.rtime32_server_timestamp == other.rtime32_server_timestamp &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientFriendMsgIncoming {
    // message fields
    steamid_from: ::std::option::Option<u64>,
    chat_entry_type: ::std::option::Option<i32>,
    from_limited_account: ::std::option::Option<bool>,
    message: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    rtime32_server_timestamp: ::std::option::Option<u32>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientFriendMsgIncoming {}

impl CMsgClientFriendMsgIncoming {
    pub fn new() -> CMsgClientFriendMsgIncoming {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientFriendMsgIncoming {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientFriendMsgIncoming> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientFriendMsgIncoming,
        };
        unsafe {
            instance.get(|| {
                CMsgClientFriendMsgIncoming {
                    steamid_from: ::std::option::Option::None,
                    chat_entry_type: ::std::option::Option::None,
                    from_limited_account: ::std::option::Option::None,
                    message: ::protobuf::SingularField::none(),
                    rtime32_server_timestamp: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_from = 1;

    pub fn clear_steamid_from(&mut self) {
        self.steamid_from = ::std::option::Option::None;
    }

    pub fn has_steamid_from(&self) -> bool {
        self.steamid_from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_from(&mut self, v: u64) {
        self.steamid_from = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_from<'a>(&self) -> u64 {
        self.steamid_from.unwrap_or(0)
    }

    // optional int32 chat_entry_type = 2;

    pub fn clear_chat_entry_type(&mut self) {
        self.chat_entry_type = ::std::option::Option::None;
    }

    pub fn has_chat_entry_type(&self) -> bool {
        self.chat_entry_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_entry_type(&mut self, v: i32) {
        self.chat_entry_type = ::std::option::Option::Some(v);
    }

    pub fn get_chat_entry_type<'a>(&self) -> i32 {
        self.chat_entry_type.unwrap_or(0)
    }

    // optional bool from_limited_account = 3;

    pub fn clear_from_limited_account(&mut self) {
        self.from_limited_account = ::std::option::Option::None;
    }

    pub fn has_from_limited_account(&self) -> bool {
        self.from_limited_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_limited_account(&mut self, v: bool) {
        self.from_limited_account = ::std::option::Option::Some(v);
    }

    pub fn get_from_limited_account<'a>(&self) -> bool {
        self.from_limited_account.unwrap_or(false)
    }

    // optional bytes message = 4;

    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message<'a>(&'a mut self) -> &'a mut ::std::vec::Vec<u8> {
        if self.message.is_none() {
            self.message.set_default();
        };
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        self.message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    pub fn get_message<'a>(&'a self) -> &'a [u8] {
        match self.message.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }

    // optional fixed32 rtime32_server_timestamp = 5;

    pub fn clear_rtime32_server_timestamp(&mut self) {
        self.rtime32_server_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_server_timestamp(&self) -> bool {
        self.rtime32_server_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_server_timestamp(&mut self, v: u32) {
        self.rtime32_server_timestamp = ::std::option::Option::Some(v);
    }

    pub fn get_rtime32_server_timestamp<'a>(&self) -> u32 {
        self.rtime32_server_timestamp.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientFriendMsgIncoming {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_from = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.chat_entry_type = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.from_limited_account = ::std::option::Option::Some(tmp);
                },
                4 => {
                    try!(::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed32());
                    self.rtime32_server_timestamp = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_from.is_some() {
            my_size += 9;
        };
        for value in self.chat_entry_type.iter() {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.from_limited_account.is_some() {
            my_size += 2;
        };
        for value in self.message.iter() {
            my_size += ::protobuf::rt::bytes_size(4, &value);
        };
        if self.rtime32_server_timestamp.is_some() {
            my_size += 5;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_from {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.chat_entry_type {
            try!(os.write_int32(2, v));
        };
        if let Some(v) = self.from_limited_account {
            try!(os.write_bool(3, v));
        };
        if let Some(v) = self.message.as_ref() {
            try!(os.write_bytes(4, &v));
        };
        if let Some(v) = self.rtime32_server_timestamp {
            try!(os.write_fixed32(5, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientFriendMsgIncoming>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientFriendMsgIncoming {
    fn new() -> CMsgClientFriendMsgIncoming {
        CMsgClientFriendMsgIncoming::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientFriendMsgIncoming>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_from",
                    CMsgClientFriendMsgIncoming::has_steamid_from,
                    CMsgClientFriendMsgIncoming::get_steamid_from,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "chat_entry_type",
                    CMsgClientFriendMsgIncoming::has_chat_entry_type,
                    CMsgClientFriendMsgIncoming::get_chat_entry_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "from_limited_account",
                    CMsgClientFriendMsgIncoming::has_from_limited_account,
                    CMsgClientFriendMsgIncoming::get_from_limited_account,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor(
                    "message",
                    CMsgClientFriendMsgIncoming::has_message,
                    CMsgClientFriendMsgIncoming::get_message,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor(
                    "rtime32_server_timestamp",
                    CMsgClientFriendMsgIncoming::has_rtime32_server_timestamp,
                    CMsgClientFriendMsgIncoming::get_rtime32_server_timestamp,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientFriendMsgIncoming>(
                    "CMsgClientFriendMsgIncoming",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientFriendMsgIncoming {
    fn clear(&mut self) {
        self.clear_steamid_from();
        self.clear_chat_entry_type();
        self.clear_from_limited_account();
        self.clear_message();
        self.clear_rtime32_server_timestamp();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientFriendMsgIncoming {
    fn eq(&self, other: &CMsgClientFriendMsgIncoming) -> bool {
        self.steamid_from == other.steamid_from &&
        self.chat_entry_type == other.chat_entry_type &&
        self.from_limited_account == other.from_limited_account &&
        self.message == other.message &&
        self.rtime32_server_timestamp == other.rtime32_server_timestamp &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientFriendMsgIncoming {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAddFriend {
    // message fields
    steamid_to_add: ::std::option::Option<u64>,
    accountname_or_email_to_add: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAddFriend {}

impl CMsgClientAddFriend {
    pub fn new() -> CMsgClientAddFriend {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAddFriend {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAddFriend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAddFriend,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAddFriend {
                    steamid_to_add: ::std::option::Option::None,
                    accountname_or_email_to_add: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 steamid_to_add = 1;

    pub fn clear_steamid_to_add(&mut self) {
        self.steamid_to_add = ::std::option::Option::None;
    }

    pub fn has_steamid_to_add(&self) -> bool {
        self.steamid_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid_to_add(&mut self, v: u64) {
        self.steamid_to_add = ::std::option::Option::Some(v);
    }

    pub fn get_steamid_to_add<'a>(&self) -> u64 {
        self.steamid_to_add.unwrap_or(0)
    }

    // optional string accountname_or_email_to_add = 2;

    pub fn clear_accountname_or_email_to_add(&mut self) {
        self.accountname_or_email_to_add.clear();
    }

    pub fn has_accountname_or_email_to_add(&self) -> bool {
        self.accountname_or_email_to_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountname_or_email_to_add(&mut self, v: ::std::string::String) {
        self.accountname_or_email_to_add = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountname_or_email_to_add<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.accountname_or_email_to_add.is_none() {
            self.accountname_or_email_to_add.set_default();
        };
        self.accountname_or_email_to_add.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountname_or_email_to_add(&mut self) -> ::std::string::String {
        self.accountname_or_email_to_add.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_accountname_or_email_to_add<'a>(&'a self) -> &'a str {
        match self.accountname_or_email_to_add.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientAddFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steamid_to_add = ::std::option::Option::Some(tmp);
                },
                2 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.accountname_or_email_to_add));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.steamid_to_add.is_some() {
            my_size += 9;
        };
        for value in self.accountname_or_email_to_add.iter() {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid_to_add {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.accountname_or_email_to_add.as_ref() {
            try!(os.write_string(2, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAddFriend>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAddFriend {
    fn new() -> CMsgClientAddFriend {
        CMsgClientAddFriend::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAddFriend>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steamid_to_add",
                    CMsgClientAddFriend::has_steamid_to_add,
                    CMsgClientAddFriend::get_steamid_to_add,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "accountname_or_email_to_add",
                    CMsgClientAddFriend::has_accountname_or_email_to_add,
                    CMsgClientAddFriend::get_accountname_or_email_to_add,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAddFriend>(
                    "CMsgClientAddFriend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAddFriend {
    fn clear(&mut self) {
        self.clear_steamid_to_add();
        self.clear_accountname_or_email_to_add();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAddFriend {
    fn eq(&self, other: &CMsgClientAddFriend) -> bool {
        self.steamid_to_add == other.steamid_to_add &&
        self.accountname_or_email_to_add == other.accountname_or_email_to_add &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientAddFriendResponse {
    // message fields
    eresult: ::std::option::Option<i32>,
    steam_id_added: ::std::option::Option<u64>,
    persona_name_added: ::protobuf::SingularField<::std::string::String>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientAddFriendResponse {}

impl CMsgClientAddFriendResponse {
    pub fn new() -> CMsgClientAddFriendResponse {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientAddFriendResponse {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientAddFriendResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientAddFriendResponse,
        };
        unsafe {
            instance.get(|| {
                CMsgClientAddFriendResponse {
                    eresult: ::std::option::Option::None,
                    steam_id_added: ::std::option::Option::None,
                    persona_name_added: ::protobuf::SingularField::none(),
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional int32 eresult = 1;

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    pub fn get_eresult<'a>(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    // optional fixed64 steam_id_added = 2;

    pub fn clear_steam_id_added(&mut self) {
        self.steam_id_added = ::std::option::Option::None;
    }

    pub fn has_steam_id_added(&self) -> bool {
        self.steam_id_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id_added(&mut self, v: u64) {
        self.steam_id_added = ::std::option::Option::Some(v);
    }

    pub fn get_steam_id_added<'a>(&self) -> u64 {
        self.steam_id_added.unwrap_or(0)
    }

    // optional string persona_name_added = 3;

    pub fn clear_persona_name_added(&mut self) {
        self.persona_name_added.clear();
    }

    pub fn has_persona_name_added(&self) -> bool {
        self.persona_name_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persona_name_added(&mut self, v: ::std::string::String) {
        self.persona_name_added = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persona_name_added<'a>(&'a mut self) -> &'a mut ::std::string::String {
        if self.persona_name_added.is_none() {
            self.persona_name_added.set_default();
        };
        self.persona_name_added.as_mut().unwrap()
    }

    // Take field
    pub fn take_persona_name_added(&mut self) -> ::std::string::String {
        self.persona_name_added.take().unwrap_or_else(|| ::std::string::String::new())
    }

    pub fn get_persona_name_added<'a>(&'a self) -> &'a str {
        match self.persona_name_added.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
}

impl ::protobuf::Message for CMsgClientAddFriendResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_int32());
                    self.eresult = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.steam_id_added = ::std::option::Option::Some(tmp);
                },
                3 => {
                    try!(::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persona_name_added));
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in self.eresult.iter() {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.steam_id_added.is_some() {
            my_size += 9;
        };
        for value in self.persona_name_added.iter() {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.eresult {
            try!(os.write_int32(1, v));
        };
        if let Some(v) = self.steam_id_added {
            try!(os.write_fixed64(2, v));
        };
        if let Some(v) = self.persona_name_added.as_ref() {
            try!(os.write_string(3, &v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientAddFriendResponse>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientAddFriendResponse {
    fn new() -> CMsgClientAddFriendResponse {
        CMsgClientAddFriendResponse::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientAddFriendResponse>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_i32_accessor(
                    "eresult",
                    CMsgClientAddFriendResponse::has_eresult,
                    CMsgClientAddFriendResponse::get_eresult,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "steam_id_added",
                    CMsgClientAddFriendResponse::has_steam_id_added,
                    CMsgClientAddFriendResponse::get_steam_id_added,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_string_accessor(
                    "persona_name_added",
                    CMsgClientAddFriendResponse::has_persona_name_added,
                    CMsgClientAddFriendResponse::get_persona_name_added,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientAddFriendResponse>(
                    "CMsgClientAddFriendResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientAddFriendResponse {
    fn clear(&mut self) {
        self.clear_eresult();
        self.clear_steam_id_added();
        self.clear_persona_name_added();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientAddFriendResponse {
    fn eq(&self, other: &CMsgClientAddFriendResponse) -> bool {
        self.eresult == other.eresult &&
        self.steam_id_added == other.steam_id_added &&
        self.persona_name_added == other.persona_name_added &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientAddFriendResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientRemoveFriend {
    // message fields
    friendid: ::std::option::Option<u64>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientRemoveFriend {}

impl CMsgClientRemoveFriend {
    pub fn new() -> CMsgClientRemoveFriend {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientRemoveFriend {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientRemoveFriend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientRemoveFriend,
        };
        unsafe {
            instance.get(|| {
                CMsgClientRemoveFriend {
                    friendid: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 friendid = 1;

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    pub fn get_friendid<'a>(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }
}

impl ::protobuf::Message for CMsgClientRemoveFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.friendid = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.friendid.is_some() {
            my_size += 9;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            try!(os.write_fixed64(1, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientRemoveFriend>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientRemoveFriend {
    fn new() -> CMsgClientRemoveFriend {
        CMsgClientRemoveFriend::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientRemoveFriend>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "friendid",
                    CMsgClientRemoveFriend::has_friendid,
                    CMsgClientRemoveFriend::get_friendid,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientRemoveFriend>(
                    "CMsgClientRemoveFriend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientRemoveFriend {
    fn clear(&mut self) {
        self.clear_friendid();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientRemoveFriend {
    fn eq(&self, other: &CMsgClientRemoveFriend) -> bool {
        self.friendid == other.friendid &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientRemoveFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

#[derive(Clone,Default)]
pub struct CMsgClientHideFriend {
    // message fields
    friendid: ::std::option::Option<u64>,
    hide: ::std::option::Option<bool>,
    // special fields
    unknown_fields: ::protobuf::UnknownFields,
    cached_size: ::std::cell::Cell<u32>,
}

// see codegen.rs for the explanation why impl Sync explicitly
unsafe impl ::std::marker::Sync for CMsgClientHideFriend {}

impl CMsgClientHideFriend {
    pub fn new() -> CMsgClientHideFriend {
        ::std::default::Default::default()
    }

    pub fn default_instance() -> &'static CMsgClientHideFriend {
        static mut instance: ::protobuf::lazy::Lazy<CMsgClientHideFriend> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CMsgClientHideFriend,
        };
        unsafe {
            instance.get(|| {
                CMsgClientHideFriend {
                    friendid: ::std::option::Option::None,
                    hide: ::std::option::Option::None,
                    unknown_fields: ::protobuf::UnknownFields::new(),
                    cached_size: ::std::cell::Cell::new(0),
                }
            })
        }
    }

    // optional fixed64 friendid = 1;

    pub fn clear_friendid(&mut self) {
        self.friendid = ::std::option::Option::None;
    }

    pub fn has_friendid(&self) -> bool {
        self.friendid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendid(&mut self, v: u64) {
        self.friendid = ::std::option::Option::Some(v);
    }

    pub fn get_friendid<'a>(&self) -> u64 {
        self.friendid.unwrap_or(0)
    }

    // optional bool hide = 2;

    pub fn clear_hide(&mut self) {
        self.hide = ::std::option::Option::None;
    }

    pub fn has_hide(&self) -> bool {
        self.hide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hide(&mut self, v: bool) {
        self.hide = ::std::option::Option::Some(v);
    }

    pub fn get_hide<'a>(&self) -> bool {
        self.hide.unwrap_or(false)
    }
}

impl ::protobuf::Message for CMsgClientHideFriend {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !try!(is.eof()) {
            let (field_number, wire_type) = try!(is.read_tag_unpack());
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_fixed64());
                    self.friendid = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    };
                    let tmp = try!(is.read_bool());
                    self.hide = ::std::option::Option::Some(tmp);
                },
                _ => {
                    try!(::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields()));
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.friendid.is_some() {
            my_size += 9;
        };
        if self.hide.is_some() {
            my_size += 2;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.friendid {
            try!(os.write_fixed64(1, v));
        };
        if let Some(v) = self.hide {
            try!(os.write_bool(2, v));
        };
        try!(os.write_unknown_fields(self.get_unknown_fields()));
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields<'s>(&'s self) -> &'s ::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields<'s>(&'s mut self) -> &'s mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn type_id(&self) -> ::std::any::TypeId {
        ::std::any::TypeId::of::<CMsgClientHideFriend>()
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        ::protobuf::MessageStatic::descriptor_static(None::<Self>)
    }
}

impl ::protobuf::MessageStatic for CMsgClientHideFriend {
    fn new() -> CMsgClientHideFriend {
        CMsgClientHideFriend::new()
    }

    fn descriptor_static(_: ::std::option::Option<CMsgClientHideFriend>) -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_u64_accessor(
                    "friendid",
                    CMsgClientHideFriend::has_friendid,
                    CMsgClientHideFriend::get_friendid,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor(
                    "hide",
                    CMsgClientHideFriend::has_hide,
                    CMsgClientHideFriend::get_hide,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CMsgClientHideFriend>(
                    "CMsgClientHideFriend",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }
}

impl ::protobuf::Clear for CMsgClientHideFriend {
    fn clear(&mut self) {
        self.clear_friendid();
        self.clear_hide();
        self.unknown_fields.clear();
    }
}

impl ::std::cmp::PartialEq for CMsgClientHideFriend {
    fn eq(&self, other: &CMsgClientHideFriend) -> bool {
        self.friendid == other.friendid &&
        self.hide == other.hide &&
        self.unknown_fields == other.unknown_fields
    }
}

impl ::std::fmt::Debug for CMsgClientHideFriend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

static file_descriptor_proto_data: &'static [u8] = &[
    0x0a, 0x20, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x73, 0x5f,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f,
    0x74, 0x6f, 0x1a, 0x18, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
    0x73, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1a, 0x65, 0x6e,
    0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x74, 0x69, 0x63, 0x6b,
    0x65, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x15, 0x0a, 0x13, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x48, 0x65, 0x61, 0x72, 0x74, 0x42, 0x65, 0x61, 0x74, 0x22,
    0x47, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x44, 0x53,
    0x50, 0x32, 0x50, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x72, 0x74, 0x65,
    0x64, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x72, 0x65, 0x6d,
    0x6f, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70,
    0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x22, 0x81, 0x02, 0x0a, 0x1c, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x44, 0x53, 0x50, 0x32, 0x50, 0x53, 0x65, 0x73,
    0x73, 0x69, 0x6f, 0x6e, 0x45, 0x6e, 0x64, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x69, 0x64, 0x5f, 0x72, 0x65, 0x6d, 0x6f, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x1a, 0x0a, 0x12, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x6c, 0x65, 0x6e, 0x67,
    0x74, 0x68, 0x5f, 0x73, 0x65, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x15, 0x0a, 0x0d,
    0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x6e, 0x61, 0x74, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x72, 0x65,
    0x63, 0x76, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x05, 0x12, 0x18, 0x0a, 0x10,
    0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x6c, 0x61, 0x79,
    0x18, 0x08, 0x20, 0x01, 0x28, 0x05, 0x12, 0x18, 0x0a, 0x10, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f,
    0x72, 0x65, 0x63, 0x76, 0x5f, 0x72, 0x65, 0x6c, 0x61, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x1a, 0x0a, 0x12, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x74, 0x6f, 0x5f, 0x63, 0x6f, 0x6e, 0x6e,
    0x65, 0x63, 0x74, 0x5f, 0x6d, 0x73, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x22, 0x6a, 0x0a, 0x22,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74,
    0x65, 0x72, 0x41, 0x75, 0x74, 0x68, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x57, 0x69, 0x74, 0x68,
    0x43, 0x4d, 0x12, 0x18, 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76,
    0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06,
    0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x1a, 0x0a, 0x12,
    0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f,
    0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x22, 0xd1, 0x01, 0x0a, 0x1c, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x41, 0x75, 0x74,
    0x68, 0x43, 0x6f, 0x6d, 0x70, 0x6c, 0x65, 0x74, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0f, 0x0a, 0x07, 0x67,
    0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0e, 0x0a, 0x06,
    0x65, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1e, 0x0a, 0x16,
    0x65, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x72, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11,
    0x44, 0x45, 0x50, 0x52, 0x45, 0x43, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x65,
    0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x69, 0x63, 0x6b, 0x65,
    0x74, 0x5f, 0x63, 0x72, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f, 0x74,
    0x69, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x07,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x5f, 0x73, 0x74,
    0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x06, 0x22, 0x82, 0x0a, 0x0a,
    0x0f, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x6f, 0x67, 0x6f, 0x6e,
    0x12, 0x18, 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72,
    0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1f, 0x0a, 0x17, 0x6f, 0x62,
    0x66, 0x75, 0x73, 0x74, 0x75, 0x63, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x70, 0x72, 0x69, 0x76, 0x61,
    0x74, 0x65, 0x5f, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x63,
    0x65, 0x6c, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f,
    0x6c, 0x61, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1e, 0x0a, 0x16, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f,
    0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f,
    0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12, 0x16,
    0x0a, 0x0e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x6f, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x27, 0x0a, 0x18, 0x73, 0x68, 0x6f, 0x75, 0x6c, 0x64,
    0x5f, 0x72, 0x65, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x5f, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6f,
    0x72, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12,
    0x14, 0x0a, 0x0c, 0x77, 0x69, 0x6e, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18,
    0x09, 0x20, 0x01, 0x28, 0x09, 0x12, 0x20, 0x0a, 0x18, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x6d, 0x73,
    0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x63, 0x65, 0x6c, 0x6c, 0x5f, 0x73, 0x65, 0x61, 0x72, 0x63,
    0x68, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69,
    0x63, 0x5f, 0x69, 0x70, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x71, 0x6f,
    0x73, 0x5f, 0x6c, 0x65, 0x76, 0x65, 0x6c, 0x18, 0x15, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x20, 0x0a,
    0x18, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64,
    0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x16, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x12, 0x0a, 0x0a, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x1e, 0x20,
    0x01, 0x28, 0x0c, 0x12, 0x18, 0x0a, 0x0d, 0x6c, 0x61, 0x75, 0x6e, 0x63, 0x68, 0x65, 0x72, 0x5f,
    0x74, 0x79, 0x70, 0x65, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x0d, 0x3a, 0x01, 0x30, 0x12, 0x12, 0x0a,
    0x07, 0x75, 0x69, 0x5f, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x20, 0x20, 0x01, 0x28, 0x0d, 0x3a, 0x01,
    0x30, 0x12, 0x1a, 0x0a, 0x12, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x32, 0x5f, 0x61, 0x75, 0x74, 0x68,
    0x5f, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x29, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x15, 0x0a,
    0x0d, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x2a,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x20, 0x0a, 0x18, 0x72, 0x74, 0x69, 0x6d, 0x65, 0x33, 0x32, 0x5f,
    0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e,
    0x18, 0x2b, 0x20, 0x01, 0x28, 0x07, 0x12, 0x14, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e,
    0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x32, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08,
    0x70, 0x61, 0x73, 0x73, 0x77, 0x6f, 0x72, 0x64, 0x18, 0x33, 0x20, 0x01, 0x28, 0x09, 0x12, 0x19,
    0x0a, 0x11, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x6f,
    0x6b, 0x65, 0x6e, 0x18, 0x34, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x6c, 0x6f, 0x67,
    0x69, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x3c, 0x20, 0x01, 0x28, 0x09, 0x12, 0x2b, 0x0a, 0x1c,
    0x77, 0x61, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x64, 0x65,
    0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x6d, 0x73, 0x67, 0x18, 0x46, 0x20, 0x01,
    0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x12, 0x25, 0x0a, 0x1d, 0x61, 0x6e, 0x6f,
    0x6e, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x5f, 0x61, 0x63,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x50, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x1e, 0x0a, 0x16, 0x72, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x64, 0x5f, 0x75, 0x73, 0x65,
    0x72, 0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x51, 0x20, 0x01, 0x28, 0x06,
    0x12, 0x1a, 0x0a, 0x12, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x5f, 0x73, 0x65, 0x6e, 0x74,
    0x72, 0x79, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x52, 0x20, 0x01, 0x28, 0x05, 0x12, 0x16, 0x0a, 0x0e,
    0x73, 0x68, 0x61, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x53,
    0x20, 0x01, 0x28, 0x0c, 0x12, 0x11, 0x0a, 0x09, 0x61, 0x75, 0x74, 0x68, 0x5f, 0x63, 0x6f, 0x64,
    0x65, 0x18, 0x54, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x6f, 0x74, 0x70, 0x5f, 0x74,
    0x79, 0x70, 0x65, 0x18, 0x55, 0x20, 0x01, 0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x6f, 0x74, 0x70,
    0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x56, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e,
    0x6f, 0x74, 0x70, 0x5f, 0x69, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x18, 0x57,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x1d, 0x0a, 0x15, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x32, 0x5f, 0x74,
    0x69, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x58, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x6f, 0x6e, 0x79, 0x5f, 0x70, 0x73, 0x6e, 0x5f,
    0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x5a, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x1b, 0x0a, 0x13,
    0x73, 0x6f, 0x6e, 0x79, 0x5f, 0x70, 0x73, 0x6e, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
    0x5f, 0x69, 0x64, 0x18, 0x5b, 0x20, 0x01, 0x28, 0x09, 0x12, 0x36, 0x0a, 0x27, 0x63, 0x72, 0x65,
    0x61, 0x74, 0x65, 0x5f, 0x6e, 0x65, 0x77, 0x5f, 0x70, 0x73, 0x6e, 0x5f, 0x6c, 0x69, 0x6e, 0x6b,
    0x65, 0x64, 0x5f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x66, 0x5f, 0x6e, 0x65,
    0x65, 0x64, 0x65, 0x64, 0x18, 0x5c, 0x20, 0x01, 0x28, 0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73,
    0x65, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x6f, 0x6e, 0x79, 0x5f, 0x70, 0x73, 0x6e, 0x5f, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x5d, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1a, 0x0a, 0x12, 0x67, 0x61, 0x6d, 0x65,
    0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x5e,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x29, 0x0a, 0x21, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x67, 0x75, 0x61,
    0x72, 0x64, 0x5f, 0x64, 0x6f, 0x6e, 0x74, 0x5f, 0x72, 0x65, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72,
    0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x18, 0x5f, 0x20, 0x01, 0x28, 0x08, 0x12,
    0x14, 0x0a, 0x0c, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x60, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1f, 0x0a, 0x17, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65,
    0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x63, 0x68, 0x6f, 0x73, 0x65, 0x6e,
    0x18, 0x61, 0x20, 0x01, 0x28, 0x09, 0x12, 0x18, 0x0a, 0x10, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72,
    0x79, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x18, 0x62, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x14, 0x0a, 0x0c, 0x69, 0x73, 0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x62, 0x6f, 0x78,
    0x18, 0x63, 0x20, 0x01, 0x28, 0x08, 0x12, 0x1a, 0x0a, 0x12, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x5f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x64, 0x20, 0x01,
    0x28, 0x04, 0x12, 0x17, 0x0a, 0x0f, 0x74, 0x77, 0x6f, 0x5f, 0x66, 0x61, 0x63, 0x74, 0x6f, 0x72,
    0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x65, 0x20, 0x01, 0x28, 0x09, 0x12, 0x24, 0x0a, 0x1c, 0x73,
    0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d,
    0x69, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x66, 0x20, 0x01, 0x28,
    0x08, 0x22, 0x8c, 0x05, 0x0a, 0x17, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x4c, 0x6f, 0x67, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a,
    0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01,
    0x32, 0x12, 0x25, 0x0a, 0x1d, 0x6f, 0x75, 0x74, 0x5f, 0x6f, 0x66, 0x5f, 0x67, 0x61, 0x6d, 0x65,
    0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e,
    0x64, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x21, 0x0a, 0x19, 0x69, 0x6e, 0x5f, 0x67,
    0x61, 0x6d, 0x65, 0x5f, 0x68, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x5f, 0x73, 0x65,
    0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x70,
    0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x69, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b,
    0x0a, 0x13, 0x72, 0x74, 0x69, 0x6d, 0x65, 0x33, 0x32, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x12, 0x15, 0x0a, 0x0d, 0x61,
    0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x65, 0x6c, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x6d, 0x61, 0x69, 0x6c, 0x5f, 0x64, 0x6f, 0x6d,
    0x61, 0x69, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x32, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c,
    0x12, 0x18, 0x0a, 0x10, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x5f, 0x65, 0x78, 0x74, 0x65,
    0x6e, 0x64, 0x65, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x12, 0x26, 0x0a, 0x1e, 0x77, 0x65,
    0x62, 0x61, 0x70, 0x69, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63, 0x61, 0x74,
    0x65, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x0b, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x1e, 0x0a, 0x16, 0x63, 0x65, 0x6c, 0x6c, 0x5f, 0x69, 0x64, 0x5f, 0x70, 0x69,
    0x6e, 0x67, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x0c, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x5f, 0x70, 0x69, 0x63, 0x73, 0x18, 0x0d,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x12, 0x0a, 0x0a, 0x76, 0x61, 0x6e, 0x69, 0x74, 0x79, 0x5f, 0x75,
    0x72, 0x6c, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1f, 0x0a, 0x17, 0x63, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x5f, 0x73, 0x75, 0x70, 0x70, 0x6c, 0x69, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x65, 0x61,
    0x6d, 0x69, 0x64, 0x18, 0x14, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f, 0x69, 0x70, 0x5f,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x63, 0x6f, 0x64, 0x65, 0x18, 0x15, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x19, 0x0a, 0x11, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x5f, 0x73,
    0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x22, 0x0a,
    0x1a, 0x70, 0x61, 0x72, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x5f, 0x73, 0x65, 0x74, 0x74, 0x69, 0x6e,
    0x67, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x17, 0x20, 0x01, 0x28,
    0x0c, 0x12, 0x26, 0x0a, 0x1e, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x6c, 0x6f, 0x67, 0x69, 0x6e,
    0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x6d, 0x69, 0x67, 0x72,
    0x61, 0x74, 0x65, 0x18, 0x18, 0x20, 0x01, 0x28, 0x05, 0x12, 0x24, 0x0a, 0x1c, 0x63, 0x6f, 0x75,
    0x6e, 0x74, 0x5f, 0x64, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x73, 0x5f, 0x74,
    0x6f, 0x5f, 0x6d, 0x69, 0x67, 0x72, 0x61, 0x74, 0x65, 0x18, 0x19, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x23, 0x0a, 0x1b, 0x6f, 0x67, 0x73, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x72, 0x65, 0x70, 0x6f,
    0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18, 0x1a,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x1a, 0x0a, 0x12, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69,
    0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x1b, 0x20, 0x01, 0x28, 0x04,
    0x22, 0x2e, 0x0a, 0x2c, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x57, 0x65, 0x62, 0x41, 0x50, 0x49, 0x41, 0x75, 0x74, 0x68, 0x65,
    0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x4e, 0x6f, 0x6e, 0x63, 0x65,
    0x22, 0x72, 0x0a, 0x34, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x57, 0x65, 0x62, 0x41, 0x50, 0x49, 0x41, 0x75, 0x74, 0x68, 0x65,
    0x6e, 0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x55, 0x73, 0x65, 0x72, 0x4e, 0x6f, 0x6e, 0x63, 0x65,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x26, 0x0a, 0x1e,
    0x77, 0x65, 0x62, 0x61, 0x70, 0x69, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74, 0x69, 0x63,
    0x61, 0x74, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x0b,
    0x20, 0x01, 0x28, 0x09, 0x22, 0x12, 0x0a, 0x10, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x4c, 0x6f, 0x67, 0x4f, 0x66, 0x66, 0x22, 0x29, 0x0a, 0x13, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x6f, 0x67, 0x67, 0x65, 0x64, 0x4f, 0x66, 0x66, 0x12,
    0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05,
    0x3a, 0x01, 0x32, 0x22, 0x3a, 0x0a, 0x10, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x43, 0x4d, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x6d, 0x5f, 0x61, 0x64,
    0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x10, 0x0a,
    0x08, 0x63, 0x6d, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x22,
    0x6d, 0x0a, 0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x32, 0x50,
    0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x15,
    0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69,
    0x64, 0x5f, 0x73, 0x72, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0e, 0x0a, 0x06, 0x61,
    0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x63,
    0x61, 0x6e, 0x64, 0x69, 0x64, 0x61, 0x74, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x7a,
    0x0a, 0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x32, 0x50, 0x43,
    0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x61, 0x69, 0x6c, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x64, 0x65,
    0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x74, 0x65, 0x61,
    0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x73, 0x72, 0x63, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0e,
    0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1a,
    0x0a, 0x12, 0x65, 0x70, 0x32, 0x70, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x65,
    0x72, 0x72, 0x6f, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x31, 0x0a, 0x1f, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x41, 0x70, 0x70, 0x4f, 0x77,
    0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x0e, 0x0a,
    0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x5d, 0x0a,
    0x27, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x41, 0x70,
    0x70, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x3a, 0x01, 0x32, 0x12, 0x0e, 0x0a, 0x06,
    0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06,
    0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x27, 0x0a, 0x16,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f,
    0x6e, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x0d, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x04, 0x22, 0x4d, 0x0a, 0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x54, 0x6f,
    0x6b, 0x65, 0x6e, 0x73, 0x12, 0x1e, 0x0a, 0x12, 0x6d, 0x61, 0x78, 0x5f, 0x74, 0x6f, 0x6b, 0x65,
    0x6e, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x6b, 0x65, 0x65, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x3a, 0x02, 0x31, 0x30, 0x12, 0x0e, 0x0a, 0x06, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x02,
    0x20, 0x03, 0x28, 0x0c, 0x22, 0xa5, 0x01, 0x0a, 0x10, 0x43, 0x4d, 0x73, 0x67, 0x47, 0x53, 0x53,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x12, 0x15, 0x0a, 0x0d, 0x61, 0x70, 0x70,
    0x5f, 0x69, 0x64, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x0d, 0x0a, 0x05, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x17, 0x0a, 0x0f, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65,
    0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x67, 0x61, 0x6d, 0x65,
    0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x67,
    0x61, 0x6d, 0x65, 0x5f, 0x64, 0x69, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a,
    0x0c, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x0f, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x71, 0x75, 0x65, 0x72,
    0x79, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x26, 0x0a, 0x11,
    0x43, 0x4d, 0x73, 0x67, 0x47, 0x53, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x52, 0x65, 0x70, 0x6c,
    0x79, 0x12, 0x11, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x08, 0x22, 0x7b, 0x0a, 0x10, 0x43, 0x4d, 0x73, 0x67, 0x47, 0x53, 0x50, 0x6c,
    0x61, 0x79, 0x65, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x07, 0x70, 0x6c, 0x61, 0x79,
    0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x43, 0x4d, 0x73, 0x67,
    0x47, 0x53, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x2e, 0x50, 0x6c, 0x61,
    0x79, 0x65, 0x72, 0x1a, 0x3c, 0x0a, 0x06, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x12, 0x10, 0x0a,
    0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x12,
    0x11, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x0c, 0x22, 0x47, 0x0a, 0x11, 0x43, 0x4d, 0x73, 0x67, 0x47, 0x53, 0x55, 0x73, 0x65, 0x72, 0x50,
    0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c,
    0x69, 0x63, 0x5f, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05, 0x74,
    0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x2a, 0x0a, 0x16, 0x43, 0x4d,
    0x73, 0x67, 0x47, 0x53, 0x44, 0x69, 0x73, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x4e, 0x6f,
    0x74, 0x69, 0x63, 0x65, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x22, 0xf5, 0x02, 0x0a, 0x15, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x73, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64,
    0x12, 0x37, 0x0a, 0x0c, 0x67, 0x61, 0x6d, 0x65, 0x73, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x47, 0x61, 0x6d, 0x65, 0x73, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x2e, 0x47,
    0x61, 0x6d, 0x65, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x5f, 0x6f, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0d, 0x1a, 0x8a, 0x02, 0x0a, 0x0a, 0x47, 0x61, 0x6d, 0x65, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64,
    0x12, 0x13, 0x0a, 0x0b, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x67, 0x73, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69,
    0x70, 0x5f, 0x61, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x11, 0x0a, 0x09, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x69, 0x73, 0x5f, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0d, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x06,
    0x20, 0x01, 0x28, 0x0c, 0x12, 0x17, 0x0a, 0x0f, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x65, 0x78, 0x74,
    0x72, 0x61, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x12, 0x16, 0x0a,
    0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x62, 0x6c, 0x6f, 0x62, 0x18,
    0x08, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73,
    0x5f, 0x69, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x73, 0x74, 0x72,
    0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x5f, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x72, 0x5f,
    0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x67, 0x61, 0x6d, 0x65,
    0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08,
    0x6f, 0x77, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x39,
    0x0a, 0x0d, 0x43, 0x4d, 0x73, 0x67, 0x47, 0x53, 0x41, 0x70, 0x70, 0x72, 0x6f, 0x76, 0x65, 0x12,
    0x10, 0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x16, 0x0a, 0x0e, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d,
    0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x22, 0x49, 0x0a, 0x0a, 0x43, 0x4d, 0x73,
    0x67, 0x47, 0x53, 0x44, 0x65, 0x6e, 0x79, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d,
    0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x64, 0x65,
    0x6e, 0x79, 0x5f, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x13, 0x0a, 0x0b, 0x64, 0x65, 0x6e, 0x79, 0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x09, 0x22, 0x34, 0x0a, 0x0a, 0x43, 0x4d, 0x73, 0x67, 0x47, 0x53, 0x4b, 0x69,
    0x63, 0x6b, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x64, 0x65, 0x6e, 0x79, 0x5f, 0x72, 0x65,
    0x61, 0x73, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x22, 0xb6, 0x01, 0x0a, 0x12, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x69, 0x73,
    0x74, 0x12, 0x13, 0x0a, 0x0b, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x5f, 0x6c, 0x65, 0x66, 0x74,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x72,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x73, 0x65, 0x71, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x24, 0x0a, 0x1c, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x5f, 0x73, 0x65, 0x71, 0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x20, 0x0a, 0x07, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74,
    0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x41, 0x75,
    0x74, 0x68, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x12, 0x0f, 0x0a, 0x07, 0x61, 0x70, 0x70, 0x5f,
    0x69, 0x64, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x6d, 0x65, 0x73,
    0x73, 0x61, 0x67, 0x65, 0x5f, 0x73, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x0d, 0x22, 0x56, 0x0a, 0x15, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x41, 0x75, 0x74, 0x68, 0x4c, 0x69, 0x73, 0x74, 0x41, 0x63, 0x6b, 0x12, 0x12, 0x0a, 0x0a,
    0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x5f, 0x63, 0x72, 0x63, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d,
    0x12, 0x0f, 0x0a, 0x07, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28,
    0x0d, 0x12, 0x18, 0x0a, 0x10, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x73, 0x65, 0x71,
    0x75, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xea, 0x01, 0x0a, 0x15,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64,
    0x73, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x14, 0x0a, 0x0c, 0x62, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d,
    0x65, 0x6e, 0x74, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12, 0x2e, 0x0a, 0x07, 0x66,
    0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73,
    0x4c, 0x69, 0x73, 0x74, 0x2e, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x12, 0x18, 0x0a, 0x10, 0x6d,
    0x61, 0x78, 0x5f, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x5f,
    0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x5f, 0x6c, 0x69,
    0x6d, 0x69, 0x74, 0x5f, 0x68, 0x69, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x39, 0x0a,
    0x06, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x12, 0x12, 0x0a, 0x0a, 0x75, 0x6c, 0x66, 0x72, 0x69,
    0x65, 0x6e, 0x64, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x1b, 0x0a, 0x13, 0x65,
    0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x72, 0x65, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x68,
    0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xc5, 0x02, 0x0a, 0x1b, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x47, 0x72,
    0x6f, 0x75, 0x70, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x08, 0x62, 0x72, 0x65, 0x6d,
    0x6f, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12, 0x14, 0x0a, 0x0c, 0x62, 0x69,
    0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,
    0x12, 0x3e, 0x0a, 0x0c, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73,
    0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73,
    0x4c, 0x69, 0x73, 0x74, 0x2e, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x47, 0x72, 0x6f, 0x75, 0x70,
    0x12, 0x48, 0x0a, 0x0b, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x73, 0x18,
    0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73, 0x4c,
    0x69, 0x73, 0x74, 0x2e, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x73,
    0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x1a, 0x35, 0x0a, 0x0b, 0x46, 0x72,
    0x69, 0x65, 0x6e, 0x64, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x12, 0x10, 0x0a, 0x08, 0x6e, 0x47, 0x72,
    0x6f, 0x75, 0x70, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14, 0x0a, 0x0c, 0x73,
    0x74, 0x72, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x4e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x1a, 0x3d, 0x0a, 0x16, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x47, 0x72, 0x6f, 0x75, 0x70,
    0x73, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x68, 0x69, 0x70, 0x12, 0x11, 0x0a, 0x09, 0x75,
    0x6c, 0x53, 0x74, 0x65, 0x61, 0x6d, 0x49, 0x44, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x10,
    0x0a, 0x08, 0x6e, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x49, 0x44, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
    0x22, 0xba, 0x01, 0x0a, 0x1c, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50,
    0x6c, 0x61, 0x79, 0x65, 0x72, 0x4e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x4c, 0x69, 0x73,
    0x74, 0x12, 0x0f, 0x0a, 0x07, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x08, 0x12, 0x13, 0x0a, 0x0b, 0x69, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61,
    0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x3f, 0x0a, 0x09, 0x6e, 0x69, 0x63, 0x6b, 0x6e,
    0x61, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4e, 0x69, 0x63,
    0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x2e, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72,
    0x4e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x1a, 0x33, 0x0a, 0x0e, 0x50, 0x6c, 0x61, 0x79,
    0x65, 0x72, 0x4e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x74,
    0x65, 0x61, 0x6d, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x10, 0x0a, 0x08, 0x6e,
    0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0x40, 0x0a,
    0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x74, 0x50, 0x6c,
    0x61, 0x79, 0x65, 0x72, 0x4e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x0f, 0x0a, 0x07,
    0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x10, 0x0a,
    0x08, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22,
    0x36, 0x0a, 0x23, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x74,
    0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xdd, 0x03, 0x0a, 0x15, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x4c, 0x69, 0x73,
    0x74, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x30, 0x0a, 0x08, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65,
    0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x2e,
    0x4c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x1a, 0xfd, 0x02, 0x0a, 0x07, 0x4c, 0x69, 0x63, 0x65,
    0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x0a, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x69, 0x6d, 0x65, 0x5f,
    0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x07, 0x12, 0x19, 0x0a,
    0x11, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6e, 0x65, 0x78, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65,
    0x73, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x07, 0x12, 0x14, 0x0a, 0x0c, 0x6d, 0x69, 0x6e, 0x75,
    0x74, 0x65, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x14,
    0x0a, 0x0c, 0x6d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x16, 0x0a, 0x0e, 0x70, 0x61, 0x79, 0x6d, 0x65, 0x6e, 0x74, 0x5f,
    0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0d, 0x0a, 0x05,
    0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x70,
    0x75, 0x72, 0x63, 0x68, 0x61, 0x73, 0x65, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x5f,
    0x63, 0x6f, 0x64, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x6c, 0x69,
    0x63, 0x65, 0x6e, 0x73, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x16, 0x0a, 0x0e, 0x74, 0x65, 0x72, 0x72, 0x69, 0x74, 0x6f, 0x72, 0x79, 0x5f, 0x63, 0x6f,
    0x64, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x05, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x10, 0x0a, 0x08, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64, 0x18, 0x0c, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x70, 0x65, 0x72,
    0x69, 0x6f, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11, 0x69, 0x6e, 0x69,
    0x74, 0x69, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x75, 0x6e, 0x69, 0x74, 0x18, 0x0e,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x72, 0x65, 0x6e, 0x65, 0x77, 0x61, 0x6c, 0x5f,
    0x70, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11,
    0x72, 0x65, 0x6e, 0x65, 0x77, 0x61, 0x6c, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x75, 0x6e, 0x69,
    0x74, 0x18, 0x10, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x7c, 0x0a, 0x15, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x53, 0x65, 0x74, 0x53, 0x63, 0x6f, 0x72, 0x65,
    0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x16, 0x0a, 0x0e, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f,
    0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0d, 0x0a, 0x05, 0x73, 0x63, 0x6f, 0x72,
    0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x64, 0x65, 0x74, 0x61, 0x69,
    0x6c, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x1b, 0x0a, 0x13, 0x75, 0x70, 0x6c, 0x6f,
    0x61, 0x64, 0x5f, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x05, 0x22, 0xa2, 0x01, 0x0a, 0x1d, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x53, 0x65, 0x74, 0x53, 0x63, 0x6f, 0x72, 0x65, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75,
    0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x1f, 0x0a, 0x17, 0x6c,
    0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79,
    0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x15, 0x0a, 0x0d,
    0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x1c, 0x0a, 0x14, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x5f, 0x72, 0x61,
    0x6e, 0x6b, 0x5f, 0x70, 0x72, 0x65, 0x76, 0x69, 0x6f, 0x75, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x17, 0x0a, 0x0f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x5f, 0x72, 0x61, 0x6e, 0x6b,
    0x5f, 0x6e, 0x65, 0x77, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x22, 0x4d, 0x0a, 0x13, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x53, 0x65, 0x74, 0x55, 0x47,
    0x43, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64,
    0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0e, 0x0a, 0x06, 0x75, 0x67, 0x63,
    0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x22, 0x31, 0x0a, 0x1b, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x53, 0x65, 0x74, 0x55, 0x47, 0x43,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x22, 0xa7, 0x01, 0x0a,
    0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x46, 0x69,
    0x6e, 0x64, 0x4f, 0x72, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x4c, 0x42, 0x12, 0x0e, 0x0a, 0x06,
    0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1f, 0x0a, 0x17,
    0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x6f, 0x72, 0x74,
    0x5f, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x20, 0x0a,
    0x18, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x64, 0x69, 0x73,
    0x70, 0x6c, 0x61, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x1b, 0x0a, 0x13, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x5f, 0x69, 0x66, 0x5f, 0x6e, 0x6f, 0x74,
    0x5f, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x12, 0x18, 0x0a, 0x10,
    0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x22, 0xd5, 0x01, 0x0a, 0x23, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x46, 0x69, 0x6e, 0x64, 0x4f, 0x72, 0x43, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x4c, 0x42, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12,
    0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a,
    0x01, 0x32, 0x12, 0x16, 0x0a, 0x0e, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72,
    0x64, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1f, 0x0a, 0x17, 0x6c, 0x65,
    0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x22, 0x0a, 0x17, 0x6c,
    0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x73, 0x6f, 0x72, 0x74, 0x5f,
    0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x30, 0x12,
    0x23, 0x0a, 0x18, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x64,
    0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x05, 0x3a, 0x01, 0x30, 0x12, 0x18, 0x0a, 0x10, 0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f,
    0x61, 0x72, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x22, 0x9f,
    0x01, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53,
    0x47, 0x65, 0x74, 0x4c, 0x42, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x0e, 0x0a, 0x06,
    0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x16, 0x0a, 0x0e,
    0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x69, 0x64, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x73, 0x74,
    0x61, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x11, 0x0a, 0x09, 0x72, 0x61, 0x6e,
    0x67, 0x65, 0x5f, 0x65, 0x6e, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x20, 0x0a, 0x18,
    0x6c, 0x65, 0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x64, 0x61, 0x74, 0x61,
    0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10,
    0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x06,
    0x22, 0xf8, 0x01, 0x0a, 0x21, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c,
    0x42, 0x53, 0x47, 0x65, 0x74, 0x4c, 0x42, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x1f, 0x0a, 0x17, 0x6c, 0x65,
    0x61, 0x64, 0x65, 0x72, 0x62, 0x6f, 0x61, 0x72, 0x64, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x39, 0x0a, 0x07, 0x65,
    0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4c, 0x42, 0x53, 0x47, 0x65, 0x74, 0x4c,
    0x42, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x2e, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x1a, 0x63, 0x0a, 0x05, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12,
    0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x75, 0x73, 0x65, 0x72,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x13, 0x0a, 0x0b, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
    0x5f, 0x72, 0x61, 0x6e, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0d, 0x0a, 0x05, 0x73,
    0x63, 0x6f, 0x72, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x64, 0x65,
    0x74, 0x61, 0x69, 0x6c, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0e, 0x0a, 0x06, 0x75,
    0x67, 0x63, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x06, 0x22, 0xf8, 0x01, 0x0a, 0x15,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e,
    0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x14, 0x0a, 0x0c, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61,
    0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x69,
    0x70, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x1e, 0x0a, 0x16, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x61, 0x75, 0x74, 0x68, 0x65, 0x64, 0x5f,
    0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x15, 0x0a, 0x0d, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x61, 0x63, 0x65, 0x62, 0x6f,
    0x6f, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x66,
    0x61, 0x63, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x25, 0x0a, 0x1d, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x67, 0x75, 0x61, 0x72, 0x64,
    0x5f, 0x6e, 0x6f, 0x74, 0x69, 0x66, 0x79, 0x5f, 0x6e, 0x65, 0x77, 0x6d, 0x61, 0x63, 0x68, 0x69,
    0x6e, 0x65, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x12, 0x2b, 0x0a, 0x23, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x67, 0x75, 0x61, 0x72, 0x64, 0x5f, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f,
    0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x63, 0x68, 0x6f, 0x73, 0x65, 0x6e,
    0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x22, 0xbf, 0x01, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x50,
    0x6c, 0x61, 0x79, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x12, 0x4c, 0x0a, 0x0e, 0x6d, 0x69, 0x6e,
    0x75, 0x74, 0x65, 0x73, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x34, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70,
    0x70, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x44, 0x61,
    0x74, 0x61, 0x2e, 0x41, 0x70, 0x70, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x50, 0x6c, 0x61,
    0x79, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x1a, 0x4f, 0x0a, 0x14, 0x41, 0x70, 0x70, 0x4d, 0x69,
    0x6e, 0x75, 0x74, 0x65, 0x73, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x12,
    0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x0f, 0x0a, 0x07, 0x66, 0x6f, 0x72, 0x65, 0x76, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x16, 0x0a, 0x0e, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x74, 0x77, 0x6f, 0x5f, 0x77, 0x65, 0x65,
    0x6b, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x22, 0xaa, 0x01, 0x0a, 0x1a, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x73, 0x4c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64,
    0x41, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x12, 0x1b, 0x0a, 0x13, 0x62, 0x69, 0x73, 0x5f, 0x6c,
    0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x1c, 0x0a, 0x14, 0x62, 0x69, 0x73, 0x5f, 0x63, 0x6f, 0x6d, 0x6d,
    0x75, 0x6e, 0x69, 0x74, 0x79, 0x5f, 0x62, 0x61, 0x6e, 0x6e, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x08, 0x12, 0x1a, 0x0a, 0x12, 0x62, 0x69, 0x73, 0x5f, 0x6c, 0x6f, 0x63, 0x6b, 0x65, 0x64,
    0x5f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x35,
    0x0a, 0x2d, 0x62, 0x69, 0x73, 0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x63,
    0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x65, 0x64, 0x5f, 0x74, 0x6f,
    0x5f, 0x69, 0x6e, 0x76, 0x69, 0x74, 0x65, 0x5f, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x08, 0x22, 0x4f, 0x0a, 0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64,
    0x44, 0x61, 0x74, 0x61, 0x12, 0x1f, 0x0a, 0x17, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f,
    0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73,
    0x18, 0x02, 0x20, 0x03, 0x28, 0x06, 0x22, 0x98, 0x01, 0x0a, 0x16, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75,
    0x73, 0x12, 0x15, 0x0a, 0x0d, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x73, 0x74, 0x61,
    0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x6c, 0x61, 0x79,
    0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1e, 0x0a,
    0x16, 0x69, 0x73, 0x5f, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x67, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74,
    0x65, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x15, 0x0a,
    0x0d, 0x68, 0x69, 0x67, 0x68, 0x5f, 0x70, 0x72, 0x69, 0x6f, 0x72, 0x69, 0x74, 0x79, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x08, 0x12, 0x1b, 0x0a, 0x13, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f,
    0x73, 0x65, 0x74, 0x5f, 0x62, 0x79, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x08, 0x22, 0x40, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61,
    0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e,
    0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13,
    0x0a, 0x0b, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x22, 0xe7, 0x04, 0x0a, 0x16, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x14,
    0x0a, 0x0c, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x2f, 0x0a, 0x07, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x73, 0x18,
    0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x53, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x46,
    0x72, 0x69, 0x65, 0x6e, 0x64, 0x1a, 0x85, 0x04, 0x0a, 0x06, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64,
    0x12, 0x10, 0x0a, 0x08, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x06, 0x12, 0x15, 0x0a, 0x0d, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x73, 0x74,
    0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1a, 0x0a, 0x12, 0x67, 0x61, 0x6d,
    0x65, 0x5f, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x5f, 0x69, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a,
    0x10, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x72,
    0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x70, 0x65, 0x72, 0x73, 0x6f,
    0x6e, 0x61, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x20, 0x0a, 0x18, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x73,
    0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x73,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x73,
    0x68, 0x65, 0x64, 0x5f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x69, 0x64, 0x18,
    0x08, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61,
    0x5f, 0x73, 0x65, 0x74, 0x5f, 0x62, 0x79, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x0a, 0x20, 0x01,
    0x28, 0x08, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x71, 0x75, 0x65, 0x72, 0x79,
    0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x14, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73,
    0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x19, 0x20,
    0x01, 0x28, 0x06, 0x12, 0x13, 0x0a, 0x0b, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x5f, 0x68, 0x61,
    0x73, 0x68, 0x18, 0x1f, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x13, 0x0a, 0x0b, 0x6c, 0x61, 0x73, 0x74,
    0x5f, 0x6c, 0x6f, 0x67, 0x6f, 0x66, 0x66, 0x18, 0x2d, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a,
    0x0a, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x6c, 0x6f, 0x67, 0x6f, 0x6e, 0x18, 0x2e, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x6c, 0x61, 0x6e, 0x5f, 0x72, 0x61, 0x6e, 0x6b, 0x18, 0x32,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x37, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x67, 0x61, 0x6d, 0x65, 0x69,
    0x64, 0x18, 0x38, 0x20, 0x01, 0x28, 0x06, 0x12, 0x16, 0x0a, 0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f,
    0x64, 0x61, 0x74, 0x61, 0x5f, 0x62, 0x6c, 0x6f, 0x62, 0x18, 0x3c, 0x20, 0x01, 0x28, 0x0c, 0x12,
    0x10, 0x0a, 0x08, 0x63, 0x6c, 0x61, 0x6e, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x41, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x15, 0x0a, 0x0d, 0x66, 0x61, 0x63, 0x65, 0x62, 0x6f, 0x6f, 0x6b, 0x5f, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x42, 0x20, 0x01, 0x28, 0x09, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x61, 0x63, 0x65,
    0x62, 0x6f, 0x6f, 0x6b, 0x5f, 0x69, 0x64, 0x18, 0x43, 0x20, 0x01, 0x28, 0x04, 0x22, 0x35, 0x0a,
    0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e,
    0x64, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x0e,
    0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x06, 0x22, 0xda, 0x01, 0x0a, 0x23, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65,
    0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07,
    0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32,
    0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x66, 0x72, 0x69, 0x65,
    0x6e, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x74, 0x69, 0x6d, 0x65,
    0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11,
    0x0a, 0x09, 0x72, 0x65, 0x61, 0x6c, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x69, 0x74, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x65, 0x5f, 0x6e, 0x61,
    0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x63, 0x6f, 0x75, 0x6e,
    0x74, 0x72, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10,
    0x0a, 0x08, 0x68, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x0f, 0x0a, 0x07, 0x73, 0x75, 0x6d, 0x6d, 0x61, 0x72, 0x79, 0x18, 0x09, 0x20, 0x01, 0x28,
    0x09, 0x22, 0x8c, 0x01, 0x0a, 0x14, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x2d, 0x0a, 0x07, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x4c, 0x69,
    0x73, 0x74, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x1a, 0x45, 0x0a, 0x06, 0x53, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x5f, 0x69, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x73,
    0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
    0x22, 0xa7, 0x01, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74,
    0x61, 0x74, 0x73, 0x12, 0x42, 0x0a, 0x0d, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x74, 0x6f, 0x5f,
    0x73, 0x65, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74,
    0x73, 0x54, 0x6f, 0x53, 0x65, 0x6e, 0x64, 0x1a, 0x41, 0x0a, 0x0b, 0x53, 0x74, 0x61, 0x74, 0x73,
    0x54, 0x6f, 0x53, 0x65, 0x6e, 0x64, 0x12, 0x13, 0x0a, 0x0b, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x5f, 0x73, 0x74, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x73,
    0x74, 0x61, 0x74, 0x5f, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x65, 0x5f, 0x6d, 0x65,
    0x74, 0x68, 0x6f, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xc0, 0x01, 0x0a, 0x0f, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x32, 0x12, 0x30,
    0x0a, 0x0b, 0x73, 0x74, 0x61, 0x74, 0x5f, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x18, 0x01, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x53, 0x74, 0x61, 0x74, 0x32, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c,
    0x1a, 0x7b, 0x0a, 0x0a, 0x53, 0x74, 0x61, 0x74, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x12, 0x13,
    0x0a, 0x0b, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x6c, 0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x03, 0x12, 0x13, 0x0a, 0x0b, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x6f, 0x66,
    0x5f, 0x64, 0x61, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x65,
    0x6c, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x64,
    0x65, 0x70, 0x6f, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a,
    0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xba, 0x01,
    0x0a, 0x18, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x43,
    0x72, 0x65, 0x61, 0x74, 0x65, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70,
    0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61,
    0x78, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x12, 0x0a, 0x0a, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x66, 0x6c, 0x61,
    0x67, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x65, 0x6c, 0x6c,
    0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x75, 0x62,
    0x6c, 0x69, 0x63, 0x5f, 0x69, 0x70, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08,
    0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x1a,
    0x0a, 0x12, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x6f,
    0x77, 0x6e, 0x65, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x22, 0x5e, 0x0a, 0x20, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x43, 0x72, 0x65, 0x61, 0x74,
    0x65, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e,
    0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16,
    0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x22, 0x56, 0x0a, 0x16, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4a, 0x6f, 0x69, 0x6e, 0x4c,
    0x6f, 0x62, 0x62, 0x79, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64,
    0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c,
    0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x09, 0x22, 0xcf, 0x02, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4d, 0x4d, 0x53, 0x4a, 0x6f, 0x69, 0x6e, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69,
    0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x20, 0x0a,
    0x18, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x72, 0x6f, 0x6f, 0x6d, 0x5f, 0x65, 0x6e, 0x74, 0x65, 0x72,
    0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6c, 0x6f, 0x62, 0x62,
    0x79, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x16, 0x0a,
    0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x06, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
    0x61, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x37, 0x0a, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65,
    0x72, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4a, 0x6f, 0x69, 0x6e, 0x4c, 0x6f, 0x62, 0x62,
    0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72,
    0x1a, 0x42, 0x0a, 0x06, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74,
    0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c,
    0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x0c, 0x22, 0x41, 0x0a, 0x17, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4c, 0x65, 0x61, 0x76, 0x65, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x12,
    0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62,
    0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x22, 0x5d, 0x0a, 0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4c, 0x65, 0x61, 0x76, 0x65, 0x4c, 0x6f, 0x62,
    0x62, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70,
    0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74,
    0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x06, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x22, 0xf2, 0x01, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79,
    0x4c, 0x69, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x6e, 0x75, 0x6d, 0x5f, 0x6c, 0x6f, 0x62, 0x62,
    0x69, 0x65, 0x73, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x65, 0x6c, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x5f, 0x69,
    0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x32, 0x0a, 0x07, 0x66, 0x69, 0x6c, 0x74, 0x65,
    0x72, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79,
    0x4c, 0x69, 0x73, 0x74, 0x2e, 0x46, 0x69, 0x6c, 0x74, 0x65, 0x72, 0x1a, 0x4e, 0x0a, 0x06, 0x46,
    0x69, 0x6c, 0x74, 0x65, 0x72, 0x12, 0x0b, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x09, 0x12, 0x0d, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x13, 0x0a, 0x0b, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x72, 0x69, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x74, 0x65, 0x72,
    0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x22, 0xa5, 0x02, 0x0a, 0x21,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x47, 0x65, 0x74,
    0x4c, 0x6f, 0x62, 0x62, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x39, 0x0a, 0x07, 0x6c, 0x6f, 0x62, 0x62, 0x69, 0x65, 0x73,
    0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x4c, 0x69,
    0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4c, 0x6f, 0x62, 0x62, 0x79,
    0x1a, 0xa0, 0x01, 0x0a, 0x05, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74,
    0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x13, 0x0a, 0x0b,
    0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x12, 0x0a, 0x0a, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x66,
    0x6c, 0x61, 0x67, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65,
    0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x13, 0x0a, 0x0b,
    0x6e, 0x75, 0x6d, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28,
    0x05, 0x12, 0x10, 0x0a, 0x08, 0x64, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x02, 0x12, 0x0e, 0x0a, 0x06, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x03, 0x22, 0xac, 0x01, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x53, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x44, 0x61, 0x74,
    0x61, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f,
    0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x06, 0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72,
    0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x6c, 0x6f, 0x62, 0x62, 0x79,
    0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6c,
    0x6f, 0x62, 0x62, 0x79, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x07, 0x20, 0x01,
    0x28, 0x0c, 0x22, 0x5f, 0x0a, 0x21, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x4d, 0x4d, 0x53, 0x53, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x44, 0x61, 0x74, 0x61, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d,
    0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
    0x3a, 0x01, 0x32, 0x22, 0x43, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4d, 0x4d, 0x53, 0x47, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x44, 0x61, 0x74, 0x61,
    0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62,
    0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x22, 0xc8, 0x02, 0x0a, 0x16, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x44,
    0x61, 0x74, 0x61, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f,
    0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x13, 0x0a, 0x0b, 0x6e,
    0x75, 0x6d, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05,
    0x12, 0x13, 0x0a, 0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x12, 0x0a, 0x0a, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x74,
    0x79, 0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x12, 0x13, 0x0a, 0x0b, 0x6c, 0x6f, 0x62,
    0x62, 0x79, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x05, 0x12, 0x16,
    0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6f, 0x77, 0x6e, 0x65, 0x72,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x06, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61,
    0x74, 0x61, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x2f, 0x0a, 0x07, 0x6d, 0x65, 0x6d, 0x62,
    0x65, 0x72, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x44, 0x61,
    0x74, 0x61, 0x2e, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x14, 0x0a, 0x0c, 0x6c, 0x6f, 0x62,
    0x62, 0x79, 0x5f, 0x63, 0x65, 0x6c, 0x6c, 0x69, 0x64, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0d, 0x1a,
    0x42, 0x0a, 0x06, 0x4d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c, 0x70,
    0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x10, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0c, 0x22, 0x77, 0x0a, 0x1d, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4d, 0x4d, 0x53, 0x53, 0x65, 0x6e, 0x64, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x43, 0x68, 0x61,
    0x74, 0x4d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64,
    0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f,
    0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x06, 0x12, 0x15, 0x0a, 0x0d, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x5f, 0x6d,
    0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x73, 0x0a, 0x19,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x4c, 0x6f, 0x62,
    0x62, 0x79, 0x43, 0x68, 0x61, 0x74, 0x4d, 0x73, 0x67, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70,
    0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x73, 0x65,
    0x6e, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x12, 0x15, 0x0a, 0x0d, 0x6c, 0x6f,
    0x62, 0x62, 0x79, 0x5f, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x0c, 0x22, 0x60, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d,
    0x4d, 0x53, 0x53, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x4f, 0x77, 0x6e, 0x65, 0x72, 0x12,
    0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62,
    0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x1a, 0x0a, 0x12, 0x73, 0x74, 0x65, 0x61, 0x6d,
    0x5f, 0x69, 0x64, 0x5f, 0x6e, 0x65, 0x77, 0x5f, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x06, 0x22, 0x60, 0x0a, 0x22, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4d, 0x4d, 0x53, 0x53, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x4f, 0x77, 0x6e, 0x65,
    0x72, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70,
    0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x05, 0x3a, 0x01, 0x32, 0x22, 0x5e, 0x0a, 0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x53, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x4c, 0x69,
    0x6e, 0x6b, 0x65, 0x64, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64,
    0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f,
    0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x32, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x06, 0x22, 0x99, 0x01, 0x0a, 0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x53, 0x65, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x47,
    0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70,
    0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x16, 0x0a, 0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72,
    0x5f, 0x69, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x67, 0x61, 0x6d,
    0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x1c, 0x0a, 0x14, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x06, 0x22, 0x99, 0x01, 0x0a, 0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x4d, 0x4d, 0x53, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x47, 0x61, 0x6d, 0x65, 0x53, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x53, 0x65, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69,
    0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x16, 0x0a,
    0x0e, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x69, 0x70, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65,
    0x72, 0x76, 0x65, 0x72, 0x5f, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x1c, 0x0a, 0x14, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x73,
    0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x06, 0x22, 0x73, 0x0a,
    0x1c, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x55, 0x73,
    0x65, 0x72, 0x4a, 0x6f, 0x69, 0x6e, 0x65, 0x64, 0x4c, 0x6f, 0x62, 0x62, 0x79, 0x12, 0x0e, 0x0a,
    0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a,
    0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69,
    0x64, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14, 0x0a, 0x0c,
    0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x09, 0x22, 0x71, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x4d, 0x4d, 0x53, 0x55, 0x73, 0x65, 0x72, 0x4c, 0x65, 0x66, 0x74, 0x4c, 0x6f, 0x62, 0x62, 0x79,
    0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x6c, 0x6f, 0x62,
    0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61,
    0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x14, 0x0a, 0x0c, 0x70, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
    0x04, 0x20, 0x01, 0x28, 0x09, 0x22, 0x63, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x4d, 0x4d, 0x53, 0x49, 0x6e, 0x76, 0x69, 0x74, 0x65, 0x54, 0x6f, 0x4c, 0x6f,
    0x62, 0x62, 0x79, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f,
    0x6c, 0x6f, 0x62, 0x62, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x1d, 0x0a, 0x15, 0x73,
    0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x5f, 0x69, 0x6e, 0x76,
    0x69, 0x74, 0x65, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x22, 0x60, 0x0a, 0x19, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x44, 0x53, 0x49, 0x6e, 0x76, 0x69, 0x74,
    0x65, 0x54, 0x6f, 0x47, 0x61, 0x6d, 0x65, 0x12, 0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61, 0x6d,
    0x5f, 0x69, 0x64, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x14,
    0x0a, 0x0c, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x73, 0x72, 0x63, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x06, 0x12, 0x16, 0x0a, 0x0e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x5f,
    0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x22, 0xb9, 0x01, 0x0a,
    0x14, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x68, 0x61, 0x74, 0x49,
    0x6e, 0x76, 0x69, 0x74, 0x65, 0x12, 0x18, 0x0a, 0x10, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69,
    0x64, 0x5f, 0x69, 0x6e, 0x76, 0x69, 0x74, 0x65, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x15, 0x0a, 0x0d, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x63, 0x68, 0x61, 0x74,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f,
    0x69, 0x64, 0x5f, 0x70, 0x61, 0x74, 0x72, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x15, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x74, 0x72, 0x6f, 0x6f, 0x6d, 0x5f, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1c, 0x0a, 0x14, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f,
    0x69, 0x64, 0x5f, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x5f, 0x63, 0x68, 0x61, 0x74, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x06, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x6e, 0x61, 0x6d,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f,
    0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x06, 0x22, 0x8a, 0x08, 0x0a, 0x19, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x3b, 0x0a, 0x0b, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f,
    0x6c, 0x6f, 0x67, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x4c, 0x6f,
    0x67, 0x6f, 0x6e, 0x12, 0x3b, 0x0a, 0x0b, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x76, 0x63, 0x6f,
    0x6e, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53,
    0x74, 0x61, 0x74, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x56, 0x43, 0x6f, 0x6e, 0x6e,
    0x1a, 0xc7, 0x01, 0x0a, 0x0b, 0x53, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x4c, 0x6f, 0x67, 0x6f, 0x6e,
    0x12, 0x18, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x5f, 0x61, 0x74, 0x74, 0x65,
    0x6d, 0x70, 0x74, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x19, 0x0a, 0x11, 0x63, 0x6f,
    0x6e, 0x6e, 0x65, 0x63, 0x74, 0x5f, 0x73, 0x75, 0x63, 0x63, 0x65, 0x73, 0x73, 0x65, 0x73, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x18, 0x0a, 0x10, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
    0x5f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x1b, 0x0a, 0x13, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x64,
    0x72, 0x6f, 0x70, 0x70, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x12, 0x17, 0x0a, 0x0f,
    0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x5f, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1c, 0x0a, 0x14, 0x6d, 0x73, 0x65, 0x63, 0x5f, 0x74, 0x6f,
    0x6c, 0x6f, 0x67, 0x6f, 0x6e, 0x74, 0x68, 0x69, 0x73, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x06, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x62, 0x61, 0x64,
    0x5f, 0x63, 0x6d, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x1a, 0x71, 0x0a, 0x09, 0x53, 0x74,
    0x61, 0x74, 0x73, 0x5f, 0x55, 0x44, 0x50, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x6b, 0x74, 0x73, 0x5f,
    0x73, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x62, 0x79,
    0x74, 0x65, 0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x12, 0x11,
    0x0a, 0x09, 0x70, 0x6b, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x76, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x16, 0x0a, 0x0e, 0x70, 0x6b, 0x74, 0x73, 0x5f, 0x70, 0x72, 0x6f, 0x63, 0x65, 0x73,
    0x73, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x12, 0x0a, 0x0a, 0x62, 0x79, 0x74,
    0x65, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x76, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x1a, 0xb5, 0x04,
    0x0a, 0x0b, 0x53, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x56, 0x43, 0x6f, 0x6e, 0x6e, 0x12, 0x17, 0x0a,
    0x0f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x75, 0x64, 0x70,
    0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
    0x74, 0x69, 0x6f, 0x6e, 0x73, 0x5f, 0x74, 0x63, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x37, 0x0a, 0x09, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x75, 0x64, 0x70, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0b, 0x32, 0x24, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43,
    0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x53,
    0x74, 0x61, 0x74, 0x73, 0x5f, 0x55, 0x44, 0x50, 0x12, 0x16, 0x0a, 0x0e, 0x70, 0x6b, 0x74, 0x73,
    0x5f, 0x61, 0x62, 0x61, 0x6e, 0x64, 0x6f, 0x6e, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x19, 0x0a, 0x11, 0x63, 0x6f, 0x6e, 0x6e, 0x5f, 0x72, 0x65, 0x71, 0x5f, 0x72, 0x65, 0x63,
    0x65, 0x69, 0x76, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x13, 0x0a, 0x0b, 0x70,
    0x6b, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x11, 0x0a, 0x09, 0x6d, 0x73, 0x67, 0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74, 0x18, 0x07, 0x20,
    0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x6d, 0x73, 0x67, 0x73, 0x5f, 0x73, 0x65, 0x6e, 0x74,
    0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x04, 0x12, 0x11, 0x0a,
    0x09, 0x6d, 0x73, 0x67, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x76, 0x18, 0x09, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x16, 0x0a, 0x0e, 0x64, 0x61, 0x74, 0x61, 0x67, 0x72, 0x61, 0x6d, 0x73, 0x5f, 0x73, 0x65,
    0x6e, 0x74, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x04, 0x12, 0x16, 0x0a, 0x0e, 0x64, 0x61, 0x74, 0x61,
    0x67, 0x72, 0x61, 0x6d, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x76, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x15, 0x0a, 0x0d, 0x62, 0x61, 0x64, 0x5f, 0x70, 0x6b, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x63,
    0x76, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1e, 0x0a, 0x16, 0x75, 0x6e, 0x6b, 0x6e, 0x6f,
    0x77, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x5f, 0x70, 0x6b, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x63,
    0x76, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x04, 0x12, 0x18, 0x0a, 0x10, 0x6d, 0x69, 0x73, 0x73, 0x65,
    0x64, 0x5f, 0x70, 0x6b, 0x74, 0x73, 0x5f, 0x72, 0x65, 0x63, 0x76, 0x18, 0x0e, 0x20, 0x01, 0x28,
    0x04, 0x12, 0x15, 0x0a, 0x0d, 0x64, 0x75, 0x70, 0x5f, 0x70, 0x6b, 0x74, 0x73, 0x5f, 0x72, 0x65,
    0x63, 0x76, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x04, 0x12, 0x21, 0x0a, 0x19, 0x66, 0x61, 0x69, 0x6c,
    0x65, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x5f, 0x63, 0x68, 0x61, 0x6c, 0x6c,
    0x65, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1d, 0x0a, 0x15, 0x6d,
    0x69, 0x63, 0x72, 0x6f, 0x5f, 0x73, 0x65, 0x63, 0x5f, 0x61, 0x76, 0x67, 0x5f, 0x6c, 0x61, 0x74,
    0x65, 0x6e, 0x63, 0x79, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x6d, 0x69,
    0x63, 0x72, 0x6f, 0x5f, 0x73, 0x65, 0x63, 0x5f, 0x6d, 0x69, 0x6e, 0x5f, 0x6c, 0x61, 0x74, 0x65,
    0x6e, 0x63, 0x79, 0x18, 0x12, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15, 0x6d, 0x69, 0x63,
    0x72, 0x6f, 0x5f, 0x73, 0x65, 0x63, 0x5f, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x61, 0x74, 0x65, 0x6e,
    0x63, 0x79, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x6d, 0x65, 0x6d, 0x5f,
    0x70, 0x6f, 0x6f, 0x6c, 0x5f, 0x6d, 0x73, 0x67, 0x5f, 0x69, 0x6e, 0x5f, 0x75, 0x73, 0x65, 0x18,
    0x14, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xd2, 0x01, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x41, 0x76, 0x61, 0x69, 0x6c,
    0x61, 0x62, 0x6c, 0x65, 0x12, 0x52, 0x0a, 0x16, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x74,
    0x79, 0x70, 0x65, 0x73, 0x5f, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x32, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c,
    0x65, 0x2e, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x54, 0x79, 0x70, 0x65, 0x73, 0x5f, 0x41,
    0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x25, 0x0a, 0x1d, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x72, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x5f, 0x61, 0x75, 0x74, 0x68,
    0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x1a,
    0x39, 0x0a, 0x16, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x54, 0x79, 0x70, 0x65, 0x73, 0x5f,
    0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x73, 0x65, 0x72,
    0x76, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x63, 0x68, 0x61,
    0x6e, 0x67, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x22, 0x75, 0x0a, 0x16, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x53,
    0x74, 0x61, 0x74, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x72, 0x63, 0x5f, 0x73, 0x74, 0x61,
    0x74, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1c, 0x0a, 0x14, 0x73, 0x63, 0x68, 0x65,
    0x6d, 0x61, 0x5f, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12, 0x19, 0x0a, 0x11, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f,
    0x69, 0x64, 0x5f, 0x66, 0x6f, 0x72, 0x5f, 0x75, 0x73, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x06, 0x22, 0xdf, 0x02, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x72, 0x63,
    0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06,
    0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x34, 0x0a, 0x05,
    0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x55, 0x73, 0x65, 0x72, 0x53,
    0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x53, 0x74, 0x61,
    0x74, 0x73, 0x12, 0x4e, 0x0a, 0x12, 0x61, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e,
    0x74, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x32,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x55, 0x73,
    0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e,
    0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x42, 0x6c, 0x6f, 0x63,
    0x6b, 0x73, 0x1a, 0x2c, 0x0a, 0x05, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x73,
    0x74, 0x61, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a,
    0x73, 0x74, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x1a, 0x41, 0x0a, 0x12, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f,
    0x42, 0x6c, 0x6f, 0x63, 0x6b, 0x73, 0x12, 0x16, 0x0a, 0x0e, 0x61, 0x63, 0x68, 0x69, 0x65, 0x76,
    0x65, 0x6d, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13,
    0x0a, 0x0b, 0x75, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20,
    0x03, 0x28, 0x07, 0x22, 0x9a, 0x02, 0x0a, 0x20, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65,
    0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65,
    0x73, 0x75, 0x6c, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x11, 0x0a,
    0x09, 0x63, 0x72, 0x63, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x5a, 0x0a, 0x17, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64,
    0x5f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x39, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74,
    0x6f, 0x72, 0x65, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x46, 0x61, 0x69, 0x6c, 0x65,
    0x64, 0x5f, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x19, 0x0a, 0x11,
    0x73, 0x74, 0x61, 0x74, 0x73, 0x5f, 0x6f, 0x75, 0x74, 0x5f, 0x6f, 0x66, 0x5f, 0x64, 0x61, 0x74,
    0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x47, 0x0a, 0x17, 0x53, 0x74, 0x61, 0x74, 0x73,
    0x5f, 0x46, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x5f, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69,
    0x6f, 0x6e, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x74, 0x61, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x5f,
    0x73, 0x74, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x22, 0xe8, 0x01, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53,
    0x74, 0x6f, 0x72, 0x65, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x32, 0x12, 0x0f,
    0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x17, 0x0a, 0x0f, 0x73, 0x65, 0x74, 0x74, 0x6f, 0x72, 0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f,
    0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f, 0x73, 0x65, 0x74, 0x74,
    0x65, 0x65, 0x5f, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x72, 0x63, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74,
    0x5f, 0x72, 0x65, 0x73, 0x65, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x12, 0x2f, 0x0a, 0x05,
    0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x55, 0x73, 0x65,
    0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x32, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x1a, 0x2c, 0x0a,
    0x05, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x74, 0x61, 0x74, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x74, 0x61, 0x74, 0x5f,
    0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xc2, 0x01, 0x0a, 0x16,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x55,
    0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65,
    0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x72, 0x63,
    0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x3c, 0x0a, 0x0d,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x73, 0x18, 0x04, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x53, 0x74, 0x61, 0x74, 0x73, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x2e, 0x55, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x64, 0x5f, 0x53, 0x74, 0x61, 0x74, 0x73, 0x1a, 0x34, 0x0a, 0x0d, 0x55, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x0f, 0x0a, 0x07, 0x73,
    0x74, 0x61, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a,
    0x73, 0x74, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x22, 0xbc, 0x01, 0x0a, 0x18, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53,
    0x74, 0x6f, 0x72, 0x65, 0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x12, 0x0f, 0x0a,
    0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x16,
    0x0a, 0x0e, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x5f, 0x72, 0x65, 0x73, 0x65, 0x74,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x40, 0x0a, 0x0e, 0x73, 0x74, 0x61, 0x74, 0x73, 0x5f,
    0x74, 0x6f, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x65,
    0x55, 0x73, 0x65, 0x72, 0x53, 0x74, 0x61, 0x74, 0x73, 0x2e, 0x53, 0x74, 0x61, 0x74, 0x73, 0x5f,
    0x54, 0x6f, 0x5f, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x1a, 0x35, 0x0a, 0x0e, 0x53, 0x74, 0x61, 0x74,
    0x73, 0x5f, 0x54, 0x6f, 0x5f, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x74,
    0x61, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x73,
    0x74, 0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x22,
    0x1c, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x22, 0x3f, 0x0a,
    0x24, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x70, 0x6f, 0x72,
    0x74, 0x4f, 0x76, 0x65, 0x72, 0x6c, 0x61, 0x79, 0x44, 0x65, 0x74, 0x6f, 0x75, 0x72, 0x46, 0x61,
    0x69, 0x6c, 0x75, 0x72, 0x65, 0x12, 0x17, 0x0a, 0x0f, 0x66, 0x61, 0x69, 0x6c, 0x75, 0x72, 0x65,
    0x5f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x22, 0xbf,
    0x02, 0x0a, 0x22, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x17, 0x0a, 0x0f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
    0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x18,
    0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69,
    0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0a, 0x0a, 0x02, 0x6f, 0x73, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x09, 0x12, 0x14, 0x0a, 0x0c, 0x6d, 0x61, 0x63, 0x68, 0x69, 0x6e, 0x65, 0x5f,
    0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12, 0x11, 0x0a, 0x09, 0x69, 0x70,
    0x5f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a,
    0x0a, 0x69, 0x70, 0x5f, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x17, 0x0a, 0x0f, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x61, 0x76, 0x61, 0x69, 0x6c,
    0x61, 0x62, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x12, 0x3f, 0x0a, 0x0d, 0x67, 0x61,
    0x6d, 0x65, 0x73, 0x5f, 0x72, 0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x18, 0x06, 0x20, 0x03, 0x28,
    0x0b, 0x32, 0x28, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65,
    0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x47, 0x61, 0x6d, 0x65, 0x1a, 0x43, 0x0a, 0x04, 0x47,
    0x61, 0x6d, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x65, 0x78, 0x74, 0x72, 0x61, 0x5f, 0x69, 0x6e, 0x66, 0x6f,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x18, 0x0a, 0x10, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x72,
    0x75, 0x6e, 0x6e, 0x69, 0x6e, 0x67, 0x5f, 0x73, 0x65, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d,
    0x22, 0x78, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65,
    0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x0d,
    0x0a, 0x05, 0x6d, 0x65, 0x64, 0x69, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0d, 0x0a,
    0x05, 0x74, 0x6f, 0x6f, 0x6c, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0d, 0x0a, 0x05,
    0x67, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x16, 0x0a, 0x0e, 0x6f,
    0x6e, 0x6c, 0x79, 0x5f, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x08, 0x12, 0x15, 0x0a, 0x0d, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x63, 0x68, 0x61, 0x6e,
    0x67, 0x69, 0x6e, 0x67, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x22, 0x91, 0x04, 0x0a, 0x22, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x41, 0x70, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x12, 0x35, 0x0a, 0x04, 0x61, 0x70, 0x70, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x27, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x12, 0x17, 0x0a, 0x0f, 0x62, 0x79, 0x74, 0x65,
    0x73, 0x5f, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x04, 0x1a, 0x9a, 0x03, 0x0a, 0x03, 0x41, 0x70, 0x70, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x63, 0x61, 0x74, 0x65,
    0x67, 0x6f, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08, 0x61, 0x70,
    0x70, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a, 0x08,
    0x66, 0x61, 0x76, 0x6f, 0x72, 0x69, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x11,
    0x0a, 0x09, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x08, 0x12, 0x13, 0x0a, 0x0b, 0x61, 0x75, 0x74, 0x6f, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x12, 0x18, 0x0a, 0x10, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f,
    0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04,
    0x12, 0x14, 0x0a, 0x0c, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x6e, 0x65, 0x65, 0x64, 0x65, 0x64,
    0x18, 0x07, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1b, 0x0a, 0x13, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f,
    0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x5f,
    0x70, 0x61, 0x75, 0x73, 0x65, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x08, 0x12, 0x17, 0x0a, 0x0f,
    0x6e, 0x75, 0x6d, 0x5f, 0x64, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64, 0x69, 0x6e, 0x67, 0x18,
    0x0c, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x6e, 0x75, 0x6d, 0x5f, 0x70, 0x61, 0x75,
    0x73, 0x65, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x63, 0x68, 0x61,
    0x6e, 0x67, 0x69, 0x6e, 0x67, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x08, 0x12, 0x1d, 0x0a, 0x15, 0x61,
    0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6f, 0x6e, 0x5f, 0x70, 0x6c, 0x61, 0x74,
    0x66, 0x6f, 0x72, 0x6d, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x08, 0x12, 0x39, 0x0a, 0x04, 0x64, 0x6c,
    0x63, 0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70,
    0x70, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x41, 0x70,
    0x70, 0x2e, 0x44, 0x4c, 0x43, 0x1a, 0x27, 0x0a, 0x03, 0x44, 0x4c, 0x43, 0x12, 0x0d, 0x0a, 0x05,
    0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x69,
    0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x22, 0x2b,
    0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x73, 0x74,
    0x61, 0x6c, 0x6c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x12, 0x0d, 0x0a, 0x05,
    0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x34, 0x0a, 0x22, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x22, 0x2d, 0x0a, 0x1c, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55,
    0x6e, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70,
    0x70, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x22, 0x36, 0x0a, 0x24, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x6e,
    0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73, 0x75,
    0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x42, 0x0a, 0x21, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x74, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41,
    0x70, 0x70, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x0d, 0x0a,
    0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x22, 0x3b, 0x0a, 0x29,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x65, 0x74, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x53, 0x74, 0x61, 0x74,
    0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x86, 0x02, 0x0a, 0x1e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x55, 0x70, 0x6c, 0x6f, 0x61,
    0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x06,
    0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09,
    0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x15, 0x0a, 0x0d, 0x72, 0x61, 0x77, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68, 0x61, 0x5f, 0x66, 0x69,
    0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x69, 0x6d, 0x65,
    0x5f, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x11, 0x0a, 0x09,
    0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x24, 0x0a, 0x1c, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x5f, 0x74, 0x6f, 0x5f,
    0x73, 0x79, 0x6e, 0x63, 0x5f, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x25, 0x0a, 0x11, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72,
    0x6d, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d,
    0x3a, 0x0a, 0x34, 0x32, 0x39, 0x34, 0x39, 0x36, 0x37, 0x32, 0x39, 0x35, 0x12, 0x0f, 0x0a, 0x07,
    0x63, 0x65, 0x6c, 0x6c, 0x5f, 0x69, 0x64, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a,
    0x0b, 0x63, 0x61, 0x6e, 0x5f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x18, 0x0a, 0x20, 0x01,
    0x28, 0x08, 0x22, 0xbb, 0x01, 0x0a, 0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x55, 0x46, 0x53, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68,
    0x61, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x10, 0x0a, 0x08,
    0x75, 0x73, 0x65, 0x5f, 0x68, 0x74, 0x74, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x11,
    0x0a, 0x09, 0x68, 0x74, 0x74, 0x70, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x10, 0x0a, 0x08, 0x68, 0x74, 0x74, 0x70, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x05, 0x20,
    0x01, 0x28, 0x09, 0x12, 0x12, 0x0a, 0x0a, 0x6b, 0x76, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72,
    0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x11, 0x0a, 0x09, 0x75, 0x73, 0x65, 0x5f, 0x68,
    0x74, 0x74, 0x70, 0x73, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x12, 0x14, 0x0a, 0x0c, 0x65, 0x6e,
    0x63, 0x72, 0x79, 0x70, 0x74, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08,
    0x22, 0xae, 0x01, 0x0a, 0x19, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55,
    0x46, 0x53, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x12, 0x2e,
    0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x55, 0x70, 0x6c,
    0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x1a, 0x61,
    0x0a, 0x04, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70,
    0x70, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68,
    0x61, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x10, 0x0a, 0x08,
    0x63, 0x75, 0x62, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11,
    0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28,
    0x09, 0x22, 0x99, 0x01, 0x0a, 0x21, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x55, 0x46, 0x53, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6d, 0x6d, 0x69, 0x74, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x36, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73,
    0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x55, 0x70, 0x6c, 0x6f, 0x61, 0x64, 0x43, 0x6f, 0x6d, 0x6d,
    0x69, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x1a,
    0x3c, 0x0a, 0x04, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75,
    0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x0e, 0x0a, 0x06, 0x61,
    0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x73,
    0x68, 0x61, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x4c, 0x0a,
    0x16, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x46, 0x69,
    0x6c, 0x65, 0x43, 0x68, 0x75, 0x6e, 0x6b, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68, 0x61, 0x5f, 0x66,
    0x69, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x66, 0x69, 0x6c,
    0x65, 0x5f, 0x73, 0x74, 0x61, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0c, 0x0a,
    0x04, 0x64, 0x61, 0x74, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x20, 0x0a, 0x1e, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x54, 0x72, 0x61, 0x6e,
    0x73, 0x66, 0x65, 0x72, 0x48, 0x65, 0x61, 0x72, 0x74, 0x62, 0x65, 0x61, 0x74, 0x22, 0x47, 0x0a,
    0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x55, 0x70,
    0x6c, 0x6f, 0x61, 0x64, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x69, 0x6e, 0x69, 0x73, 0x68, 0x65, 0x64,
    0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x05, 0x3a, 0x01, 0x32, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68, 0x61, 0x5f, 0x66, 0x69, 0x6c, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x22, 0x5f, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x46, 0x69, 0x6c,
    0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65,
    0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x1a, 0x0a, 0x12, 0x69,
    0x73, 0x5f, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x5f, 0x64, 0x65, 0x6c, 0x65, 0x74,
    0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x22, 0x48, 0x0a, 0x1f, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x44, 0x65, 0x6c, 0x65, 0x74, 0x65, 0x46, 0x69,
    0x6c, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72,
    0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x11,
    0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x22, 0x53, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55,
    0x46, 0x53, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x46, 0x6f, 0x72,
    0x41, 0x70, 0x70, 0x12, 0x15, 0x0a, 0x0d, 0x61, 0x70, 0x70, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x71,
    0x75, 0x65, 0x72, 0x79, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x1a, 0x0a, 0x12, 0x73, 0x65,
    0x6e, 0x64, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x65, 0x73,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x22, 0xc1, 0x02, 0x0a, 0x26, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c,
    0x69, 0x73, 0x74, 0x46, 0x6f, 0x72, 0x41, 0x70, 0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x12, 0x3b, 0x0a, 0x05, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x2c, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53,
    0x47, 0x65, 0x74, 0x46, 0x69, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x46, 0x6f, 0x72, 0x41, 0x70,
    0x70, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x15,
    0x0a, 0x0d, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x65, 0x73, 0x18,
    0x02, 0x20, 0x03, 0x28, 0x09, 0x1a, 0xb8, 0x01, 0x0a, 0x04, 0x46, 0x69, 0x6c, 0x65, 0x12, 0x0e,
    0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11,
    0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x09, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68, 0x61, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x6d,
    0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x72, 0x61, 0x77, 0x5f, 0x66,
    0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1a,
    0x0a, 0x12, 0x69, 0x73, 0x5f, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x5f, 0x64, 0x65,
    0x6c, 0x65, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x19, 0x0a, 0x11, 0x70, 0x6c,
    0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x73, 0x5f, 0x74, 0x6f, 0x5f, 0x73, 0x79, 0x6e, 0x63, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11, 0x70, 0x61, 0x74, 0x68, 0x5f, 0x70, 0x72,
    0x65, 0x66, 0x69, 0x78, 0x5f, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0d,
    0x3a, 0x08, 0x88, 0xb5, 0x18, 0x10, 0x80, 0xb5, 0x18, 0x08, 0x22, 0x5a, 0x0a, 0x1c, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x44, 0x6f, 0x77, 0x6e, 0x6c,
    0x6f, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70,
    0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x66, 0x69,
    0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x17, 0x0a,
    0x0f, 0x63, 0x61, 0x6e, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x5f, 0x68, 0x74, 0x74, 0x70,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x22, 0xa0, 0x02, 0x0a, 0x1d, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x44, 0x6f, 0x77, 0x6e, 0x6c, 0x6f, 0x61, 0x64,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x0e, 0x0a, 0x06,
    0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09,
    0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x15, 0x0a, 0x0d, 0x72, 0x61, 0x77, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65,
    0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x73, 0x68, 0x61, 0x5f, 0x66, 0x69,
    0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x69, 0x6d, 0x65,
    0x5f, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x06, 0x20, 0x01, 0x28, 0x04, 0x12, 0x1a, 0x0a, 0x12,
    0x69, 0x73, 0x5f, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x5f, 0x64, 0x65, 0x6c, 0x65,
    0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x12, 0x10, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x5f,
    0x68, 0x74, 0x74, 0x70, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x12, 0x11, 0x0a, 0x09, 0x68, 0x74,
    0x74, 0x70, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x12, 0x10, 0x0a,
    0x08, 0x68, 0x74, 0x74, 0x70, 0x5f, 0x75, 0x72, 0x6c, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x12, 0x0a, 0x0a, 0x6b, 0x76, 0x5f, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x0b, 0x20,
    0x01, 0x28, 0x0c, 0x12, 0x11, 0x0a, 0x09, 0x75, 0x73, 0x65, 0x5f, 0x68, 0x74, 0x74, 0x70, 0x73,
    0x18, 0x0c, 0x20, 0x01, 0x28, 0x08, 0x12, 0x11, 0x0a, 0x09, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70,
    0x74, 0x65, 0x64, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x08, 0x22, 0x5d, 0x0a, 0x19, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52,
    0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x18, 0x0a, 0x10, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63,
    0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x18, 0x0a, 0x10, 0x61, 0x6d, 0x5f, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74,
    0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x12, 0x0c, 0x0a, 0x04, 0x61, 0x70,
    0x70, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x22, 0x30, 0x0a, 0x1a, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65,
    0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c,
    0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x22, 0x47, 0x0a, 0x23, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x45,
    0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x41, 0x70, 0x70, 0x54, 0x69, 0x63, 0x6b, 0x65,
    0x74, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28,
    0x0d, 0x12, 0x10, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x0c, 0x22, 0x84, 0x01, 0x0a, 0x2b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
    0x65, 0x64, 0x41, 0x70, 0x70, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x31, 0x0a, 0x14, 0x65, 0x6e, 0x63, 0x72, 0x79,
    0x70, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x74, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x18,
    0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65,
    0x64, 0x41, 0x70, 0x70, 0x54, 0x69, 0x63, 0x6b, 0x65, 0x74, 0x22, 0x6c, 0x0a, 0x1a, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x57, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x49, 0x6e,
    0x66, 0x6f, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x12, 0x12, 0x0a, 0x0a, 0x68, 0x61, 0x73, 0x5f,
    0x77, 0x61, 0x6c, 0x6c, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0f, 0x0a, 0x07,
    0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x10, 0x0a,
    0x08, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x63, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x12,
    0x17, 0x0a, 0x0f, 0x62, 0x61, 0x6c, 0x61, 0x6e, 0x63, 0x65, 0x5f, 0x64, 0x65, 0x6c, 0x61, 0x79,
    0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x22, 0x4d, 0x0a, 0x17, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x55, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x12, 0x19, 0x0a, 0x11, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x63, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x17,
    0x0a, 0x0f, 0x73, 0x65, 0x6e, 0x64, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x6c, 0x69, 0x73,
    0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x22, 0x64, 0x0a, 0x18, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x43, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x73, 0x12, 0x1d, 0x0a, 0x15, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x63,
    0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x19, 0x0a, 0x11, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x5f, 0x66, 0x75, 0x6c, 0x6c,
    0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0e, 0x0a,
    0x06, 0x61, 0x70, 0x70, 0x49, 0x44, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x22, 0xab, 0x01,
    0x0a, 0x18, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x49,
    0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x2b, 0x0a, 0x04, 0x61, 0x70,
    0x70, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75,
    0x65, 0x73, 0x74, 0x2e, 0x41, 0x70, 0x70, 0x12, 0x1f, 0x0a, 0x10, 0x73, 0x75, 0x70, 0x70, 0x6f,
    0x72, 0x74, 0x73, 0x5f, 0x62, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x08, 0x3a, 0x05, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x1a, 0x41, 0x0a, 0x03, 0x41, 0x70, 0x70, 0x12,
    0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x15, 0x0a, 0x0d, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x66, 0x6c, 0x61, 0x67, 0x73,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6f,
    0x6e, 0x5f, 0x43, 0x52, 0x43, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0d, 0x22, 0x9b, 0x02, 0x0a, 0x19,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66,
    0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2c, 0x0a, 0x04, 0x61, 0x70, 0x70,
    0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x12, 0x14, 0x0a, 0x0c, 0x61, 0x70, 0x70, 0x73, 0x5f,
    0x75, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x14, 0x0a,
    0x0c, 0x61, 0x70, 0x70, 0x73, 0x5f, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20,
    0x01, 0x28, 0x0d, 0x1a, 0x99, 0x01, 0x0a, 0x03, 0x41, 0x70, 0x70, 0x12, 0x0e, 0x0a, 0x06, 0x61,
    0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x63,
    0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x38, 0x0a, 0x08, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x03,
    0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x2e, 0x41, 0x70, 0x70, 0x2e, 0x53, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x31, 0x0a, 0x07,
    0x53, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x0a, 0x73, 0x65, 0x63, 0x74, 0x69,
    0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x12, 0x0a, 0x0a, 0x73,
    0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6b, 0x76, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x3a,
    0x08, 0x80, 0xb5, 0x18, 0x00, 0x88, 0xb5, 0x18, 0x00, 0x22, 0x4b, 0x0a, 0x1c, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e,
    0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x13, 0x0a, 0x0b, 0x70, 0x61, 0x63,
    0x6b, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x16,
    0x0a, 0x0e, 0x6d, 0x65, 0x74, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x6f, 0x6e, 0x6c, 0x79,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x22, 0xe0, 0x01, 0x0a, 0x1d, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x08, 0x70, 0x61, 0x63, 0x6b,
    0x61, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e,
    0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x61,
    0x67, 0x65, 0x12, 0x18, 0x0a, 0x10, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x73, 0x5f, 0x75,
    0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x18, 0x0a, 0x10,
    0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x73, 0x5f, 0x70, 0x65, 0x6e, 0x64, 0x69, 0x6e, 0x67,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x1a, 0x51, 0x0a, 0x07, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67,
    0x65, 0x12, 0x12, 0x0a, 0x0a, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f,
    0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x0b, 0x0a, 0x03,
    0x73, 0x68, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0e, 0x0a, 0x06, 0x62, 0x75, 0x66,
    0x66, 0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x22, 0xc0, 0x01, 0x0a, 0x21, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x43, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
    0x1b, 0x0a, 0x13, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f,
    0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1d, 0x0a, 0x15,
    0x73, 0x65, 0x6e, 0x64, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x5f, 0x63, 0x68,
    0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x12, 0x21, 0x0a, 0x19, 0x73,
    0x65, 0x6e, 0x64, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f,
    0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x1b,
    0x0a, 0x13, 0x6e, 0x75, 0x6d, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x5f, 0x63,
    0x61, 0x63, 0x68, 0x65, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1f, 0x0a, 0x17, 0x6e,
    0x75, 0x6d, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x5f,
    0x63, 0x61, 0x63, 0x68, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0d, 0x22, 0xe5, 0x03, 0x0a,
    0x22, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x43,
    0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x12, 0x1d, 0x0a, 0x15, 0x63, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x5f, 0x63,
    0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x1b, 0x0a, 0x13, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x19, 0x0a, 0x11, 0x66, 0x6f, 0x72, 0x63, 0x65, 0x5f, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x75, 0x70,
    0x64, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x4a, 0x0a, 0x0f, 0x70, 0x61,
    0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x04, 0x20,
    0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x50, 0x49, 0x43, 0x53, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
    0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x42, 0x0a, 0x0b, 0x61, 0x70, 0x70, 0x5f, 0x63, 0x68,
    0x61, 0x6e, 0x67, 0x65, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x43, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x73, 0x53, 0x69, 0x6e, 0x63, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
    0x2e, 0x41, 0x70, 0x70, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x1d, 0x0a, 0x15, 0x66, 0x6f,
    0x72, 0x63, 0x65, 0x5f, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x61, 0x70, 0x70, 0x5f, 0x75, 0x70, 0x64,
    0x61, 0x74, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x21, 0x0a, 0x19, 0x66, 0x6f, 0x72,
    0x63, 0x65, 0x5f, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f,
    0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x4e, 0x0a, 0x0d,
    0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x11, 0x0a,
    0x09, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x15, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65,
    0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x13, 0x0a, 0x0b, 0x6e, 0x65, 0x65, 0x64, 0x73,
    0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x46, 0x0a, 0x09,
    0x41, 0x70, 0x70, 0x43, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70,
    0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e,
    0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12,
    0x13, 0x0a, 0x0b, 0x6e, 0x65, 0x65, 0x64, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x08, 0x22, 0xca, 0x02, 0x0a, 0x20, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x6e,
    0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3f, 0x0a, 0x08, 0x70, 0x61, 0x63,
    0x6b, 0x61, 0x67, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x50, 0x72, 0x6f, 0x64,
    0x75, 0x63, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x50,
    0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x37, 0x0a, 0x04, 0x61, 0x70,
    0x70, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74,
    0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x41, 0x70, 0x70, 0x49,
    0x6e, 0x66, 0x6f, 0x12, 0x16, 0x0a, 0x0e, 0x6d, 0x65, 0x74, 0x61, 0x5f, 0x64, 0x61, 0x74, 0x61,
    0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x17, 0x0a, 0x0f, 0x6e,
    0x75, 0x6d, 0x5f, 0x70, 0x72, 0x65, 0x76, 0x5f, 0x66, 0x61, 0x69, 0x6c, 0x65, 0x64, 0x18, 0x04,
    0x20, 0x01, 0x28, 0x0d, 0x1a, 0x43, 0x0a, 0x07, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14,
    0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x04, 0x12, 0x13, 0x0a, 0x0b, 0x6f, 0x6e, 0x6c, 0x79, 0x5f, 0x70, 0x75, 0x62,
    0x6c, 0x69, 0x63, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x1a, 0x36, 0x0a, 0x0b, 0x50, 0x61, 0x63,
    0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x61, 0x63, 0x6b,
    0x61, 0x67, 0x65, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x61,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x04, 0x22, 0xbd, 0x04, 0x0a, 0x21, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x50, 0x49, 0x43, 0x53, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52,
    0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x38, 0x0a, 0x04, 0x61, 0x70, 0x70, 0x73, 0x18,
    0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x50, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x49, 0x6e, 0x66,
    0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66,
    0x6f, 0x12, 0x16, 0x0a, 0x0e, 0x75, 0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x5f, 0x61, 0x70, 0x70,
    0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x40, 0x0a, 0x08, 0x70, 0x61, 0x63,
    0x6b, 0x61, 0x67, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x50, 0x72, 0x6f, 0x64,
    0x75, 0x63, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e,
    0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1a, 0x0a, 0x12, 0x75,
    0x6e, 0x6b, 0x6e, 0x6f, 0x77, 0x6e, 0x5f, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x69, 0x64,
    0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x16, 0x0a, 0x0e, 0x6d, 0x65, 0x74, 0x61, 0x5f,
    0x64, 0x61, 0x74, 0x61, 0x5f, 0x6f, 0x6e, 0x6c, 0x79, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x12,
    0x18, 0x0a, 0x10, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x70, 0x65, 0x6e, 0x64,
    0x69, 0x6e, 0x67, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x15, 0x0a, 0x0d, 0x68, 0x74, 0x74,
    0x70, 0x5f, 0x6d, 0x69, 0x6e, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x11, 0x0a, 0x09, 0x68, 0x74, 0x74, 0x70, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x08, 0x20,
    0x01, 0x28, 0x09, 0x1a, 0x86, 0x01, 0x0a, 0x07, 0x41, 0x70, 0x70, 0x49, 0x6e, 0x66, 0x6f, 0x12,
    0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15,
    0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67,
    0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0b, 0x0a, 0x03,
    0x73, 0x68, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0e, 0x0a, 0x06, 0x62, 0x75, 0x66,
    0x66, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x13, 0x0a, 0x0b, 0x6f, 0x6e, 0x6c,
    0x79, 0x5f, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0c,
    0x0a, 0x04, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0d, 0x1a, 0x79, 0x0a, 0x0b,
    0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x70,
    0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15,
    0x0a, 0x0d, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18,
    0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x15, 0x0a, 0x0d, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67,
    0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0b, 0x0a, 0x03,
    0x73, 0x68, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0e, 0x0a, 0x06, 0x62, 0x75, 0x66,
    0x66, 0x65, 0x72, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x0c, 0x0a, 0x04, 0x73, 0x69, 0x7a,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x3a, 0x08, 0x80, 0xb5, 0x18, 0x00, 0x88, 0xb5, 0x18,
    0x00, 0x22, 0x46, 0x0a, 0x20, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50,
    0x49, 0x43, 0x53, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x0a, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
    0x69, 0x64, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70,
    0x69, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x22, 0xdf, 0x02, 0x0a, 0x21, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x41, 0x63, 0x63, 0x65,
    0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
    0x4e, 0x0a, 0x15, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x73,
    0x73, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2f,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x41,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e,
    0x73, 0x65, 0x2e, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12,
    0x1d, 0x0a, 0x15, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x5f, 0x64, 0x65, 0x6e, 0x69, 0x65,
    0x64, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0d, 0x12, 0x46,
    0x0a, 0x11, 0x61, 0x70, 0x70, 0x5f, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74, 0x6f, 0x6b,
    0x65, 0x6e, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x50, 0x49, 0x43, 0x53, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73,
    0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x41, 0x70,
    0x70, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x19, 0x0a, 0x11, 0x61, 0x70, 0x70, 0x5f, 0x64, 0x65,
    0x6e, 0x69, 0x65, 0x64, 0x5f, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28,
    0x0d, 0x1a, 0x37, 0x0a, 0x0c, 0x50, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x54, 0x6f, 0x6b, 0x65,
    0x6e, 0x12, 0x11, 0x0a, 0x09, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x69, 0x64, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f, 0x74,
    0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x1a, 0x2f, 0x0a, 0x08, 0x41, 0x70,
    0x70, 0x54, 0x6f, 0x6b, 0x65, 0x6e, 0x12, 0x0d, 0x0a, 0x05, 0x61, 0x70, 0x70, 0x69, 0x64, 0x18,
    0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x14, 0x0a, 0x0c, 0x61, 0x63, 0x63, 0x65, 0x73, 0x73, 0x5f,
    0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x04, 0x22, 0x44, 0x0a, 0x1a, 0x43,
    0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x47, 0x65, 0x74, 0x55,
    0x47, 0x43, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x12, 0x26, 0x0a, 0x08, 0x68, 0x63, 0x6f,
    0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x3a, 0x14, 0x31, 0x38, 0x34,
    0x34, 0x36, 0x37, 0x34, 0x34, 0x30, 0x37, 0x33, 0x37, 0x30, 0x39, 0x35, 0x35, 0x31, 0x36, 0x31,
    0x35, 0x22, 0xe5, 0x01, 0x0a, 0x22, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74,
    0x55, 0x46, 0x53, 0x47, 0x65, 0x74, 0x55, 0x47, 0x43, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x0b, 0x0a, 0x03,
    0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70,
    0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x69, 0x6c,
    0x65, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x12, 0x17, 0x0a, 0x0f, 0x73,
    0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x63, 0x72, 0x65, 0x61, 0x74, 0x6f, 0x72, 0x18, 0x05,
    0x20, 0x01, 0x28, 0x06, 0x12, 0x11, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a,
    0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1c, 0x0a, 0x14, 0x63, 0x6f, 0x6d, 0x70, 0x72,
    0x65, 0x73, 0x73, 0x65, 0x64, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18,
    0x07, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x17, 0x0a, 0x0f, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x63, 0x68,
    0x65, 0x63, 0x6b, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x12, 0x19,
    0x0a, 0x11, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x5f, 0x73,
    0x68, 0x61, 0x31, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x22, 0x43, 0x0a, 0x1e, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x47, 0x65, 0x74, 0x53, 0x69, 0x6e,
    0x67, 0x6c, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x0e, 0x0a, 0x06, 0x61,
    0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x66,
    0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0xb8,
    0x01, 0x0a, 0x26, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53,
    0x47, 0x65, 0x74, 0x53, 0x69, 0x6e, 0x67, 0x6c, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x49, 0x6e, 0x66,
    0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65,
    0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x0e, 0x0a,
    0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a,
    0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09,
    0x12, 0x10, 0x0a, 0x08, 0x73, 0x68, 0x61, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x04, 0x20, 0x01,
    0x28, 0x0c, 0x12, 0x12, 0x0a, 0x0a, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x73, 0x74, 0x61, 0x6d, 0x70,
    0x18, 0x05, 0x20, 0x01, 0x28, 0x04, 0x12, 0x15, 0x0a, 0x0d, 0x72, 0x61, 0x77, 0x5f, 0x66, 0x69,
    0x6c, 0x65, 0x5f, 0x73, 0x69, 0x7a, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1a, 0x0a,
    0x12, 0x69, 0x73, 0x5f, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x5f, 0x64, 0x65, 0x6c,
    0x65, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x22, 0x3b, 0x0a, 0x16, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x53, 0x68, 0x61, 0x72, 0x65, 0x46,
    0x69, 0x6c, 0x65, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20,
    0x01, 0x28, 0x0d, 0x12, 0x11, 0x0a, 0x09, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x5c, 0x0a, 0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c,
    0x69, 0x65, 0x6e, 0x74, 0x55, 0x46, 0x53, 0x53, 0x68, 0x61, 0x72, 0x65, 0x46, 0x69, 0x6c, 0x65,
    0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73,
    0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x26, 0x0a, 0x08,
    0x68, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x3a, 0x14,
    0x31, 0x38, 0x34, 0x34, 0x36, 0x37, 0x34, 0x34, 0x30, 0x37, 0x33, 0x37, 0x30, 0x39, 0x35, 0x35,
    0x31, 0x36, 0x31, 0x35, 0x22, 0x3d, 0x0a, 0x15, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x4e, 0x65, 0x77, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x12, 0x11, 0x0a,
    0x09, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x11, 0x0a, 0x09, 0x6c, 0x6f, 0x67, 0x69, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x02, 0x20,
    0x01, 0x28, 0x09, 0x22, 0x32, 0x0a, 0x1d, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e,
    0x74, 0x4e, 0x65, 0x77, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x41, 0x63, 0x63, 0x65,
    0x70, 0x74, 0x65, 0x64, 0x12, 0x11, 0x0a, 0x09, 0x75, 0x6e, 0x69, 0x71, 0x75, 0x65, 0x5f, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x22, 0x33, 0x0a, 0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47, 0x65, 0x74, 0x43, 0x6c, 0x61, 0x6e, 0x4f, 0x66,
    0x66, 0x69, 0x63, 0x65, 0x72, 0x73, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69,
    0x64, 0x5f, 0x63, 0x6c, 0x61, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x22, 0x66, 0x0a, 0x23,
    0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47, 0x65, 0x74, 0x43,
    0x6c, 0x61, 0x6e, 0x4f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x72, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
    0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07, 0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x74, 0x65, 0x61, 0x6d,
    0x69, 0x64, 0x5f, 0x63, 0x6c, 0x61, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x15, 0x0a,
    0x0d, 0x6f, 0x66, 0x66, 0x69, 0x63, 0x65, 0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x05, 0x22, 0x90, 0x01, 0x0a, 0x21, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47, 0x65, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x4e,
    0x61, 0x6d, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x08, 0x69, 0x64,
    0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x12, 0x3a, 0x0a, 0x03,
    0x49, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47, 0x65, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f,
    0x6e, 0x61, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x2e, 0x49, 0x64,
    0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x1a, 0x1d, 0x0a, 0x0a, 0x49, 0x64, 0x49, 0x6e,
    0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x0f, 0x0a, 0x07, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69,
    0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x22, 0xc3, 0x02, 0x0a, 0x29, 0x43, 0x4d, 0x73, 0x67,
    0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47, 0x65, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f,
    0x6e, 0x61, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73,
    0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4f, 0x0a, 0x09, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
    0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x3c, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43,
    0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47, 0x65, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e,
    0x61, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x69, 0x73, 0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70,
    0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e,
    0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x1a, 0xc4, 0x01, 0x0a, 0x11, 0x4e, 0x61, 0x6d, 0x65, 0x54,
    0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x07,
    0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32,
    0x12, 0x0f, 0x0a, 0x07, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x06, 0x12, 0x58, 0x0a, 0x05, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b,
    0x32, 0x49, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x4d, 0x47,
    0x65, 0x74, 0x50, 0x65, 0x72, 0x73, 0x6f, 0x6e, 0x61, 0x4e, 0x61, 0x6d, 0x65, 0x48, 0x69, 0x73,
    0x74, 0x6f, 0x72, 0x79, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4e, 0x61, 0x6d,
    0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x2e, 0x4e,
    0x61, 0x6d, 0x65, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x1a, 0x30, 0x0a, 0x0c, 0x4e,
    0x61, 0x6d, 0x65, 0x49, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x0a, 0x6e,
    0x61, 0x6d, 0x65, 0x5f, 0x73, 0x69, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x07, 0x12,
    0x0c, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x45, 0x0a,
    0x1e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x44, 0x65, 0x72, 0x65, 0x67,
    0x69, 0x73, 0x74, 0x65, 0x72, 0x57, 0x69, 0x74, 0x68, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12,
    0x13, 0x0a, 0x0b, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01,
    0x20, 0x01, 0x28, 0x0d, 0x12, 0x0e, 0x0a, 0x06, 0x61, 0x70, 0x70, 0x5f, 0x69, 0x64, 0x18, 0x02,
    0x20, 0x01, 0x28, 0x0d, 0x22, 0x8e, 0x04, 0x0a, 0x13, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x43, 0x6c, 0x61, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x12, 0x14, 0x0a, 0x0c,
    0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x63, 0x6c, 0x61, 0x6e, 0x18, 0x01, 0x20, 0x01,
    0x28, 0x06, 0x12, 0x17, 0x0a, 0x0f, 0x6d, 0x5f, 0x75, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73,
    0x46, 0x6c, 0x61, 0x67, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x1a, 0x0a, 0x12, 0x63,
    0x6c, 0x61, 0x6e, 0x5f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x66, 0x6c, 0x61, 0x67,
    0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x30, 0x0a, 0x09, 0x6e, 0x61, 0x6d, 0x65, 0x5f,
    0x69, 0x6e, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6c, 0x61, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65,
    0x2e, 0x4e, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x34, 0x0a, 0x0b, 0x75, 0x73, 0x65,
    0x72, 0x5f, 0x63, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f,
    0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6c, 0x61, 0x6e, 0x53,
    0x74, 0x61, 0x74, 0x65, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x12,
    0x2a, 0x0a, 0x06, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32,
    0x1a, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43, 0x6c, 0x61, 0x6e,
    0x53, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x31, 0x0a, 0x0d, 0x61,
    0x6e, 0x6e, 0x6f, 0x75, 0x6e, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x18, 0x07, 0x20, 0x03,
    0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x43,
    0x6c, 0x61, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x65, 0x2e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x1a, 0x31,
    0x0a, 0x08, 0x4e, 0x61, 0x6d, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x11, 0x0a, 0x09, 0x63, 0x6c,
    0x61, 0x6e, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x12, 0x12, 0x0a,
    0x0a, 0x73, 0x68, 0x61, 0x5f, 0x61, 0x76, 0x61, 0x74, 0x61, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
    0x0c, 0x1a, 0x50, 0x0a, 0x0a, 0x55, 0x73, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x73, 0x12,
    0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x6d, 0x62, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x0e, 0x0a, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d,
    0x12, 0x10, 0x0a, 0x08, 0x63, 0x68, 0x61, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x18, 0x03, 0x20, 0x01,
    0x28, 0x0d, 0x12, 0x0f, 0x0a, 0x07, 0x69, 0x6e, 0x5f, 0x67, 0x61, 0x6d, 0x65, 0x18, 0x04, 0x20,
    0x01, 0x28, 0x0d, 0x1a, 0x60, 0x0a, 0x05, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x12, 0x0b, 0x0a, 0x03,
    0x67, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x12, 0x0a, 0x0a, 0x65, 0x76, 0x65,
    0x6e, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0d, 0x12, 0x10, 0x0a,
    0x08, 0x68, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x12,
    0x0f, 0x0a, 0x07, 0x67, 0x61, 0x6d, 0x65, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x06,
    0x12, 0x13, 0x0a, 0x0b, 0x6a, 0x75, 0x73, 0x74, 0x5f, 0x70, 0x6f, 0x73, 0x74, 0x65, 0x64, 0x18,
    0x05, 0x20, 0x01, 0x28, 0x08, 0x22, 0x72, 0x0a, 0x13, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69,
    0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x4d, 0x73, 0x67, 0x12, 0x0f, 0x0a, 0x07,
    0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x17, 0x0a,
    0x0f, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65,
    0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x20, 0x0a, 0x18, 0x72, 0x74, 0x69, 0x6d, 0x65,
    0x33, 0x32, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
    0x61, 0x6d, 0x70, 0x18, 0x04, 0x20, 0x01, 0x28, 0x07, 0x22, 0x9d, 0x01, 0x0a, 0x1b, 0x43, 0x4d,
    0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x4d, 0x73,
    0x67, 0x49, 0x6e, 0x63, 0x6f, 0x6d, 0x69, 0x6e, 0x67, 0x12, 0x14, 0x0a, 0x0c, 0x73, 0x74, 0x65,
    0x61, 0x6d, 0x69, 0x64, 0x5f, 0x66, 0x72, 0x6f, 0x6d, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12,
    0x17, 0x0a, 0x0f, 0x63, 0x68, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x79,
    0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x12, 0x1c, 0x0a, 0x14, 0x66, 0x72, 0x6f, 0x6d,
    0x5f, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x63, 0x63, 0x6f, 0x75, 0x6e, 0x74,
    0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x12, 0x0f, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
    0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x12, 0x20, 0x0a, 0x18, 0x72, 0x74, 0x69, 0x6d, 0x65,
    0x33, 0x32, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
    0x61, 0x6d, 0x70, 0x18, 0x05, 0x20, 0x01, 0x28, 0x07, 0x22, 0x52, 0x0a, 0x13, 0x43, 0x4d, 0x73,
    0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64,
    0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x69, 0x64, 0x5f, 0x74, 0x6f, 0x5f, 0x61,
    0x64, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x23, 0x0a, 0x1b, 0x61, 0x63, 0x63, 0x6f,
    0x75, 0x6e, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x6f, 0x72, 0x5f, 0x65, 0x6d, 0x61, 0x69, 0x6c,
    0x5f, 0x74, 0x6f, 0x5f, 0x61, 0x64, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x22, 0x65, 0x0a,
    0x1b, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x41, 0x64, 0x64, 0x46, 0x72,
    0x69, 0x65, 0x6e, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x12, 0x0a, 0x07,
    0x65, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x3a, 0x01, 0x32,
    0x12, 0x16, 0x0a, 0x0e, 0x73, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x69, 0x64, 0x5f, 0x61, 0x64, 0x64,
    0x65, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x06, 0x12, 0x1a, 0x0a, 0x12, 0x70, 0x65, 0x72, 0x73,
    0x6f, 0x6e, 0x61, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x61, 0x64, 0x64, 0x65, 0x64, 0x18, 0x03,
    0x20, 0x01, 0x28, 0x09, 0x22, 0x2a, 0x0a, 0x16, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65,
    0x6e, 0x74, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x12, 0x10,
    0x0a, 0x08, 0x66, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06,
    0x22, 0x36, 0x0a, 0x14, 0x43, 0x4d, 0x73, 0x67, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x48, 0x69,
    0x64, 0x65, 0x46, 0x72, 0x69, 0x65, 0x6e, 0x64, 0x12, 0x10, 0x0a, 0x08, 0x66, 0x72, 0x69, 0x65,
    0x6e, 0x64, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x06, 0x12, 0x0c, 0x0a, 0x04, 0x68, 0x69,
    0x64, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x42, 0x05, 0x48, 0x01, 0x80, 0x01, 0x00, 0x4a,
    0x95, 0x9a, 0x04, 0x0a, 0x07, 0x12, 0x05, 0x00, 0x00, 0xfa, 0x0a, 0x01, 0x0a, 0x09, 0x0a, 0x02,
    0x03, 0x00, 0x12, 0x03, 0x00, 0x07, 0x21, 0x0a, 0x09, 0x0a, 0x02, 0x03, 0x01, 0x12, 0x03, 0x01,
    0x07, 0x23, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x03, 0x00, 0x1c, 0x0a, 0x0b, 0x0a, 0x04,
    0x08, 0xe7, 0x07, 0x00, 0x12, 0x03, 0x03, 0x00, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07,
    0x00, 0x02, 0x12, 0x03, 0x03, 0x07, 0x13, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07, 0x00, 0x02,
    0x00, 0x12, 0x03, 0x03, 0x07, 0x13, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x03, 0x03, 0x07, 0x13, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x00, 0x03, 0x12,
    0x03, 0x03, 0x16, 0x1b, 0x0a, 0x08, 0x0a, 0x01, 0x08, 0x12, 0x03, 0x04, 0x00, 0x23, 0x0a, 0x0b,
    0x0a, 0x04, 0x08, 0xe7, 0x07, 0x01, 0x12, 0x03, 0x04, 0x00, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x08,
    0xe7, 0x07, 0x01, 0x02, 0x12, 0x03, 0x04, 0x07, 0x1a, 0x0a, 0x0d, 0x0a, 0x06, 0x08, 0xe7, 0x07,
    0x01, 0x02, 0x00, 0x12, 0x03, 0x04, 0x07, 0x1a, 0x0a, 0x0e, 0x0a, 0x07, 0x08, 0xe7, 0x07, 0x01,
    0x02, 0x00, 0x01, 0x12, 0x03, 0x04, 0x07, 0x1a, 0x0a, 0x0c, 0x0a, 0x05, 0x08, 0xe7, 0x07, 0x01,
    0x03, 0x12, 0x03, 0x04, 0x1d, 0x22, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x00, 0x12, 0x04, 0x06, 0x00,
    0x07, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x00, 0x01, 0x12, 0x03, 0x06, 0x08, 0x1b, 0x0a, 0x0a,
    0x0a, 0x02, 0x04, 0x01, 0x12, 0x04, 0x09, 0x00, 0x0c, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x01,
    0x01, 0x12, 0x03, 0x09, 0x08, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x01, 0x02, 0x00, 0x12, 0x03,
    0x0a, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x04, 0x12, 0x03, 0x0a, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x05, 0x12, 0x03, 0x0a, 0x11, 0x18, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x00, 0x01, 0x12, 0x03, 0x0a, 0x19, 0x27, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x01, 0x02, 0x00, 0x03, 0x12, 0x03, 0x0a, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x01, 0x02, 0x01, 0x12, 0x03, 0x0b, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01,
    0x04, 0x12, 0x03, 0x0b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x05, 0x12,
    0x03, 0x0b, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x01, 0x12, 0x03, 0x0b,
    0x17, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x01, 0x02, 0x01, 0x03, 0x12, 0x03, 0x0b, 0x1f, 0x20,
    0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x02, 0x12, 0x04, 0x0e, 0x00, 0x19, 0x01, 0x0a, 0x0a, 0x0a, 0x03,
    0x04, 0x02, 0x01, 0x12, 0x03, 0x0e, 0x08, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x00,
    0x12, 0x03, 0x0f, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x04, 0x12, 0x03,
    0x0f, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x05, 0x12, 0x03, 0x0f, 0x11,
    0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x01, 0x12, 0x03, 0x0f, 0x19, 0x27, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x00, 0x03, 0x12, 0x03, 0x0f, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x10, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x01, 0x04, 0x12, 0x03, 0x10, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01,
    0x05, 0x12, 0x03, 0x10, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x01, 0x12,
    0x03, 0x10, 0x17, 0x1c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x01, 0x03, 0x12, 0x03, 0x10,
    0x1f, 0x20, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x02, 0x12, 0x03, 0x11, 0x08, 0x2e, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x02, 0x04, 0x12, 0x03, 0x11, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x02, 0x05, 0x12, 0x03, 0x11, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x02, 0x01, 0x12, 0x03, 0x11, 0x17, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x02, 0x03, 0x12, 0x03, 0x11, 0x2c, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x03, 0x12,
    0x03, 0x12, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x04, 0x12, 0x03, 0x12,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x05, 0x12, 0x03, 0x12, 0x11, 0x16,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x01, 0x12, 0x03, 0x12, 0x17, 0x24, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x03, 0x03, 0x12, 0x03, 0x12, 0x27, 0x28, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x02, 0x02, 0x04, 0x12, 0x03, 0x13, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x04, 0x04, 0x12, 0x03, 0x13, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x05,
    0x12, 0x03, 0x13, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x01, 0x12, 0x03,
    0x13, 0x17, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x04, 0x03, 0x12, 0x03, 0x13, 0x21,
    0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x03, 0x14, 0x08, 0x26, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x05, 0x04, 0x12, 0x03, 0x14, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x05, 0x05, 0x12, 0x03, 0x14, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02,
    0x02, 0x05, 0x01, 0x12, 0x03, 0x14, 0x17, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x05,
    0x03, 0x12, 0x03, 0x14, 0x24, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x06, 0x12, 0x03,
    0x15, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06, 0x04, 0x12, 0x03, 0x15, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06, 0x05, 0x12, 0x03, 0x15, 0x11, 0x16, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x06, 0x01, 0x12, 0x03, 0x15, 0x17, 0x21, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x06, 0x03, 0x12, 0x03, 0x15, 0x24, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x02, 0x02, 0x07, 0x12, 0x03, 0x16, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07,
    0x04, 0x12, 0x03, 0x16, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x05, 0x12,
    0x03, 0x16, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x01, 0x12, 0x03, 0x16,
    0x17, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x07, 0x03, 0x12, 0x03, 0x16, 0x2a, 0x2b,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x08, 0x12, 0x03, 0x17, 0x08, 0x2c, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x02, 0x02, 0x08, 0x04, 0x12, 0x03, 0x17, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x02, 0x02, 0x08, 0x05, 0x12, 0x03, 0x17, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02,
    0x08, 0x01, 0x12, 0x03, 0x17, 0x17, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x08, 0x03,
    0x12, 0x03, 0x17, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x02, 0x02, 0x09, 0x12, 0x03, 0x18,
    0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x09, 0x04, 0x12, 0x03, 0x18, 0x08, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x02, 0x02, 0x09, 0x05, 0x12, 0x03, 0x18, 0x11, 0x16, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x02, 0x02, 0x09, 0x01, 0x12, 0x03, 0x18, 0x17, 0x29, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x02, 0x02, 0x09, 0x03, 0x12, 0x03, 0x18, 0x2c, 0x2e, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x03,
    0x12, 0x04, 0x1b, 0x00, 0x1f, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x03, 0x01, 0x12, 0x03, 0x1b,
    0x08, 0x2a, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x00, 0x12, 0x03, 0x1c, 0x08, 0x2d, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x00, 0x04, 0x12, 0x03, 0x1c, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x03, 0x02, 0x00, 0x05, 0x12, 0x03, 0x1c, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x03, 0x02, 0x00, 0x01, 0x12, 0x03, 0x1c, 0x18, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x00, 0x03, 0x12, 0x03, 0x1c, 0x2b, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x03, 0x02, 0x01, 0x12,
    0x03, 0x1d, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x04, 0x12, 0x03, 0x1d,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x05, 0x12, 0x03, 0x1d, 0x11, 0x16,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x01, 0x12, 0x03, 0x1d, 0x17, 0x1d, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x03, 0x02, 0x01, 0x03, 0x12, 0x03, 0x1d, 0x20, 0x21, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x03, 0x02, 0x02, 0x12, 0x03, 0x1e, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02,
    0x02, 0x04, 0x12, 0x03, 0x1e, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x05,
    0x12, 0x03, 0x1e, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x01, 0x12, 0x03,
    0x1e, 0x18, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x03, 0x02, 0x02, 0x03, 0x12, 0x03, 0x1e, 0x2d,
    0x2e, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x04, 0x12, 0x04, 0x21, 0x00, 0x2a, 0x01, 0x0a, 0x0a, 0x0a,
    0x03, 0x04, 0x04, 0x01, 0x12, 0x03, 0x21, 0x08, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02,
    0x00, 0x12, 0x03, 0x22, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x04, 0x12,
    0x03, 0x22, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x05, 0x12, 0x03, 0x22,
    0x11, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x01, 0x12, 0x03, 0x22, 0x19, 0x21,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x00, 0x03, 0x12, 0x03, 0x22, 0x24, 0x25, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x04, 0x02, 0x01, 0x12, 0x03, 0x23, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x01, 0x04, 0x12, 0x03, 0x23, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x01, 0x05, 0x12, 0x03, 0x23, 0x11, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x01,
    0x12, 0x03, 0x23, 0x19, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x01, 0x03, 0x12, 0x03,
    0x23, 0x23, 0x24, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x02, 0x12, 0x03, 0x24, 0x08, 0x23,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x04, 0x12, 0x03, 0x24, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x02, 0x05, 0x12, 0x03, 0x24, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x04, 0x02, 0x02, 0x01, 0x12, 0x03, 0x24, 0x18, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x02, 0x03, 0x12, 0x03, 0x24, 0x21, 0x22, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x03,
    0x12, 0x03, 0x25, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x04, 0x12, 0x03,
    0x25, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x05, 0x12, 0x03, 0x25, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x01, 0x12, 0x03, 0x25, 0x18, 0x2e, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x03, 0x03, 0x12, 0x03, 0x25, 0x31, 0x32, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x04, 0x02, 0x04, 0x12, 0x03, 0x26, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04,
    0x02, 0x04, 0x04, 0x12, 0x03, 0x26, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04,
    0x05, 0x12, 0x03, 0x26, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04, 0x01, 0x12,
    0x03, 0x26, 0x17, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x04, 0x03, 0x12, 0x03, 0x26,
    0x2b, 0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x05, 0x12, 0x03, 0x27, 0x08, 0x27, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x05, 0x04, 0x12, 0x03, 0x27, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x04, 0x02, 0x05, 0x05, 0x12, 0x03, 0x27, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x04, 0x02, 0x05, 0x01, 0x12, 0x03, 0x27, 0x18, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x05, 0x03, 0x12, 0x03, 0x27, 0x25, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x04, 0x02, 0x06, 0x12,
    0x03, 0x28, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x06, 0x04, 0x12, 0x03, 0x28,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x06, 0x05, 0x12, 0x03, 0x28, 0x11, 0x17,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x06, 0x01, 0x12, 0x03, 0x28, 0x18, 0x27, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x04, 0x02, 0x06, 0x03, 0x12, 0x03, 0x28, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x04, 0x02, 0x07, 0x12, 0x03, 0x29, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02,
    0x07, 0x04, 0x12, 0x03, 0x29, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x07, 0x05,
    0x12, 0x03, 0x29, 0x11, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x07, 0x01, 0x12, 0x03,
    0x29, 0x19, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x04, 0x02, 0x07, 0x03, 0x12, 0x03, 0x29, 0x2a,
    0x2b, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x05, 0x12, 0x04, 0x2c, 0x00, 0x5b, 0x01, 0x0a, 0x0a, 0x0a,
    0x03, 0x04, 0x05, 0x01, 0x12, 0x03, 0x2c, 0x08, 0x17, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02,
    0x00, 0x12, 0x03, 0x2d, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x04, 0x12,
    0x03, 0x2d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x05, 0x12, 0x03, 0x2d,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x01, 0x12, 0x03, 0x2d, 0x18, 0x28,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x00, 0x03, 0x12, 0x03, 0x2d, 0x2b, 0x2c, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x05, 0x02, 0x01, 0x12, 0x03, 0x2e, 0x08, 0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x01, 0x04, 0x12, 0x03, 0x2e, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x01, 0x05, 0x12, 0x03, 0x2e, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x01,
    0x12, 0x03, 0x2e, 0x18, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x01, 0x03, 0x12, 0x03,
    0x2e, 0x32, 0x33, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x02, 0x12, 0x03, 0x2f, 0x08, 0x24,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x04, 0x12, 0x03, 0x2f, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x02, 0x05, 0x12, 0x03, 0x2f, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x02, 0x01, 0x12, 0x03, 0x2f, 0x18, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x02, 0x03, 0x12, 0x03, 0x2f, 0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x03,
    0x12, 0x03, 0x30, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x04, 0x12, 0x03,
    0x30, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x05, 0x12, 0x03, 0x30, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x01, 0x12, 0x03, 0x30, 0x18, 0x27, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x03, 0x03, 0x12, 0x03, 0x30, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x04, 0x12, 0x03, 0x31, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x04, 0x04, 0x12, 0x03, 0x31, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04,
    0x05, 0x12, 0x03, 0x31, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04, 0x01, 0x12,
    0x03, 0x31, 0x18, 0x2e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x04, 0x03, 0x12, 0x03, 0x31,
    0x31, 0x32, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x05, 0x12, 0x03, 0x32, 0x08, 0x2c, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x05, 0x04, 0x12, 0x03, 0x32, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x05, 0x05, 0x12, 0x03, 0x32, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x05, 0x01, 0x12, 0x03, 0x32, 0x18, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x05, 0x03, 0x12, 0x03, 0x32, 0x2a, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x06, 0x12,
    0x03, 0x33, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x06, 0x04, 0x12, 0x03, 0x33,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x06, 0x05, 0x12, 0x03, 0x33, 0x11, 0x17,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x06, 0x01, 0x12, 0x03, 0x33, 0x18, 0x26, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x06, 0x03, 0x12, 0x03, 0x33, 0x29, 0x2a, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x07, 0x12, 0x03, 0x34, 0x08, 0x45, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x07, 0x04, 0x12, 0x03, 0x34, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x07, 0x05,
    0x12, 0x03, 0x34, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x07, 0x01, 0x12, 0x03,
    0x34, 0x16, 0x2e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x07, 0x03, 0x12, 0x03, 0x34, 0x31,
    0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x07, 0x08, 0x12, 0x03, 0x34, 0x33, 0x44, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x07, 0x07, 0x12, 0x03, 0x34, 0x3e, 0x43, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x08, 0x12, 0x03, 0x35, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x08, 0x04, 0x12, 0x03, 0x35, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x08,
    0x05, 0x12, 0x03, 0x35, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x08, 0x01, 0x12,
    0x03, 0x35, 0x18, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x08, 0x03, 0x12, 0x03, 0x35,
    0x27, 0x28, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x09, 0x12, 0x03, 0x36, 0x08, 0x36, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x09, 0x04, 0x12, 0x03, 0x36, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x09, 0x05, 0x12, 0x03, 0x36, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x09, 0x01, 0x12, 0x03, 0x36, 0x18, 0x30, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x09, 0x03, 0x12, 0x03, 0x36, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x0a, 0x12,
    0x03, 0x37, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0a, 0x04, 0x12, 0x03, 0x37,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0a, 0x05, 0x12, 0x03, 0x37, 0x11, 0x17,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0a, 0x01, 0x12, 0x03, 0x37, 0x18, 0x21, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x0a, 0x03, 0x12, 0x03, 0x37, 0x24, 0x26, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x0b, 0x12, 0x03, 0x38, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x0b, 0x04, 0x12, 0x03, 0x38, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0b, 0x05,
    0x12, 0x03, 0x38, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0b, 0x01, 0x12, 0x03,
    0x38, 0x18, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0b, 0x03, 0x12, 0x03, 0x38, 0x24,
    0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x0c, 0x12, 0x03, 0x39, 0x08, 0x37, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x0c, 0x04, 0x12, 0x03, 0x39, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x0c, 0x05, 0x12, 0x03, 0x39, 0x11, 0x18, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x0c, 0x01, 0x12, 0x03, 0x39, 0x19, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0c,
    0x03, 0x12, 0x03, 0x39, 0x34, 0x36, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x0d, 0x12, 0x03,
    0x3a, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0d, 0x04, 0x12, 0x03, 0x3a, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0d, 0x05, 0x12, 0x03, 0x3a, 0x11, 0x16, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0d, 0x01, 0x12, 0x03, 0x3a, 0x17, 0x21, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x0d, 0x03, 0x12, 0x03, 0x3a, 0x24, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x05, 0x02, 0x0e, 0x12, 0x03, 0x3b, 0x08, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0e,
    0x04, 0x12, 0x03, 0x3b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0e, 0x05, 0x12,
    0x03, 0x3b, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0e, 0x01, 0x12, 0x03, 0x3b,
    0x18, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0e, 0x03, 0x12, 0x03, 0x3b, 0x28, 0x2a,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0e, 0x08, 0x12, 0x03, 0x3b, 0x2b, 0x38, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x0e, 0x07, 0x12, 0x03, 0x3b, 0x36, 0x37, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x0f, 0x12, 0x03, 0x3c, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x0f, 0x04, 0x12, 0x03, 0x3c, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0f, 0x05,
    0x12, 0x03, 0x3c, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0f, 0x01, 0x12, 0x03,
    0x3c, 0x18, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0f, 0x03, 0x12, 0x03, 0x3c, 0x22,
    0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0f, 0x08, 0x12, 0x03, 0x3c, 0x25, 0x32, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x0f, 0x07, 0x12, 0x03, 0x3c, 0x30, 0x31, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x10, 0x12, 0x03, 0x3d, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x10, 0x04, 0x12, 0x03, 0x3d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x10,
    0x05, 0x12, 0x03, 0x3d, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x10, 0x01, 0x12,
    0x03, 0x3d, 0x17, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x10, 0x03, 0x12, 0x03, 0x3d,
    0x2c, 0x2e, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x11, 0x12, 0x03, 0x3e, 0x08, 0x2b, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x11, 0x04, 0x12, 0x03, 0x3e, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x11, 0x05, 0x12, 0x03, 0x3e, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x11, 0x01, 0x12, 0x03, 0x3e, 0x18, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x11, 0x03, 0x12, 0x03, 0x3e, 0x28, 0x2a, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x12, 0x12,
    0x03, 0x3f, 0x08, 0x37, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x12, 0x04, 0x12, 0x03, 0x3f,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x12, 0x05, 0x12, 0x03, 0x3f, 0x11, 0x18,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x12, 0x01, 0x12, 0x03, 0x3f, 0x19, 0x31, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x12, 0x03, 0x12, 0x03, 0x3f, 0x34, 0x36, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x13, 0x12, 0x03, 0x40, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x13, 0x04, 0x12, 0x03, 0x40, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x13, 0x05,
    0x12, 0x03, 0x40, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x13, 0x01, 0x12, 0x03,
    0x40, 0x18, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x13, 0x03, 0x12, 0x03, 0x40, 0x27,
    0x29, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x14, 0x12, 0x03, 0x41, 0x08, 0x26, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x14, 0x04, 0x12, 0x03, 0x41, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x14, 0x05, 0x12, 0x03, 0x41, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x14, 0x01, 0x12, 0x03, 0x41, 0x18, 0x20, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x14,
    0x03, 0x12, 0x03, 0x41, 0x23, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x15, 0x12, 0x03,
    0x42, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x15, 0x04, 0x12, 0x03, 0x42, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x15, 0x05, 0x12, 0x03, 0x42, 0x11, 0x17, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x15, 0x01, 0x12, 0x03, 0x42, 0x18, 0x29, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x15, 0x03, 0x12, 0x03, 0x42, 0x2c, 0x2e, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x05, 0x02, 0x16, 0x12, 0x03, 0x43, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x16,
    0x04, 0x12, 0x03, 0x43, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x16, 0x05, 0x12,
    0x03, 0x43, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x16, 0x01, 0x12, 0x03, 0x43,
    0x18, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x16, 0x03, 0x12, 0x03, 0x43, 0x24, 0x26,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x17, 0x12, 0x03, 0x44, 0x08, 0x4a, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x17, 0x04, 0x12, 0x03, 0x44, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x17, 0x05, 0x12, 0x03, 0x44, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x17, 0x01, 0x12, 0x03, 0x44, 0x16, 0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x17, 0x03,
    0x12, 0x03, 0x44, 0x35, 0x37, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x17, 0x08, 0x12, 0x03,
    0x44, 0x38, 0x49, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x17, 0x07, 0x12, 0x03, 0x44, 0x43,
    0x48, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x18, 0x12, 0x03, 0x45, 0x08, 0x3b, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x18, 0x04, 0x12, 0x03, 0x45, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x18, 0x05, 0x12, 0x03, 0x45, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x18, 0x01, 0x12, 0x03, 0x45, 0x18, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x18,
    0x03, 0x12, 0x03, 0x45, 0x38, 0x3a, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x19, 0x12, 0x03,
    0x46, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x19, 0x04, 0x12, 0x03, 0x46, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x19, 0x05, 0x12, 0x03, 0x46, 0x11, 0x18, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x19, 0x01, 0x12, 0x03, 0x46, 0x19, 0x2f, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x19, 0x03, 0x12, 0x03, 0x46, 0x32, 0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x05, 0x02, 0x1a, 0x12, 0x03, 0x47, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1a,
    0x04, 0x12, 0x03, 0x47, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1a, 0x05, 0x12,
    0x03, 0x47, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1a, 0x01, 0x12, 0x03, 0x47,
    0x17, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1a, 0x03, 0x12, 0x03, 0x47, 0x2c, 0x2e,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x1b, 0x12, 0x03, 0x48, 0x08, 0x2b, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x1b, 0x04, 0x12, 0x03, 0x48, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x1b, 0x05, 0x12, 0x03, 0x48, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x1b, 0x01, 0x12, 0x03, 0x48, 0x17, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1b, 0x03,
    0x12, 0x03, 0x48, 0x28, 0x2a, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x1c, 0x12, 0x03, 0x49,
    0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1c, 0x04, 0x12, 0x03, 0x49, 0x08, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1c, 0x05, 0x12, 0x03, 0x49, 0x11, 0x17, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x1c, 0x01, 0x12, 0x03, 0x49, 0x18, 0x21, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x1c, 0x03, 0x12, 0x03, 0x49, 0x24, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05,
    0x02, 0x1d, 0x12, 0x03, 0x4a, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1d, 0x04,
    0x12, 0x03, 0x4a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1d, 0x05, 0x12, 0x03,
    0x4a, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1d, 0x01, 0x12, 0x03, 0x4a, 0x17,
    0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1d, 0x03, 0x12, 0x03, 0x4a, 0x22, 0x24, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x1e, 0x12, 0x03, 0x4b, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x1e, 0x04, 0x12, 0x03, 0x4b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x1e, 0x05, 0x12, 0x03, 0x4b, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1e,
    0x01, 0x12, 0x03, 0x4b, 0x18, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1e, 0x03, 0x12,
    0x03, 0x4b, 0x24, 0x26, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x1f, 0x12, 0x03, 0x4c, 0x08,
    0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1f, 0x04, 0x12, 0x03, 0x4c, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x1f, 0x05, 0x12, 0x03, 0x4c, 0x11, 0x17, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x1f, 0x01, 0x12, 0x03, 0x4c, 0x18, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x1f, 0x03, 0x12, 0x03, 0x4c, 0x29, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02,
    0x20, 0x12, 0x03, 0x4d, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x20, 0x04, 0x12,
    0x03, 0x4d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x20, 0x05, 0x12, 0x03, 0x4d,
    0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x20, 0x01, 0x12, 0x03, 0x4d, 0x16, 0x2b,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x20, 0x03, 0x12, 0x03, 0x4d, 0x2e, 0x30, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x05, 0x02, 0x21, 0x12, 0x03, 0x4e, 0x08, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x21, 0x04, 0x12, 0x03, 0x4e, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x21, 0x05, 0x12, 0x03, 0x4e, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x21, 0x01,
    0x12, 0x03, 0x4e, 0x17, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x21, 0x03, 0x12, 0x03,
    0x4e, 0x29, 0x2b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x22, 0x12, 0x03, 0x4f, 0x08, 0x31,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x22, 0x04, 0x12, 0x03, 0x4f, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x22, 0x05, 0x12, 0x03, 0x4f, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x22, 0x01, 0x12, 0x03, 0x4f, 0x18, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x22, 0x03, 0x12, 0x03, 0x4f, 0x2e, 0x30, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x23,
    0x12, 0x03, 0x50, 0x08, 0x55, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x23, 0x04, 0x12, 0x03,
    0x50, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x23, 0x05, 0x12, 0x03, 0x50, 0x11,
    0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x23, 0x01, 0x12, 0x03, 0x50, 0x16, 0x3d, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x23, 0x03, 0x12, 0x03, 0x50, 0x40, 0x42, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x23, 0x08, 0x12, 0x03, 0x50, 0x43, 0x54, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x23, 0x07, 0x12, 0x03, 0x50, 0x4e, 0x53, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02,
    0x24, 0x12, 0x03, 0x51, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x24, 0x04, 0x12,
    0x03, 0x51, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x24, 0x05, 0x12, 0x03, 0x51,
    0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x24, 0x01, 0x12, 0x03, 0x51, 0x18, 0x25,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x24, 0x03, 0x12, 0x03, 0x51, 0x28, 0x2a, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x05, 0x02, 0x25, 0x12, 0x03, 0x52, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x25, 0x04, 0x12, 0x03, 0x52, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x25, 0x05, 0x12, 0x03, 0x52, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x25, 0x01,
    0x12, 0x03, 0x52, 0x17, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x25, 0x03, 0x12, 0x03,
    0x52, 0x2c, 0x2e, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x26, 0x12, 0x03, 0x53, 0x08, 0x3d,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x26, 0x04, 0x12, 0x03, 0x53, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x26, 0x05, 0x12, 0x03, 0x53, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x26, 0x01, 0x12, 0x03, 0x53, 0x16, 0x37, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x26, 0x03, 0x12, 0x03, 0x53, 0x3a, 0x3c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x27,
    0x12, 0x03, 0x54, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x27, 0x04, 0x12, 0x03,
    0x54, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x27, 0x05, 0x12, 0x03, 0x54, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x27, 0x01, 0x12, 0x03, 0x54, 0x18, 0x24, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x27, 0x03, 0x12, 0x03, 0x54, 0x27, 0x29, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x05, 0x02, 0x28, 0x12, 0x03, 0x55, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x28, 0x04, 0x12, 0x03, 0x55, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x28,
    0x05, 0x12, 0x03, 0x55, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x28, 0x01, 0x12,
    0x03, 0x55, 0x18, 0x2f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x28, 0x03, 0x12, 0x03, 0x55,
    0x32, 0x34, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x29, 0x12, 0x03, 0x56, 0x08, 0x2e, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x29, 0x04, 0x12, 0x03, 0x56, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x29, 0x05, 0x12, 0x03, 0x56, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x05, 0x02, 0x29, 0x01, 0x12, 0x03, 0x56, 0x18, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x29, 0x03, 0x12, 0x03, 0x56, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x2a, 0x12,
    0x03, 0x57, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2a, 0x04, 0x12, 0x03, 0x57,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2a, 0x05, 0x12, 0x03, 0x57, 0x11, 0x15,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2a, 0x01, 0x12, 0x03, 0x57, 0x16, 0x22, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x2a, 0x03, 0x12, 0x03, 0x57, 0x25, 0x27, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x05, 0x02, 0x2b, 0x12, 0x03, 0x58, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02,
    0x2b, 0x04, 0x12, 0x03, 0x58, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2b, 0x05,
    0x12, 0x03, 0x58, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2b, 0x01, 0x12, 0x03,
    0x58, 0x18, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2b, 0x03, 0x12, 0x03, 0x58, 0x2d,
    0x30, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x2c, 0x12, 0x03, 0x59, 0x08, 0x2e, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x05, 0x02, 0x2c, 0x04, 0x12, 0x03, 0x59, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x05, 0x02, 0x2c, 0x05, 0x12, 0x03, 0x59, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05,
    0x02, 0x2c, 0x01, 0x12, 0x03, 0x59, 0x18, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2c,
    0x03, 0x12, 0x03, 0x59, 0x2a, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x05, 0x02, 0x2d, 0x12, 0x03,
    0x5a, 0x08, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2d, 0x04, 0x12, 0x03, 0x5a, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2d, 0x05, 0x12, 0x03, 0x5a, 0x11, 0x15, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x05, 0x02, 0x2d, 0x01, 0x12, 0x03, 0x5a, 0x16, 0x32, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x05, 0x02, 0x2d, 0x03, 0x12, 0x03, 0x5a, 0x35, 0x38, 0x0a, 0x0a, 0x0a, 0x02, 0x04,
    0x06, 0x12, 0x04, 0x5d, 0x00, 0x74, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x06, 0x01, 0x12, 0x03,
    0x5d, 0x08, 0x1f, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x00, 0x12, 0x03, 0x5e, 0x08, 0x31,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x04, 0x12, 0x03, 0x5e, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x05, 0x12, 0x03, 0x5e, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x00, 0x01, 0x12, 0x03, 0x5e, 0x17, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x00, 0x03, 0x12, 0x03, 0x5e, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00,
    0x08, 0x12, 0x03, 0x5e, 0x23, 0x30, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x00, 0x07, 0x12,
    0x03, 0x5e, 0x2e, 0x2f, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x01, 0x12, 0x03, 0x5f, 0x08,
    0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x04, 0x12, 0x03, 0x5f, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x01, 0x05, 0x12, 0x03, 0x5f, 0x11, 0x16, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x01, 0x01, 0x12, 0x03, 0x5f, 0x17, 0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x01, 0x03, 0x12, 0x03, 0x5f, 0x37, 0x38, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02,
    0x02, 0x12, 0x03, 0x60, 0x08, 0x35, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x04, 0x12,
    0x03, 0x60, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x05, 0x12, 0x03, 0x60,
    0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x01, 0x12, 0x03, 0x60, 0x17, 0x30,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x02, 0x03, 0x12, 0x03, 0x60, 0x33, 0x34, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x06, 0x02, 0x03, 0x12, 0x03, 0x61, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x03, 0x04, 0x12, 0x03, 0x61, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x03, 0x05, 0x12, 0x03, 0x61, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x01,
    0x12, 0x03, 0x61, 0x18, 0x21, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x03, 0x03, 0x12, 0x03,
    0x61, 0x24, 0x25, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x04, 0x12, 0x03, 0x62, 0x08, 0x31,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x04, 0x04, 0x12, 0x03, 0x62, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x04, 0x05, 0x12, 0x03, 0x62, 0x11, 0x18, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x04, 0x01, 0x12, 0x03, 0x62, 0x19, 0x2c, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x04, 0x03, 0x12, 0x03, 0x62, 0x2f, 0x30, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x05,
    0x12, 0x03, 0x63, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05, 0x04, 0x12, 0x03,
    0x63, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05, 0x05, 0x12, 0x03, 0x63, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05, 0x01, 0x12, 0x03, 0x63, 0x18, 0x25, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x05, 0x03, 0x12, 0x03, 0x63, 0x28, 0x29, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x06, 0x02, 0x06, 0x12, 0x03, 0x64, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x06, 0x04, 0x12, 0x03, 0x64, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x06,
    0x05, 0x12, 0x03, 0x64, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x06, 0x01, 0x12,
    0x03, 0x64, 0x18, 0x1f, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x06, 0x03, 0x12, 0x03, 0x64,
    0x22, 0x23, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x07, 0x12, 0x03, 0x65, 0x08, 0x29, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x07, 0x04, 0x12, 0x03, 0x65, 0x08, 0x10, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x07, 0x05, 0x12, 0x03, 0x65, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x07, 0x01, 0x12, 0x03, 0x65, 0x18, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x07, 0x03, 0x12, 0x03, 0x65, 0x27, 0x28, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x08, 0x12,
    0x03, 0x66, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x08, 0x04, 0x12, 0x03, 0x66,
    0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x08, 0x05, 0x12, 0x03, 0x66, 0x11, 0x16,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x08, 0x01, 0x12, 0x03, 0x66, 0x17, 0x24, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x08, 0x03, 0x12, 0x03, 0x66, 0x27, 0x28, 0x0a, 0x0b, 0x0a, 0x04,
    0x04, 0x06, 0x02, 0x09, 0x12, 0x03, 0x67, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x09, 0x04, 0x12, 0x03, 0x67, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x09, 0x05,
    0x12, 0x03, 0x67, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x09, 0x01, 0x12, 0x03,
    0x67, 0x17, 0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x09, 0x03, 0x12, 0x03, 0x67, 0x2a,
    0x2c, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x0a, 0x12, 0x03, 0x68, 0x08, 0x3c, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x0a, 0x04, 0x12, 0x03, 0x68, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x0a, 0x05, 0x12, 0x03, 0x68, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x0a, 0x01, 0x12, 0x03, 0x68, 0x18, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0a,
    0x03, 0x12, 0x03, 0x68, 0x39, 0x3b, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x0b, 0x12, 0x03,
    0x69, 0x08, 0x34, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0b, 0x04, 0x12, 0x03, 0x69, 0x08,
    0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0b, 0x05, 0x12, 0x03, 0x69, 0x11, 0x17, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0b, 0x01, 0x12, 0x03, 0x69, 0x18, 0x2e, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x0b, 0x03, 0x12, 0x03, 0x69, 0x31, 0x33, 0x0a, 0x0b, 0x0a, 0x04, 0x04,
    0x06, 0x02, 0x0c, 0x12, 0x03, 0x6a, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0c,
    0x04, 0x12, 0x03, 0x6a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0c, 0x05, 0x12,
    0x03, 0x6a, 0x11, 0x15, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0c, 0x01, 0x12, 0x03, 0x6a,
    0x16, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0c, 0x03, 0x12, 0x03, 0x6a, 0x21, 0x23,
    0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x0d, 0x12, 0x03, 0x6b, 0x08, 0x28, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x0d, 0x04, 0x12, 0x03, 0x6b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x0d, 0x05, 0x12, 0x03, 0x6b, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x0d, 0x01, 0x12, 0x03, 0x6b, 0x18, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0d, 0x03,
    0x12, 0x03, 0x6b, 0x25, 0x27, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x0e, 0x12, 0x03, 0x6c,
    0x08, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0e, 0x04, 0x12, 0x03, 0x6c, 0x08, 0x10,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0e, 0x05, 0x12, 0x03, 0x6c, 0x11, 0x18, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x0e, 0x01, 0x12, 0x03, 0x6c, 0x19, 0x30, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x0e, 0x03, 0x12, 0x03, 0x6c, 0x33, 0x35, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06,
    0x02, 0x0f, 0x12, 0x03, 0x6d, 0x08, 0x2d, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0f, 0x04,
    0x12, 0x03, 0x6d, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0f, 0x05, 0x12, 0x03,
    0x6d, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0f, 0x01, 0x12, 0x03, 0x6d, 0x18,
    0x27, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x0f, 0x03, 0x12, 0x03, 0x6d, 0x2a, 0x2c, 0x0a,
    0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x10, 0x12, 0x03, 0x6e, 0x08, 0x2e, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x10, 0x04, 0x12, 0x03, 0x6e, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x10, 0x05, 0x12, 0x03, 0x6e, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x10,
    0x01, 0x12, 0x03, 0x6e, 0x17, 0x28, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x10, 0x03, 0x12,
    0x03, 0x6e, 0x2b, 0x2d, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x11, 0x12, 0x03, 0x6f, 0x08,
    0x37, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x11, 0x04, 0x12, 0x03, 0x6f, 0x08, 0x10, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x11, 0x05, 0x12, 0x03, 0x6f, 0x11, 0x16, 0x0a, 0x0c, 0x0a,
    0x05, 0x04, 0x06, 0x02, 0x11, 0x01, 0x12, 0x03, 0x6f, 0x17, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x11, 0x03, 0x12, 0x03, 0x6f, 0x34, 0x36, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02,
    0x12, 0x12, 0x03, 0x70, 0x08, 0x3b, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x12, 0x04, 0x12,
    0x03, 0x70, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x12, 0x05, 0x12, 0x03, 0x70,
    0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x12, 0x01, 0x12, 0x03, 0x70, 0x17, 0x35,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x12, 0x03, 0x12, 0x03, 0x70, 0x38, 0x3a, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x06, 0x02, 0x13, 0x12, 0x03, 0x71, 0x08, 0x39, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x06, 0x02, 0x13, 0x04, 0x12, 0x03, 0x71, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02,
    0x13, 0x05, 0x12, 0x03, 0x71, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x13, 0x01,
    0x12, 0x03, 0x71, 0x17, 0x33, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x13, 0x03, 0x12, 0x03,
    0x71, 0x36, 0x38, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x14, 0x12, 0x03, 0x72, 0x08, 0x38,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x14, 0x04, 0x12, 0x03, 0x72, 0x08, 0x10, 0x0a, 0x0c,
    0x0a, 0x05, 0x04, 0x06, 0x02, 0x14, 0x05, 0x12, 0x03, 0x72, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05,
    0x04, 0x06, 0x02, 0x14, 0x01, 0x12, 0x03, 0x72, 0x17, 0x32, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06,
    0x02, 0x14, 0x03, 0x12, 0x03, 0x72, 0x35, 0x37, 0x0a, 0x0b, 0x0a, 0x04, 0x04, 0x06, 0x02, 0x15,
    0x12, 0x03, 0x73, 0x08, 0x30, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x15, 0x04, 0x12, 0x03,
    0x73, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x15, 0x05, 0x12, 0x03, 0x73, 0x11,
    0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x15, 0x01, 0x12, 0x03, 0x73, 0x18, 0x2a, 0x0a,
    0x0c, 0x0a, 0x05, 0x04, 0x06, 0x02, 0x15, 0x03, 0x12, 0x03, 0x73, 0x2d, 0x2f, 0x0a, 0x0a, 0x0a,
    0x02, 0x04, 0x07, 0x12, 0x04, 0x76, 0x00, 0x77, 0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x07, 0x01,
    0x12, 0x03, 0x76, 0x08, 0x34, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x08, 0x12, 0x04, 0x79, 0x00, 0x7c,
    0x01, 0x0a, 0x0a, 0x0a, 0x03, 0x04, 0x08, 0x01, 0x12, 0x03, 0x79, 0x08, 0x3c, 0x0a, 0x0b, 0x0a,
    0x04, 0x04, 0x08, 0x02, 0x00, 0x12, 0x03, 0x7a, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08,
    0x02, 0x00, 0x04, 0x12, 0x03, 0x7a, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00,
    0x05, 0x12, 0x03, 0x7a, 0x11, 0x16, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x01, 0x12,
    0x03, 0x7a, 0x17, 0x1e, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x03, 0x12, 0x03, 0x7a,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x08, 0x12, 0x03, 0x7a, 0x23, 0x30,
    0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x00, 0x07, 0x12, 0x03, 0x7a, 0x2e, 0x2f, 0x0a, 0x0b,
    0x0a, 0x04, 0x04, 0x08, 0x02, 0x01, 0x12, 0x03, 0x7b, 0x08, 0x3c, 0x0a, 0x0c, 0x0a, 0x05, 0x04,
    0x08, 0x02, 0x01, 0x04, 0x12, 0x03, 0x7b, 0x08, 0x10, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02,
    0x01, 0x05, 0x12, 0x03, 0x7b, 0x11, 0x17, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x01,
    0x12, 0x03, 0x7b, 0x18, 0x36, 0x0a, 0x0c, 0x0a, 0x05, 0x04, 0x08, 0x02, 0x01, 0x03, 0x12, 0x03,
    0x7b, 0x39, 0x3b, 0x0a, 0x0a, 0x0a, 0x02, 0x04, 0x09, 0x12, 0x04, 0x7e, 0x00, 0x7f, 0x01, 0x0a,
    0x0a, 0x0a, 0x03, 0x04, 0x09, 0x01, 0x12, 0x03, 0x7e, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x0a, 0x12, 0x06, 0x81, 0x01, 0x00, 0x83, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0a, 0x01,
    0x12, 0x04, 0x81, 0x01, 0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0a, 0x02, 0x00, 0x12, 0x04,
    0x82, 0x01, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x82,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x05, 0x12, 0x04, 0x82, 0x01,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x01, 0x17,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x01, 0x21, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x08, 0x12, 0x04, 0x82, 0x01, 0x23, 0x30, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0a, 0x02, 0x00, 0x07, 0x12, 0x04, 0x82, 0x01, 0x2e, 0x2f, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x0b, 0x12, 0x06, 0x85, 0x01, 0x00, 0x88, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x0b, 0x01, 0x12, 0x04, 0x85, 0x01, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02,
    0x00, 0x12, 0x04, 0x86, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x86, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x05, 0x12,
    0x04, 0x86, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x01, 0x12, 0x04,
    0x86, 0x01, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x00, 0x03, 0x12, 0x04, 0x86,
    0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0b, 0x02, 0x01, 0x12, 0x04, 0x87, 0x01, 0x08,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x04, 0x12, 0x04, 0x87, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x87, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x87, 0x01, 0x18, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0b, 0x02, 0x01, 0x03, 0x12, 0x04, 0x87, 0x01, 0x23, 0x24, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x0c, 0x12, 0x06, 0x8a, 0x01, 0x00, 0x8f, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x0c, 0x01, 0x12, 0x04, 0x8a, 0x01, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x00,
    0x12, 0x04, 0x8b, 0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x8b, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x05, 0x12, 0x04,
    0x8b, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8b,
    0x01, 0x19, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8b, 0x01,
    0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8c, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8c, 0x01, 0x11, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0c, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c, 0x01, 0x19, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0c, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x0c, 0x02, 0x02, 0x12, 0x04, 0x8d, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c,
    0x02, 0x02, 0x04, 0x12, 0x04, 0x8d, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x8d, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02,
    0x01, 0x12, 0x04, 0x8d, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x02, 0x03,
    0x12, 0x04, 0x8d, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0c, 0x02, 0x03, 0x12, 0x04,
    0x8e, 0x01, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x04, 0x12, 0x04, 0x8e,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x05, 0x12, 0x04, 0x8e, 0x01,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x01, 0x12, 0x04, 0x8e, 0x01, 0x17,
    0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0c, 0x02, 0x03, 0x03, 0x12, 0x04, 0x8e, 0x01, 0x23, 0x24,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0d, 0x12, 0x06, 0x91, 0x01, 0x00, 0x96, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x0d, 0x01, 0x12, 0x04, 0x91, 0x01, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0d, 0x02, 0x00, 0x12, 0x04, 0x92, 0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x92, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x92, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x01,
    0x12, 0x04, 0x92, 0x01, 0x19, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x00, 0x03, 0x12,
    0x04, 0x92, 0x01, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x01, 0x12, 0x04, 0x93,
    0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x04, 0x12, 0x04, 0x93, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x05, 0x12, 0x04, 0x93, 0x01, 0x11,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x01, 0x12, 0x04, 0x93, 0x01, 0x19, 0x25,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x01, 0x03, 0x12, 0x04, 0x93, 0x01, 0x28, 0x29, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02, 0x02, 0x12, 0x04, 0x94, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0d, 0x02, 0x02, 0x04, 0x12, 0x04, 0x94, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0d, 0x02, 0x02, 0x05, 0x12, 0x04, 0x94, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0d, 0x02, 0x02, 0x01, 0x12, 0x04, 0x94, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d,
    0x02, 0x02, 0x03, 0x12, 0x04, 0x94, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0d, 0x02,
    0x03, 0x12, 0x04, 0x95, 0x01, 0x08, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x04,
    0x12, 0x04, 0x95, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x05, 0x12,
    0x04, 0x95, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x01, 0x12, 0x04,
    0x95, 0x01, 0x18, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0d, 0x02, 0x03, 0x03, 0x12, 0x04, 0x95,
    0x01, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0e, 0x12, 0x06, 0x98, 0x01, 0x00, 0x9a, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0e, 0x01, 0x12, 0x04, 0x98, 0x01, 0x08, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x0e, 0x02, 0x00, 0x12, 0x04, 0x99, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0e, 0x02, 0x00, 0x04, 0x12, 0x04, 0x99, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x0e, 0x02, 0x00, 0x05, 0x12, 0x04, 0x99, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0e, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x99, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x0f, 0x12, 0x06,
    0x9c, 0x01, 0x00, 0xa0, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x0f, 0x01, 0x12, 0x04, 0x9c,
    0x01, 0x08, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x00, 0x12, 0x04, 0x9d, 0x01, 0x08,
    0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x01, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9d, 0x01, 0x18, 0x1f, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x0f, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x01, 0x22, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x0f, 0x02, 0x00, 0x08, 0x12, 0x04, 0x9d, 0x01, 0x24, 0x31, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x0f, 0x02, 0x00, 0x07, 0x12, 0x04, 0x9d, 0x01, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x0f, 0x02, 0x01, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x9e, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x9e, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x9e, 0x01, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x9e, 0x01, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x0f, 0x02, 0x02, 0x12, 0x04, 0x9f,
    0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9f, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9f, 0x01, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9f, 0x01, 0x17, 0x1d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x0f, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9f, 0x01, 0x20, 0x21, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x10, 0x12, 0x06, 0xa2, 0x01, 0x00, 0xa4, 0x01, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x10, 0x01, 0x12, 0x04, 0xa2, 0x01, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x10,
    0x02, 0x00, 0x12, 0x04, 0xa3, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xa3, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xa3, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa3, 0x01, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x10, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xa3, 0x01, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x11, 0x12, 0x06, 0xa6, 0x01, 0x00, 0xa9,
    0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x11, 0x01, 0x12, 0x04, 0xa6, 0x01, 0x08, 0x23, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x00, 0x12, 0x04, 0xa7, 0x01, 0x08, 0x3e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x11, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x11, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa7, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x11, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa7, 0x01, 0x18, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa7, 0x01, 0x2d, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02,
    0x00, 0x08, 0x12, 0x04, 0xa7, 0x01, 0x2f, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x00,
    0x07, 0x12, 0x04, 0xa7, 0x01, 0x3a, 0x3c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x11, 0x02, 0x01, 0x12,
    0x04, 0xa8, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa8,
    0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa8, 0x01,
    0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x11, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa8, 0x01, 0x20,
    0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x12, 0x12, 0x06, 0xab, 0x01, 0x00, 0xb3, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x12, 0x01, 0x12, 0x04, 0xab, 0x01, 0x08, 0x18, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x12, 0x02, 0x00, 0x12, 0x04, 0xac, 0x01, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xac, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xac, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xac, 0x01, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xac, 0x01, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x01, 0x12, 0x04,
    0xad, 0x01, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x04, 0x12, 0x04, 0xad,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x05, 0x12, 0x04, 0xad, 0x01,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x01, 0x12, 0x04, 0xad, 0x01, 0x18,
    0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x01, 0x03, 0x12, 0x04, 0xad, 0x01, 0x20, 0x21,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x02, 0x12, 0x04, 0xae, 0x01, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x12, 0x02, 0x02, 0x04, 0x12, 0x04, 0xae, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x12, 0x02, 0x02, 0x05, 0x12, 0x04, 0xae, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x02, 0x01, 0x12, 0x04, 0xae, 0x01, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x02, 0x03, 0x12, 0x04, 0xae, 0x01, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12,
    0x02, 0x03, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xaf, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xaf, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xaf, 0x01, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xaf, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x04, 0x12, 0x04, 0xb0, 0x01,
    0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb0, 0x01, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb0, 0x01, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb0, 0x01, 0x18, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb0, 0x01, 0x23, 0x24, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x12, 0x02, 0x05, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x12, 0x02, 0x05, 0x04, 0x12, 0x04, 0xb1, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x12, 0x02, 0x05, 0x05, 0x12, 0x04, 0xb1, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xb1, 0x01, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xb1, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x12, 0x02, 0x06,
    0x12, 0x04, 0xb2, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xb2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x05, 0x12, 0x04,
    0xb2, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb2,
    0x01, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x12, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb2, 0x01,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x13, 0x12, 0x06, 0xb5, 0x01, 0x00, 0xb7, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x13, 0x01, 0x12, 0x04, 0xb5, 0x01, 0x08, 0x19, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x13, 0x02, 0x00, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x13, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xb6, 0x01, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xb6, 0x01, 0x16, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x13, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xb6, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x14, 0x12, 0x06, 0xb9,
    0x01, 0x00, 0xc1, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x14, 0x01, 0x12, 0x04, 0xb9, 0x01,
    0x08, 0x18, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x14, 0x03, 0x00, 0x12, 0x06, 0xba, 0x01, 0x08, 0xbe,
    0x01, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x03, 0x00, 0x01, 0x12, 0x04, 0xba, 0x01, 0x10,
    0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x14, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x01, 0x10,
    0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x01,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbb,
    0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xbb, 0x01, 0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xbb, 0x01, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x14, 0x03, 0x00, 0x02, 0x01, 0x12,
    0x04, 0xbc, 0x01, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xbc, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xbc, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xbc, 0x01, 0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03, 0x00,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xbc, 0x01, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x14, 0x03,
    0x00, 0x02, 0x02, 0x12, 0x04, 0xbd, 0x01, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14, 0x03,
    0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbd, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x14,
    0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbd, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x14, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbd, 0x01, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x14, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbd, 0x01, 0x27, 0x28, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x14, 0x02, 0x00, 0x12, 0x04, 0xc0, 0x01, 0x08, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x14, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc0, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14,
    0x02, 0x00, 0x06, 0x12, 0x04, 0xc0, 0x01, 0x11, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xc0, 0x01, 0x2a, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x14, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xc0, 0x01, 0x34, 0x35, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x15, 0x12, 0x06, 0xc3,
    0x01, 0x00, 0xc7, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x15, 0x01, 0x12, 0x04, 0xc3, 0x01,
    0x08, 0x19, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x00, 0x12, 0x04, 0xc4, 0x01, 0x08, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc4, 0x01, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc4, 0x01, 0x11, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x15, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc4, 0x01, 0x19, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x15, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc4, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x15, 0x02, 0x01, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xc5, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xc5, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xc5, 0x01, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xc5, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x15, 0x02, 0x02, 0x12, 0x04,
    0xc6, 0x01, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc6,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc6, 0x01,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x01, 0x17,
    0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x15, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc6, 0x01, 0x1f, 0x20,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x16, 0x12, 0x06, 0xc9, 0x01, 0x00, 0xcb, 0x01, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x16, 0x01, 0x12, 0x04, 0xc9, 0x01, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x16, 0x02, 0x00, 0x12, 0x04, 0xca, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xca, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xca, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xca, 0x01, 0x19, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x16, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xca, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x17, 0x12, 0x06, 0xcd, 0x01, 0x00,
    0xdf, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x17, 0x01, 0x12, 0x04, 0xcd, 0x01, 0x08, 0x1d,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x17, 0x03, 0x00, 0x12, 0x06, 0xce, 0x01, 0x08, 0xdb, 0x01, 0x09,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x03, 0x00, 0x01, 0x12, 0x04, 0xce, 0x01, 0x10, 0x1a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x01, 0x10, 0x30, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcf, 0x01, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcf, 0x01, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcf, 0x01,
    0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf,
    0x01, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xd0,
    0x01, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xd0, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xd0, 0x01, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xd0, 0x01, 0x21, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xd0, 0x01, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x02, 0x12, 0x04, 0xd1, 0x01, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xd1, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xd1, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x01, 0x20, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd1, 0x01, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xd2, 0x01, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd2, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xd2, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd2, 0x01, 0x20, 0x29, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd2, 0x01, 0x2c, 0x2d, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xd3, 0x01, 0x10, 0x2c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd3, 0x01, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd3, 0x01, 0x19,
    0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd3, 0x01,
    0x1e, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd3,
    0x01, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xd4,
    0x01, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xd4, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12,
    0x04, 0xd4, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xd4, 0x01, 0x1f, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xd4, 0x01, 0x27, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x06, 0x12, 0x04, 0xd5, 0x01, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xd5, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xd5, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd5, 0x01, 0x20, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xd5, 0x01, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x07, 0x12, 0x04, 0xd6, 0x01, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0xd6, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x00, 0x02, 0x07, 0x05, 0x12, 0x04, 0xd6, 0x01, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xd6, 0x01, 0x1f, 0x2d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12, 0x04, 0xd6, 0x01, 0x30, 0x31, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x08, 0x12, 0x04, 0xd7, 0x01, 0x10, 0x2f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x08, 0x04, 0x12, 0x04, 0xd7, 0x01, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x08, 0x05, 0x12, 0x04, 0xd7, 0x01, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04, 0xd7, 0x01,
    0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x08, 0x03, 0x12, 0x04, 0xd7,
    0x01, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02, 0x09, 0x12, 0x04, 0xd8,
    0x01, 0x10, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x09, 0x04, 0x12, 0x04,
    0xd8, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x09, 0x05, 0x12,
    0x04, 0xd8, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xd8, 0x01, 0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x09,
    0x03, 0x12, 0x04, 0xd8, 0x01, 0x38, 0x3a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x0a, 0x12, 0x04, 0xd9, 0x01, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02,
    0x0a, 0x04, 0x12, 0x04, 0xd9, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03, 0x00,
    0x02, 0x0a, 0x05, 0x12, 0x04, 0xd9, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17, 0x03,
    0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xd9, 0x01, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x17,
    0x03, 0x00, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xd9, 0x01, 0x2d, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x0b, 0x12, 0x04, 0xda, 0x01, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x17, 0x03, 0x00, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xda, 0x01, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x17, 0x03, 0x00, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xda, 0x01, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xda, 0x01, 0x20, 0x28, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x17, 0x03, 0x00, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xda, 0x01, 0x2b, 0x2d, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x01, 0x08, 0x44, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x17, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdd, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x17, 0x02, 0x00, 0x06, 0x12, 0x04, 0xdd, 0x01, 0x11, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x17, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x01, 0x33, 0x3f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x01, 0x42, 0x43, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x17, 0x02,
    0x01, 0x12, 0x04, 0xde, 0x01, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xde, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xde, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xde, 0x01, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x17, 0x02, 0x01, 0x03, 0x12, 0x04, 0xde,
    0x01, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x18, 0x12, 0x06, 0xe1, 0x01, 0x00, 0xe4, 0x01,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x18, 0x01, 0x12, 0x04, 0xe1, 0x01, 0x08, 0x15, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x18, 0x02, 0x00, 0x12, 0x04, 0xe2, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x18, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe2, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x18, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe2, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xe2, 0x01, 0x19, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe2, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x18, 0x02, 0x01,
    0x12, 0x04, 0xe3, 0x01, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xe3, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xe3, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe3,
    0x01, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x18, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe3, 0x01,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x19, 0x12, 0x06, 0xe6, 0x01, 0x00, 0xea, 0x01, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x19, 0x01, 0x12, 0x04, 0xe6, 0x01, 0x08, 0x12, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x19, 0x02, 0x00, 0x12, 0x04, 0xe7, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x19, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xe7, 0x01, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe7, 0x01, 0x19, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe7, 0x01, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x01, 0x12,
    0x04, 0xe8, 0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xe8, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe8,
    0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe8, 0x01,
    0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe8, 0x01, 0x26,
    0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x19, 0x02, 0x02, 0x12, 0x04, 0xe9, 0x01, 0x08, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe9, 0x01, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x19, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe9, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x19, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x01, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x19, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe9, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x1a, 0x12, 0x06, 0xec, 0x01, 0x00, 0xef, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1a, 0x01,
    0x12, 0x04, 0xec, 0x01, 0x08, 0x12, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x00, 0x12, 0x04,
    0xed, 0x01, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xed,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xed, 0x01,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xed, 0x01, 0x19,
    0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xed, 0x01, 0x24, 0x25,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1a, 0x02, 0x01, 0x12, 0x04, 0xee, 0x01, 0x08, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xee, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xee, 0x01, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xee, 0x01, 0x17, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xee, 0x01, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1b,
    0x12, 0x06, 0xf1, 0x01, 0x00, 0xf8, 0x01, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1b, 0x01, 0x12,
    0x04, 0xf1, 0x01, 0x08, 0x1a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x00, 0x12, 0x04, 0xf2,
    0x01, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf2, 0x01,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf2, 0x01, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf2, 0x01, 0x18, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf2, 0x01, 0x26, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf3, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf3, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf3, 0x01, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xf3, 0x01, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02,
    0x02, 0x12, 0x04, 0xf4, 0x01, 0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xf4, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xf4, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xf4, 0x01, 0x18, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf4,
    0x01, 0x37, 0x38, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x03, 0x12, 0x04, 0xf5, 0x01, 0x08,
    0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x04, 0x12, 0x04, 0xf5, 0x01, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x06, 0x12, 0x04, 0xf5, 0x01, 0x11, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf5, 0x01, 0x21, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1b, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf5, 0x01, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x1b, 0x02, 0x04, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1b, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf6, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xf6, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xf6, 0x01, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xf6, 0x01, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1b, 0x02, 0x05, 0x12,
    0x04, 0xf7, 0x01, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xf7, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x05, 0x05, 0x12, 0x04, 0xf7,
    0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf7, 0x01,
    0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1b, 0x02, 0x05, 0x03, 0x12, 0x04, 0xf7, 0x01, 0x2b,
    0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1c, 0x12, 0x06, 0xfa, 0x01, 0x00, 0xfe, 0x01, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x1c, 0x01, 0x12, 0x04, 0xfa, 0x01, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1c, 0x02, 0x00, 0x12, 0x04, 0xfb, 0x01, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xfb, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xfb, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xfb, 0x01, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xfb, 0x01, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x01, 0x12, 0x04,
    0xfc, 0x01, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xfc,
    0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xfc, 0x01,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xfc, 0x01, 0x18,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xfc, 0x01, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1c, 0x02, 0x02, 0x12, 0x04, 0xfd, 0x01, 0x08, 0x2d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1c, 0x02, 0x02, 0x04, 0x12, 0x04, 0xfd, 0x01, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1c, 0x02, 0x02, 0x05, 0x12, 0x04, 0xfd, 0x01, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1c, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfd, 0x01, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1c, 0x02, 0x02, 0x03, 0x12, 0x04, 0xfd, 0x01, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x1d,
    0x12, 0x06, 0x80, 0x02, 0x00, 0x8b, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x1d, 0x01, 0x12,
    0x04, 0x80, 0x02, 0x08, 0x1d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1d, 0x03, 0x00, 0x12, 0x06, 0x81,
    0x02, 0x08, 0x84, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x03, 0x00, 0x01, 0x12, 0x04,
    0x81, 0x02, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04,
    0x82, 0x02, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x82, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x82, 0x02, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x82, 0x02, 0x21, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x82, 0x02, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1d, 0x03, 0x00,
    0x02, 0x01, 0x12, 0x04, 0x83, 0x02, 0x10, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x83, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x83, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1d,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x83, 0x02, 0x20, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1d, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83, 0x02, 0x36, 0x37, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x1d, 0x02, 0x00, 0x12, 0x04, 0x86, 0x02, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x86, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02,
    0x00, 0x05, 0x12, 0x04, 0x86, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x86, 0x02, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x86, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x01, 0x12, 0x04,
    0x87, 0x02, 0x08, 0x3b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x04, 0x12, 0x04, 0x87,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x06, 0x12, 0x04, 0x87, 0x02,
    0x11, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x01, 0x12, 0x04, 0x87, 0x02, 0x2f,
    0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x01, 0x03, 0x12, 0x04, 0x87, 0x02, 0x39, 0x3a,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x02, 0x12, 0x04, 0x88, 0x02, 0x08, 0x2d, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1d, 0x02, 0x02, 0x04, 0x12, 0x04, 0x88, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1d, 0x02, 0x02, 0x05, 0x12, 0x04, 0x88, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1d, 0x02, 0x02, 0x01, 0x12, 0x04, 0x88, 0x02, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x1d, 0x02, 0x02, 0x03, 0x12, 0x04, 0x88, 0x02, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d,
    0x02, 0x03, 0x12, 0x04, 0x89, 0x02, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x03,
    0x04, 0x12, 0x04, 0x89, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x03, 0x05,
    0x12, 0x04, 0x89, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x03, 0x01, 0x12,
    0x04, 0x89, 0x02, 0x18, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x03, 0x03, 0x12, 0x04,
    0x89, 0x02, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1d, 0x02, 0x04, 0x12, 0x04, 0x8a, 0x02,
    0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x04, 0x04, 0x12, 0x04, 0x8a, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x04, 0x05, 0x12, 0x04, 0x8a, 0x02, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x04, 0x01, 0x12, 0x04, 0x8a, 0x02, 0x16, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1d, 0x02, 0x04, 0x03, 0x12, 0x04, 0x8a, 0x02, 0x2a, 0x2b, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x1e, 0x12, 0x06, 0x8d, 0x02, 0x00, 0x9c, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x1e, 0x01, 0x12, 0x04, 0x8d, 0x02, 0x08, 0x23, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1e, 0x03,
    0x00, 0x12, 0x06, 0x8e, 0x02, 0x08, 0x91, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x03,
    0x00, 0x01, 0x12, 0x04, 0x8e, 0x02, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1e, 0x03, 0x00,
    0x02, 0x00, 0x12, 0x04, 0x8f, 0x02, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x8f, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8f, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8f, 0x02, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1e, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8f, 0x02, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x1e, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x90, 0x02, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1e, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x90, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1e, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x90, 0x02, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1e, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x90, 0x02, 0x20, 0x2c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x90, 0x02, 0x2f, 0x30,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1e, 0x03, 0x01, 0x12, 0x06, 0x93, 0x02, 0x08, 0x96, 0x02, 0x09,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x03, 0x01, 0x01, 0x12, 0x04, 0x93, 0x02, 0x10, 0x26, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0x94, 0x02, 0x10, 0x2f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x02, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94, 0x02, 0x19,
    0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x02,
    0x21, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94,
    0x02, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0x95,
    0x02, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x95, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x95, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x95, 0x02, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1e, 0x03, 0x01, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x95, 0x02, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x00, 0x12,
    0x04, 0x98, 0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x98, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x05, 0x12, 0x04, 0x98,
    0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x01, 0x12, 0x04, 0x98, 0x02,
    0x16, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x00, 0x03, 0x12, 0x04, 0x98, 0x02, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x01, 0x12, 0x04, 0x99, 0x02, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x01, 0x04, 0x12, 0x04, 0x99, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1e, 0x02, 0x01, 0x05, 0x12, 0x04, 0x99, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1e, 0x02, 0x01, 0x01, 0x12, 0x04, 0x99, 0x02, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1e, 0x02, 0x01, 0x03, 0x12, 0x04, 0x99, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1e, 0x02, 0x02, 0x12, 0x04, 0x9a, 0x02, 0x08, 0x4b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x9a, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02,
    0x06, 0x12, 0x04, 0x9a, 0x02, 0x11, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x01,
    0x12, 0x04, 0x9a, 0x02, 0x3a, 0x46, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x02, 0x03, 0x12,
    0x04, 0x9a, 0x02, 0x49, 0x4a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1e, 0x02, 0x03, 0x12, 0x04, 0x9b,
    0x02, 0x08, 0x55, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x04, 0x12, 0x04, 0x9b, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x06, 0x12, 0x04, 0x9b, 0x02, 0x11,
    0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x01, 0x12, 0x04, 0x9b, 0x02, 0x45, 0x50,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1e, 0x02, 0x03, 0x03, 0x12, 0x04, 0x9b, 0x02, 0x53, 0x54, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x1f, 0x12, 0x06, 0x9e, 0x02, 0x00, 0xa7, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x1f, 0x01, 0x12, 0x04, 0x9e, 0x02, 0x08, 0x24, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x1f,
    0x03, 0x00, 0x12, 0x06, 0x9f, 0x02, 0x08, 0xa2, 0x02, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f,
    0x03, 0x00, 0x01, 0x12, 0x04, 0x9f, 0x02, 0x10, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x1f, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xa0, 0x02, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa0, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa0, 0x02, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x1f, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa0, 0x02, 0x21, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x1f, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa0, 0x02, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa1, 0x02, 0x10, 0x2d, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa1, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa1, 0x02, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x02, 0x20, 0x28,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x1f, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa1, 0x02, 0x2b,
    0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x00, 0x12, 0x04, 0xa4, 0x02, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa4, 0x02, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x1f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa4, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x1f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa4, 0x02, 0x16, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x1f, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa4, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x1f, 0x02, 0x01, 0x12, 0x04, 0xa5, 0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xa5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xa5, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa5, 0x02, 0x16, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xa5, 0x02, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x1f, 0x02, 0x02, 0x12, 0x04, 0xa6,
    0x02, 0x08, 0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa6, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x02, 0x06, 0x12, 0x04, 0xa6, 0x02, 0x11,
    0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa6, 0x02, 0x3e, 0x47,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x1f, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa6, 0x02, 0x4a, 0x4b, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x20, 0x12, 0x06, 0xa9, 0x02, 0x00, 0xac, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x20, 0x01, 0x12, 0x04, 0xa9, 0x02, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20,
    0x02, 0x00, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xaa, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xaa, 0x02, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xaa, 0x02, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xaa, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x20, 0x02, 0x01, 0x12, 0x04, 0xab, 0x02,
    0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x04, 0x12, 0x04, 0xab, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x05, 0x12, 0x04, 0xab, 0x02, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x01, 0x12, 0x04, 0xab, 0x02, 0x18, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x20, 0x02, 0x01, 0x03, 0x12, 0x04, 0xab, 0x02, 0x23, 0x24, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x21, 0x12, 0x06, 0xae, 0x02, 0x00, 0xb0, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x21, 0x01, 0x12, 0x04, 0xae, 0x02, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x21, 0x02,
    0x00, 0x12, 0x04, 0xaf, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xaf, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xaf, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xaf, 0x02, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x21, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaf,
    0x02, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x22, 0x12, 0x06, 0xb2, 0x02, 0x00, 0xc8, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x22, 0x01, 0x12, 0x04, 0xb2, 0x02, 0x08, 0x1d, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x22, 0x03, 0x00, 0x12, 0x06, 0xb3, 0x02, 0x08, 0xc4, 0x02, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x22, 0x03, 0x00, 0x01, 0x12, 0x04, 0xb3, 0x02, 0x10, 0x17, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb4, 0x02, 0x10, 0x2f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb4, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb4, 0x02, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb4, 0x02, 0x20, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb4, 0x02, 0x2d,
    0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xb5, 0x02, 0x10,
    0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb5, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb5,
    0x02, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xb5, 0x02, 0x21, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xb5, 0x02, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x02, 0x12,
    0x04, 0xb6, 0x02, 0x10, 0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xb6, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xb6, 0x02, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xb6, 0x02, 0x21, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xb6, 0x02, 0x35, 0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x03, 0x12, 0x04, 0xb7, 0x02, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb7, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22,
    0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb7, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x22, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb7, 0x02, 0x1f, 0x2b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x22, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb7, 0x02, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xb8, 0x02, 0x10, 0x30, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb8, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb8, 0x02, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb8, 0x02, 0x1f, 0x2b,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb8, 0x02, 0x2e,
    0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xb9, 0x02, 0x10,
    0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xb9, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xb9,
    0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04,
    0xb9, 0x02, 0x20, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12,
    0x04, 0xb9, 0x02, 0x31, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x06, 0x12,
    0x04, 0xba, 0x02, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x06, 0x04,
    0x12, 0x04, 0xba, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x06,
    0x05, 0x12, 0x04, 0xba, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xba, 0x02, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00,
    0x02, 0x06, 0x03, 0x12, 0x04, 0xba, 0x02, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x07, 0x12, 0x04, 0xbb, 0x02, 0x10, 0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0xbb, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22,
    0x03, 0x00, 0x02, 0x07, 0x05, 0x12, 0x04, 0xbb, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x22, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04, 0xbb, 0x02, 0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x22, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12, 0x04, 0xbb, 0x02, 0x38, 0x39, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x08, 0x12, 0x04, 0xbc, 0x02, 0x10, 0x31, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x08, 0x04, 0x12, 0x04, 0xbc, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x08, 0x05, 0x12, 0x04, 0xbc, 0x02, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x08, 0x01, 0x12, 0x04, 0xbc, 0x02, 0x20, 0x2c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x08, 0x03, 0x12, 0x04, 0xbc, 0x02, 0x2f,
    0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x09, 0x12, 0x04, 0xbd, 0x02, 0x10,
    0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x09, 0x04, 0x12, 0x04, 0xbd, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x09, 0x05, 0x12, 0x04, 0xbd,
    0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x09, 0x01, 0x12, 0x04,
    0xbd, 0x02, 0x1f, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x09, 0x03, 0x12,
    0x04, 0xbd, 0x02, 0x30, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0a, 0x12,
    0x04, 0xbe, 0x02, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0a, 0x04,
    0x12, 0x04, 0xbe, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0a,
    0x05, 0x12, 0x04, 0xbe, 0x02, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02,
    0x0a, 0x01, 0x12, 0x04, 0xbe, 0x02, 0x1f, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00,
    0x02, 0x0a, 0x03, 0x12, 0x04, 0xbe, 0x02, 0x2f, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x0b, 0x12, 0x04, 0xbf, 0x02, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xbf, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22,
    0x03, 0x00, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xbf, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x22, 0x03, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xbf, 0x02, 0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x22, 0x03, 0x00, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xbf, 0x02, 0x2b, 0x2d, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0c, 0x12, 0x04, 0xc0, 0x02, 0x10, 0x34, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xc0, 0x02, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xc0, 0x02, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xc0, 0x02, 0x20, 0x2e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xc0, 0x02, 0x31,
    0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0d, 0x12, 0x04, 0xc1, 0x02, 0x10,
    0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0d, 0x04, 0x12, 0x04, 0xc1, 0x02,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0d, 0x05, 0x12, 0x04, 0xc1,
    0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x04,
    0xc1, 0x02, 0x20, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0d, 0x03, 0x12,
    0x04, 0xc1, 0x02, 0x34, 0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0e, 0x12,
    0x04, 0xc2, 0x02, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0e, 0x04,
    0x12, 0x04, 0xc2, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02, 0x0e,
    0x05, 0x12, 0x04, 0xc2, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00, 0x02,
    0x0e, 0x01, 0x12, 0x04, 0xc2, 0x02, 0x20, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03, 0x00,
    0x02, 0x0e, 0x03, 0x12, 0x04, 0xc2, 0x02, 0x31, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x0f, 0x12, 0x04, 0xc3, 0x02, 0x10, 0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22, 0x03,
    0x00, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xc3, 0x02, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x22,
    0x03, 0x00, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xc3, 0x02, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x22, 0x03, 0x00, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xc3, 0x02, 0x20, 0x31, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x22, 0x03, 0x00, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xc3, 0x02, 0x34, 0x36, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x22, 0x02, 0x00, 0x12, 0x04, 0xc6, 0x02, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x22, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc6, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xc6, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xc6, 0x02, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xc6, 0x02, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x08,
    0x12, 0x04, 0xc6, 0x02, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x00, 0x07, 0x12,
    0x04, 0xc6, 0x02, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x22, 0x02, 0x01, 0x12, 0x04, 0xc7,
    0x02, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc7, 0x02,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x06, 0x12, 0x04, 0xc7, 0x02, 0x11,
    0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc7, 0x02, 0x30, 0x38,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x22, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc7, 0x02, 0x3b, 0x3c, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x23, 0x12, 0x06, 0xca, 0x02, 0x00, 0xd0, 0x02, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x23, 0x01, 0x12, 0x04, 0xca, 0x02, 0x08, 0x1d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23,
    0x02, 0x00, 0x12, 0x04, 0xcb, 0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xcb, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xcb, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xcb, 0x02, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xcb, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x01, 0x12, 0x04, 0xcc, 0x02,
    0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcc, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcc, 0x02, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcc, 0x02, 0x17, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcc, 0x02, 0x28, 0x29, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x23, 0x02, 0x02, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x23, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcd, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x23, 0x02, 0x02, 0x05, 0x12, 0x04, 0xcd, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x02, 0x17, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xcd, 0x02, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x03,
    0x12, 0x04, 0xce, 0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xce, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xce, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x01, 0x12, 0x04, 0xce,
    0x02, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x03, 0x03, 0x12, 0x04, 0xce, 0x02,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x23, 0x02, 0x04, 0x12, 0x04, 0xcf, 0x02, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x04, 0x04, 0x12, 0x04, 0xcf, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x23, 0x02, 0x04, 0x05, 0x12, 0x04, 0xcf, 0x02, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x23, 0x02, 0x04, 0x01, 0x12, 0x04, 0xcf, 0x02, 0x17, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x23, 0x02, 0x04, 0x03, 0x12, 0x04, 0xcf, 0x02, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x24, 0x12, 0x06, 0xd2, 0x02, 0x00, 0xd8, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x24,
    0x01, 0x12, 0x04, 0xd2, 0x02, 0x08, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x00, 0x12,
    0x04, 0xd3, 0x02, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xd3, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd3,
    0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd3, 0x02,
    0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd3, 0x02, 0x21,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x08, 0x12, 0x04, 0xd3, 0x02, 0x23, 0x30,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x00, 0x07, 0x12, 0x04, 0xd3, 0x02, 0x2e, 0x2f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x02, 0x08, 0x33, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x24, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd4, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x24, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd4, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x24, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd4, 0x02, 0x17, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xd4, 0x02, 0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02,
    0x02, 0x12, 0x04, 0xd5, 0x02, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x04,
    0x12, 0x04, 0xd5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xd5, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xd5, 0x02, 0x16, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd5,
    0x02, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x24, 0x02, 0x03, 0x12, 0x04, 0xd6, 0x02, 0x08,
    0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd6, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x05, 0x12, 0x04, 0xd6, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd6, 0x02, 0x17, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x24, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd6, 0x02, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x24, 0x02, 0x04, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x24, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd7, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24,
    0x02, 0x04, 0x05, 0x12, 0x04, 0xd7, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xd7, 0x02, 0x17, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x24, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xd7, 0x02, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x25, 0x12, 0x06, 0xda,
    0x02, 0x00, 0xde, 0x02, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x25, 0x01, 0x12, 0x04, 0xda, 0x02,
    0x08, 0x1b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x00, 0x12, 0x04, 0xdb, 0x02, 0x08, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdb, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdb, 0x02, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x25, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdb, 0x02, 0x18, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x25, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdb, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x25, 0x02, 0x01, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xdc, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xdc, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xdc, 0x02, 0x17, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xdc, 0x02, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x25, 0x02, 0x02, 0x12, 0x04,
    0xdd, 0x02, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdd,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x02, 0x05, 0x12, 0x04, 0xdd, 0x02,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x02, 0x01, 0x12, 0x04, 0xdd, 0x02, 0x19,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x25, 0x02, 0x02, 0x03, 0x12, 0x04, 0xdd, 0x02, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x26, 0x12, 0x06, 0xe0, 0x02, 0x00, 0xe2, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x26, 0x01, 0x12, 0x04, 0xe0, 0x02, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x26, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x02, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xe1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xe1, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xe1, 0x02, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xe1, 0x02, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x08, 0x12, 0x04,
    0xe1, 0x02, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x26, 0x02, 0x00, 0x07, 0x12, 0x04, 0xe1,
    0x02, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x27, 0x12, 0x06, 0xe4, 0x02, 0x00, 0xea, 0x02,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x27, 0x01, 0x12, 0x04, 0xe4, 0x02, 0x08, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x27, 0x02, 0x00, 0x12, 0x04, 0xe5, 0x02, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x27, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe5, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x27, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe5, 0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xe5, 0x02, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe5, 0x02, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x01,
    0x12, 0x04, 0xe6, 0x02, 0x08, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xe6, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xe6, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe6,
    0x02, 0x17, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe6, 0x02,
    0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x02, 0x12, 0x04, 0xe7, 0x02, 0x08, 0x34,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe7, 0x02, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe7, 0x02, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x27, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe7, 0x02, 0x17, 0x2f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x27, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe7, 0x02, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x27, 0x02, 0x03, 0x12, 0x04, 0xe8, 0x02, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xe8, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02,
    0x03, 0x05, 0x12, 0x04, 0xe8, 0x02, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xe8, 0x02, 0x16, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x03, 0x03,
    0x12, 0x04, 0xe8, 0x02, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x27, 0x02, 0x04, 0x12, 0x04,
    0xe9, 0x02, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe9,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe9, 0x02,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe9, 0x02, 0x18,
    0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x27, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe9, 0x02, 0x2b, 0x2c,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x28, 0x12, 0x06, 0xec, 0x02, 0x00, 0xf3, 0x02, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x28, 0x01, 0x12, 0x04, 0xec, 0x02, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x28, 0x02, 0x00, 0x12, 0x04, 0xed, 0x02, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xed, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xed, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xed, 0x02, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xed, 0x02, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x08, 0x12, 0x04,
    0xed, 0x02, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x00, 0x07, 0x12, 0x04, 0xed,
    0x02, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x01, 0x12, 0x04, 0xee, 0x02, 0x08,
    0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x04, 0x12, 0x04, 0xee, 0x02, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x05, 0x12, 0x04, 0xee, 0x02, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x01, 0x12, 0x04, 0xee, 0x02, 0x17, 0x25, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x28, 0x02, 0x01, 0x03, 0x12, 0x04, 0xee, 0x02, 0x28, 0x29, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x28, 0x02, 0x02, 0x12, 0x04, 0xef, 0x02, 0x08, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x28, 0x02, 0x02, 0x04, 0x12, 0x04, 0xef, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xef, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xef, 0x02, 0x17, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xef, 0x02, 0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x03, 0x12,
    0x04, 0xf0, 0x02, 0x08, 0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xf0, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x03, 0x05, 0x12, 0x04, 0xf0,
    0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf0, 0x02,
    0x17, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf0, 0x02, 0x31,
    0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x03, 0x08, 0x12, 0x04, 0xf0, 0x02, 0x33, 0x40,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x03, 0x07, 0x12, 0x04, 0xf0, 0x02, 0x3e, 0x3f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x04, 0x12, 0x04, 0xf1, 0x02, 0x08, 0x42, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x28, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf1, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x28, 0x02, 0x04, 0x05, 0x12, 0x04, 0xf1, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x28, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf1, 0x02, 0x17, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xf1, 0x02, 0x32, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02,
    0x04, 0x08, 0x12, 0x04, 0xf1, 0x02, 0x34, 0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x04,
    0x07, 0x12, 0x04, 0xf1, 0x02, 0x3f, 0x40, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x28, 0x02, 0x05, 0x12,
    0x04, 0xf2, 0x02, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xf2, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x05, 0x05, 0x12, 0x04, 0xf2,
    0x02, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x05, 0x01, 0x12, 0x04, 0xf2, 0x02,
    0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x28, 0x02, 0x05, 0x03, 0x12, 0x04, 0xf2, 0x02, 0x2b,
    0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x29, 0x12, 0x06, 0xf5, 0x02, 0x00, 0xfc, 0x02, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x29, 0x01, 0x12, 0x04, 0xf5, 0x02, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x29, 0x02, 0x00, 0x12, 0x04, 0xf6, 0x02, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xf6, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xf6, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xf6, 0x02, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xf6, 0x02, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x01, 0x12, 0x04,
    0xf7, 0x02, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf7,
    0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf7, 0x02,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf7, 0x02, 0x17,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf7, 0x02, 0x28, 0x29,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x02, 0x12, 0x04, 0xf8, 0x02, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x29, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf8, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x29, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf8, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x29, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf8, 0x02, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x29, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf8, 0x02, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29,
    0x02, 0x03, 0x12, 0x04, 0xf9, 0x02, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xf9, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xf9, 0x02, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xf9, 0x02, 0x17, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xf9, 0x02, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x29, 0x02, 0x04, 0x12, 0x04, 0xfa, 0x02,
    0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x04, 0x04, 0x12, 0x04, 0xfa, 0x02, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x04, 0x05, 0x12, 0x04, 0xfa, 0x02, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x04, 0x01, 0x12, 0x04, 0xfa, 0x02, 0x17, 0x2f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02, 0x04, 0x03, 0x12, 0x04, 0xfa, 0x02, 0x32, 0x33, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x29, 0x02, 0x05, 0x12, 0x04, 0xfb, 0x02, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x29, 0x02, 0x05, 0x04, 0x12, 0x04, 0xfb, 0x02, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x29, 0x02, 0x05, 0x05, 0x12, 0x04, 0xfb, 0x02, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29,
    0x02, 0x05, 0x01, 0x12, 0x04, 0xfb, 0x02, 0x19, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x29, 0x02,
    0x05, 0x03, 0x12, 0x04, 0xfb, 0x02, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2a, 0x12, 0x06,
    0xfe, 0x02, 0x00, 0x8a, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2a, 0x01, 0x12, 0x04, 0xfe,
    0x02, 0x08, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2a, 0x03, 0x00, 0x12, 0x06, 0xff, 0x02, 0x08,
    0x85, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x03, 0x00, 0x01, 0x12, 0x04, 0xff, 0x02,
    0x10, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x80, 0x03,
    0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x80,
    0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04,
    0x80, 0x03, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12,
    0x04, 0x80, 0x03, 0x21, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x80, 0x03, 0x31, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x01,
    0x12, 0x04, 0x81, 0x03, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x01,
    0x04, 0x12, 0x04, 0x81, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02,
    0x01, 0x05, 0x12, 0x04, 0x81, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x81, 0x03, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03,
    0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x81, 0x03, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2a,
    0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x82, 0x03, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a,
    0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x82, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2a, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x82, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x2a, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x82, 0x03, 0x1f, 0x24, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x82, 0x03, 0x27, 0x28, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x83, 0x03, 0x10, 0x2b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x83, 0x03, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x83, 0x03, 0x19, 0x1e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x83, 0x03, 0x1f,
    0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0x83, 0x03,
    0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0x84, 0x03,
    0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0x84,
    0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04,
    0x84, 0x03, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12,
    0x04, 0x84, 0x03, 0x21, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2a, 0x03, 0x00, 0x02, 0x04, 0x03,
    0x12, 0x04, 0x84, 0x03, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x00, 0x12, 0x04,
    0x87, 0x03, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x04, 0x12, 0x04, 0x87,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x05, 0x12, 0x04, 0x87, 0x03,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x01, 0x12, 0x04, 0x87, 0x03, 0x17,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x03, 0x12, 0x04, 0x87, 0x03, 0x21, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x08, 0x12, 0x04, 0x87, 0x03, 0x23, 0x30, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x00, 0x07, 0x12, 0x04, 0x87, 0x03, 0x2e, 0x2f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x2a, 0x02, 0x01, 0x12, 0x04, 0x88, 0x03, 0x08, 0x33, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2a, 0x02, 0x01, 0x04, 0x12, 0x04, 0x88, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2a, 0x02, 0x01, 0x05, 0x12, 0x04, 0x88, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x88, 0x03, 0x17, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x88, 0x03, 0x31, 0x32, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2a, 0x02, 0x02,
    0x12, 0x04, 0x89, 0x03, 0x08, 0x46, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x89, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x06, 0x12, 0x04,
    0x89, 0x03, 0x11, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x01, 0x12, 0x04, 0x89,
    0x03, 0x3a, 0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2a, 0x02, 0x02, 0x03, 0x12, 0x04, 0x89, 0x03,
    0x44, 0x45, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2b, 0x12, 0x06, 0x8c, 0x03, 0x00, 0x95, 0x03, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x2b, 0x01, 0x12, 0x04, 0x8c, 0x03, 0x08, 0x1d, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x2b, 0x02, 0x00, 0x12, 0x04, 0x8d, 0x03, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2b, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8d, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x8d, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x8d, 0x03, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x8d, 0x03, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x01, 0x12,
    0x04, 0x8e, 0x03, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x8e, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8e,
    0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8e, 0x03,
    0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8e, 0x03, 0x25,
    0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x02, 0x12, 0x04, 0x8f, 0x03, 0x08, 0x32, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8f, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2b, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8f, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2b, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8f, 0x03, 0x17, 0x2d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2b, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8f, 0x03, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x2b, 0x02, 0x03, 0x12, 0x04, 0x90, 0x03, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02,
    0x03, 0x04, 0x12, 0x04, 0x90, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x03,
    0x05, 0x12, 0x04, 0x90, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x03, 0x01,
    0x12, 0x04, 0x90, 0x03, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x03, 0x03, 0x12,
    0x04, 0x90, 0x03, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x04, 0x12, 0x04, 0x91,
    0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x04, 0x04, 0x12, 0x04, 0x91, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x04, 0x05, 0x12, 0x04, 0x91, 0x03, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x04, 0x01, 0x12, 0x04, 0x91, 0x03, 0x18, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x04, 0x03, 0x12, 0x04, 0x91, 0x03, 0x26, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x05, 0x12, 0x04, 0x92, 0x03, 0x08, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2b, 0x02, 0x05, 0x04, 0x12, 0x04, 0x92, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2b, 0x02, 0x05, 0x05, 0x12, 0x04, 0x92, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2b, 0x02, 0x05, 0x01, 0x12, 0x04, 0x92, 0x03, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b,
    0x02, 0x05, 0x03, 0x12, 0x04, 0x92, 0x03, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02,
    0x06, 0x12, 0x04, 0x93, 0x03, 0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x06, 0x04,
    0x12, 0x04, 0x93, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x06, 0x05, 0x12,
    0x04, 0x93, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x06, 0x01, 0x12, 0x04,
    0x93, 0x03, 0x16, 0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x06, 0x03, 0x12, 0x04, 0x93,
    0x03, 0x36, 0x38, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2b, 0x02, 0x07, 0x12, 0x04, 0x94, 0x03, 0x08,
    0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x07, 0x04, 0x12, 0x04, 0x94, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x07, 0x05, 0x12, 0x04, 0x94, 0x03, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2b, 0x02, 0x07, 0x01, 0x12, 0x04, 0x94, 0x03, 0x18, 0x3b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2b, 0x02, 0x07, 0x03, 0x12, 0x04, 0x94, 0x03, 0x3e, 0x40, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x2c, 0x12, 0x06, 0x97, 0x03, 0x00, 0x9f, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x2c, 0x01, 0x12, 0x04, 0x97, 0x03, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x2c, 0x03, 0x00,
    0x12, 0x06, 0x98, 0x03, 0x08, 0x9c, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x03, 0x00,
    0x01, 0x12, 0x04, 0x98, 0x03, 0x10, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x2c, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0x99, 0x03, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x99, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x99, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x03, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c,
    0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x99, 0x03, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x2c, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x2c, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9a, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9a, 0x03, 0x1f, 0x26, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9a, 0x03, 0x29, 0x2a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x9b, 0x03, 0x10, 0x32, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9b, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9b, 0x03, 0x19,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x03,
    0x1f, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x2c, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9b,
    0x03, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2c, 0x02, 0x00, 0x12, 0x04, 0x9e, 0x03, 0x08,
    0x59, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9e, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x06, 0x12, 0x04, 0x9e, 0x03, 0x11, 0x45, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9e, 0x03, 0x46, 0x54, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9e, 0x03, 0x57, 0x58, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x2d, 0x12, 0x06, 0xa1, 0x03, 0x00, 0xa6, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x2d, 0x01, 0x12, 0x04, 0xa1, 0x03, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2d, 0x02, 0x00,
    0x12, 0x04, 0xa2, 0x03, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xa2, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xa2, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa2,
    0x03, 0x16, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2, 0x03,
    0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2d, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa3, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3, 0x03, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x03, 0x16, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa3, 0x03, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x2d, 0x02, 0x02, 0x12, 0x04, 0xa4, 0x03, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xa4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xa4, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xa4, 0x03, 0x16, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xa4, 0x03, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2d, 0x02, 0x03, 0x12, 0x04,
    0xa5, 0x03, 0x08, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa5,
    0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa5, 0x03,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa5, 0x03, 0x16,
    0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2d, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa5, 0x03, 0x46, 0x47,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x2e, 0x12, 0x06, 0xa8, 0x03, 0x00, 0xab, 0x03, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x2e, 0x01, 0x12, 0x04, 0xa8, 0x03, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x2e, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xa9, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xa9, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xa9, 0x03, 0x18, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xa9, 0x03, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2e, 0x02, 0x01, 0x12, 0x04, 0xaa,
    0x03, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xaa, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xaa, 0x03, 0x11,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaa, 0x03, 0x19, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xaa, 0x03, 0x23, 0x24, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x2f, 0x12, 0x06, 0xad, 0x03, 0x00, 0xb3, 0x03, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x2f, 0x01, 0x12, 0x04, 0xad, 0x03, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f,
    0x02, 0x00, 0x12, 0x04, 0xae, 0x03, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xae, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xae, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xae, 0x03, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xae, 0x03, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x01, 0x12, 0x04, 0xaf, 0x03,
    0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xaf, 0x03, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x05, 0x12, 0x04, 0xaf, 0x03, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaf, 0x03, 0x18, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xaf, 0x03, 0x26, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x2f, 0x02, 0x02, 0x12, 0x04, 0xb0, 0x03, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x2f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x2f, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb0, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xb0, 0x03, 0x16, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xb0, 0x03, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x03,
    0x12, 0x04, 0xb1, 0x03, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xb1, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xb1, 0x03, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb1,
    0x03, 0x16, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb1, 0x03,
    0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x2f, 0x02, 0x04, 0x12, 0x04, 0xb2, 0x03, 0x08, 0x2e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb2, 0x03, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x2f, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb2, 0x03, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x2f, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb2, 0x03, 0x16, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x2f, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb2, 0x03, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x30, 0x12, 0x06, 0xb5, 0x03, 0x00, 0xb8, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x30,
    0x01, 0x12, 0x04, 0xb5, 0x03, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x30, 0x02, 0x00, 0x12,
    0x04, 0xb6, 0x03, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xb6, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb6,
    0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb6, 0x03,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb6, 0x03, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x30, 0x02, 0x01, 0x12, 0x04, 0xb7, 0x03, 0x08, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb7, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x30, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb7, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x30, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb7, 0x03, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x30, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb7, 0x03, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x31, 0x12, 0x06, 0xba, 0x03, 0x00, 0xd6, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x31, 0x01,
    0x12, 0x04, 0xba, 0x03, 0x08, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x31, 0x03, 0x00, 0x12, 0x06,
    0xbb, 0x03, 0x08, 0xd2, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xbb, 0x03, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xbc, 0x03, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xbc, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xbc, 0x03, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xbc, 0x03, 0x21, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xbc, 0x03, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xbd, 0x03, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbd, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbd, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x31, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbd, 0x03, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x31, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbd, 0x03, 0x30, 0x31, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xbe, 0x03, 0x10, 0x37, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbe, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbe, 0x03, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbe, 0x03, 0x20, 0x32,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbe, 0x03, 0x35,
    0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xbf, 0x03, 0x10,
    0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xbf, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xbf,
    0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xbf, 0x03, 0x20, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12,
    0x04, 0xbf, 0x03, 0x31, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x04, 0x12,
    0x04, 0xc0, 0x03, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xc0, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xc0, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xc0, 0x03, 0x20, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00,
    0x02, 0x04, 0x03, 0x12, 0x04, 0xc0, 0x03, 0x33, 0x34, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x05, 0x12, 0x04, 0xc1, 0x03, 0x10, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xc1, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31,
    0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xc1, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x31, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xc1, 0x03, 0x20, 0x33, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x31, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xc1, 0x03, 0x36, 0x37, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0xc2, 0x03, 0x10, 0x3d, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xc2, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xc2, 0x03, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xc2, 0x03, 0x20, 0x38,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xc2, 0x03, 0x3b,
    0x3c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x07, 0x12, 0x04, 0xc3, 0x03, 0x10,
    0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0xc3, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x07, 0x05, 0x12, 0x04, 0xc3,
    0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xc3, 0x03, 0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xc3, 0x03, 0x38, 0x39, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x08, 0x12,
    0x04, 0xc4, 0x03, 0x10, 0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x08, 0x04,
    0x12, 0x04, 0xc4, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x08,
    0x05, 0x12, 0x04, 0xc4, 0x03, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02,
    0x08, 0x01, 0x12, 0x04, 0xc4, 0x03, 0x1e, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00,
    0x02, 0x08, 0x03, 0x12, 0x04, 0xc4, 0x03, 0x34, 0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x09, 0x12, 0x04, 0xc5, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x09, 0x04, 0x12, 0x04, 0xc5, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31,
    0x03, 0x00, 0x02, 0x09, 0x05, 0x12, 0x04, 0xc5, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x31, 0x03, 0x00, 0x02, 0x09, 0x01, 0x12, 0x04, 0xc5, 0x03, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x31, 0x03, 0x00, 0x02, 0x09, 0x03, 0x12, 0x04, 0xc5, 0x03, 0x2e, 0x30, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0a, 0x12, 0x04, 0xc6, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xc6, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xc6, 0x03, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xc6, 0x03, 0x20, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xc6, 0x03, 0x2d,
    0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0b, 0x12, 0x04, 0xc7, 0x03, 0x10,
    0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xc7, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xc7,
    0x03, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x04,
    0xc7, 0x03, 0x21, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0b, 0x03, 0x12,
    0x04, 0xc7, 0x03, 0x32, 0x34, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0c, 0x12,
    0x04, 0xc8, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0c, 0x04,
    0x12, 0x04, 0xc8, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0c,
    0x05, 0x12, 0x04, 0xc8, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02,
    0x0c, 0x01, 0x12, 0x04, 0xc8, 0x03, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00,
    0x02, 0x0c, 0x03, 0x12, 0x04, 0xc8, 0x03, 0x2d, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x0d, 0x12, 0x04, 0xc9, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x0d, 0x04, 0x12, 0x04, 0xc9, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31,
    0x03, 0x00, 0x02, 0x0d, 0x05, 0x12, 0x04, 0xc9, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x31, 0x03, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x04, 0xc9, 0x03, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x31, 0x03, 0x00, 0x02, 0x0d, 0x03, 0x12, 0x04, 0xc9, 0x03, 0x2e, 0x30, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0e, 0x12, 0x04, 0xca, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0e, 0x04, 0x12, 0x04, 0xca, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0e, 0x05, 0x12, 0x04, 0xca, 0x03, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xca, 0x03, 0x20, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xca, 0x03, 0x2d,
    0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0f, 0x12, 0x04, 0xcb, 0x03, 0x10,
    0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xcb, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xcb,
    0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0f, 0x01, 0x12, 0x04,
    0xcb, 0x03, 0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x0f, 0x03, 0x12,
    0x04, 0xcb, 0x03, 0x2c, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x10, 0x12,
    0x04, 0xcc, 0x03, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x10, 0x04,
    0x12, 0x04, 0xcc, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x10,
    0x05, 0x12, 0x04, 0xcc, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02,
    0x10, 0x01, 0x12, 0x04, 0xcc, 0x03, 0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00,
    0x02, 0x10, 0x03, 0x12, 0x04, 0xcc, 0x03, 0x2c, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x11, 0x12, 0x04, 0xcd, 0x03, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x11, 0x04, 0x12, 0x04, 0xcd, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31,
    0x03, 0x00, 0x02, 0x11, 0x05, 0x12, 0x04, 0xcd, 0x03, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x31, 0x03, 0x00, 0x02, 0x11, 0x01, 0x12, 0x04, 0xcd, 0x03, 0x21, 0x27, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x31, 0x03, 0x00, 0x02, 0x11, 0x03, 0x12, 0x04, 0xcd, 0x03, 0x2a, 0x2c, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x12, 0x12, 0x04, 0xce, 0x03, 0x10, 0x33, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x12, 0x04, 0x12, 0x04, 0xce, 0x03, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x12, 0x05, 0x12, 0x04, 0xce, 0x03, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x12, 0x01, 0x12, 0x04, 0xce, 0x03, 0x1f, 0x2d,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x12, 0x03, 0x12, 0x04, 0xce, 0x03, 0x30,
    0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x13, 0x12, 0x04, 0xcf, 0x03, 0x10,
    0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x13, 0x04, 0x12, 0x04, 0xcf, 0x03,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x13, 0x05, 0x12, 0x04, 0xcf,
    0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x13, 0x01, 0x12, 0x04,
    0xcf, 0x03, 0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x13, 0x03, 0x12,
    0x04, 0xcf, 0x03, 0x2b, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03, 0x00, 0x02, 0x14, 0x12,
    0x04, 0xd0, 0x03, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x14, 0x04,
    0x12, 0x04, 0xd0, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02, 0x14,
    0x05, 0x12, 0x04, 0xd0, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00, 0x02,
    0x14, 0x01, 0x12, 0x04, 0xd0, 0x03, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03, 0x00,
    0x02, 0x14, 0x03, 0x12, 0x04, 0xd0, 0x03, 0x30, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x15, 0x12, 0x04, 0xd1, 0x03, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31, 0x03,
    0x00, 0x02, 0x15, 0x04, 0x12, 0x04, 0xd1, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x31,
    0x03, 0x00, 0x02, 0x15, 0x05, 0x12, 0x04, 0xd1, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x31, 0x03, 0x00, 0x02, 0x15, 0x01, 0x12, 0x04, 0xd1, 0x03, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x31, 0x03, 0x00, 0x02, 0x15, 0x03, 0x12, 0x04, 0xd1, 0x03, 0x2e, 0x30, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x31, 0x02, 0x00, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x31, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd4, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xd4, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xd4, 0x03, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xd4, 0x03, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x31, 0x02, 0x01, 0x12,
    0x04, 0xd5, 0x03, 0x08, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xd5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x01, 0x06, 0x12, 0x04, 0xd5,
    0x03, 0x11, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd5, 0x03,
    0x30, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x31, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd5, 0x03, 0x3a,
    0x3b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x32, 0x12, 0x06, 0xd8, 0x03, 0x00, 0xda, 0x03, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x32, 0x01, 0x12, 0x04, 0xd8, 0x03, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x32, 0x02, 0x00, 0x12, 0x04, 0xd9, 0x03, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xd9, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xd9, 0x03, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xd9, 0x03, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x32, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xd9, 0x03, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x33, 0x12, 0x06, 0xdc, 0x03,
    0x00, 0xe6, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x33, 0x01, 0x12, 0x04, 0xdc, 0x03, 0x08,
    0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x03, 0x08, 0x31, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdd, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdd, 0x03, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x33, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x03, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x33, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x03, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x33, 0x02, 0x00, 0x08, 0x12, 0x04, 0xdd, 0x03, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33,
    0x02, 0x00, 0x07, 0x12, 0x04, 0xdd, 0x03, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02,
    0x01, 0x12, 0x04, 0xde, 0x03, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xde, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xde, 0x03, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xde, 0x03, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x01, 0x03, 0x12, 0x04, 0xde,
    0x03, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x02, 0x12, 0x04, 0xdf, 0x03, 0x08,
    0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdf, 0x03, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x02, 0x05, 0x12, 0x04, 0xdf, 0x03, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x02, 0x01, 0x12, 0x04, 0xdf, 0x03, 0x18, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x02, 0x03, 0x12, 0x04, 0xdf, 0x03, 0x27, 0x28, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x33, 0x02, 0x03, 0x12, 0x04, 0xe0, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x33, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe0, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xe0, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xe0, 0x03, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xe0, 0x03, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x04, 0x12,
    0x04, 0xe1, 0x03, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xe1, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe1,
    0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe1, 0x03,
    0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe1, 0x03, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x05, 0x12, 0x04, 0xe2, 0x03, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe2, 0x03, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x33, 0x02, 0x05, 0x05, 0x12, 0x04, 0xe2, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x33, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe2, 0x03, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x33, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe2, 0x03, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x33, 0x02, 0x06, 0x12, 0x04, 0xe3, 0x03, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xe3, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x06,
    0x05, 0x12, 0x04, 0xe3, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x06, 0x01,
    0x12, 0x04, 0xe3, 0x03, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x06, 0x03, 0x12,
    0x04, 0xe3, 0x03, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x07, 0x12, 0x04, 0xe4,
    0x03, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x07, 0x04, 0x12, 0x04, 0xe4, 0x03,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x07, 0x05, 0x12, 0x04, 0xe4, 0x03, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x07, 0x01, 0x12, 0x04, 0xe4, 0x03, 0x18, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33, 0x02, 0x07, 0x03, 0x12, 0x04, 0xe4, 0x03, 0x23, 0x24, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x33, 0x02, 0x08, 0x12, 0x04, 0xe5, 0x03, 0x08, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x33, 0x02, 0x08, 0x04, 0x12, 0x04, 0xe5, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x33, 0x02, 0x08, 0x05, 0x12, 0x04, 0xe5, 0x03, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x33, 0x02, 0x08, 0x01, 0x12, 0x04, 0xe5, 0x03, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x33,
    0x02, 0x08, 0x03, 0x12, 0x04, 0xe5, 0x03, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x34, 0x12,
    0x06, 0xe8, 0x03, 0x00, 0xf0, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x34, 0x01, 0x12, 0x04,
    0xe8, 0x03, 0x08, 0x1c, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x34, 0x03, 0x00, 0x12, 0x06, 0xe9, 0x03,
    0x08, 0xed, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34, 0x03, 0x00, 0x01, 0x12, 0x04, 0xe9,
    0x03, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x34, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xea,
    0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xea, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xea, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xea, 0x03, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xea, 0x03, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x34, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xeb, 0x03, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xeb, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xeb, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xeb, 0x03, 0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x34,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xeb, 0x03, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x34, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xec, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x34, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xec, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x34, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xec, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x34, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xec, 0x03, 0x20, 0x2b, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x34, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xec, 0x03, 0x2e, 0x2f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x34, 0x02, 0x00, 0x12, 0x04, 0xef, 0x03, 0x08, 0x3a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x34, 0x02, 0x00, 0x04, 0x12, 0x04, 0xef, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x34, 0x02, 0x00, 0x06, 0x12, 0x04, 0xef, 0x03, 0x11, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x34, 0x02, 0x00, 0x01, 0x12, 0x04, 0xef, 0x03, 0x2e, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x34,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xef, 0x03, 0x38, 0x39, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x35, 0x12,
    0x06, 0xf2, 0x03, 0x00, 0xf9, 0x03, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x35, 0x01, 0x12, 0x04,
    0xf2, 0x03, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x35, 0x03, 0x00, 0x12, 0x06, 0xf3, 0x03,
    0x08, 0xf6, 0x03, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x03, 0x00, 0x01, 0x12, 0x04, 0xf3,
    0x03, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x35, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xf4,
    0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xf4, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xf4, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xf4, 0x03, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xf4, 0x03, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x35, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xf5, 0x03, 0x10, 0x3a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xf5, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xf5, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf5, 0x03, 0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x35,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf5, 0x03, 0x38, 0x39, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x35, 0x02, 0x00, 0x12, 0x04, 0xf8, 0x03, 0x08, 0x4f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xf8, 0x03, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00,
    0x06, 0x12, 0x04, 0xf8, 0x03, 0x11, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xf8, 0x03, 0x3d, 0x4a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x35, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xf8, 0x03, 0x4d, 0x4e, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x36, 0x12, 0x06, 0xfb, 0x03, 0x00,
    0x86, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x36, 0x01, 0x12, 0x04, 0xfb, 0x03, 0x08, 0x17,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x36, 0x03, 0x00, 0x12, 0x06, 0xfc, 0x03, 0x08, 0x83, 0x04, 0x09,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x03, 0x00, 0x01, 0x12, 0x04, 0xfc, 0x03, 0x10, 0x1a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x36, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x03, 0x10, 0x30, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfd, 0x03, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfd, 0x03, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfd, 0x03,
    0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xfd,
    0x03, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x36, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xfe,
    0x03, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xfe, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xfe, 0x03, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xfe, 0x03, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xfe, 0x03, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x36, 0x03, 0x00, 0x02,
    0x02, 0x12, 0x04, 0xff, 0x03, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xff, 0x03, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xff, 0x03, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xff, 0x03, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36,
    0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xff, 0x03, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x36, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x80, 0x04, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x36, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x80, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x36, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x80, 0x04, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0x80, 0x04, 0x20, 0x27, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0x80, 0x04, 0x2a, 0x2b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x36, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0x81, 0x04, 0x10, 0x2d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0x81, 0x04, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0x81, 0x04, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x81, 0x04,
    0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0x81,
    0x04, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x36, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0x82,
    0x04, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04,
    0x82, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12,
    0x04, 0x82, 0x04, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x05, 0x01,
    0x12, 0x04, 0x82, 0x04, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x36, 0x03, 0x00, 0x02, 0x05,
    0x03, 0x12, 0x04, 0x82, 0x04, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x36, 0x02, 0x00, 0x12,
    0x04, 0x85, 0x04, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x85, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x06, 0x12, 0x04, 0x85,
    0x04, 0x11, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x04,
    0x2d, 0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x36, 0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x04, 0x3b,
    0x3c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x37, 0x12, 0x06, 0x88, 0x04, 0x00, 0x91, 0x04, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x37, 0x01, 0x12, 0x04, 0x88, 0x04, 0x08, 0x20, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x37, 0x02, 0x00, 0x12, 0x04, 0x89, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x89, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02,
    0x00, 0x05, 0x12, 0x04, 0x89, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x89, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x00, 0x03,
    0x12, 0x04, 0x89, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x01, 0x12, 0x04,
    0x8a, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8a,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8a, 0x04,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8a, 0x04, 0x17,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8a, 0x04, 0x25, 0x26,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x02, 0x12, 0x04, 0x8b, 0x04, 0x08, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x37, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8b, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x37, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8b, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x37, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8b, 0x04, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x37, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8b, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37,
    0x02, 0x03, 0x12, 0x04, 0x8c, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x03,
    0x04, 0x12, 0x04, 0x8c, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x03, 0x05,
    0x12, 0x04, 0x8c, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x03, 0x01, 0x12,
    0x04, 0x8c, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x03, 0x03, 0x12, 0x04,
    0x8c, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x04, 0x12, 0x04, 0x8d, 0x04,
    0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x04, 0x04, 0x12, 0x04, 0x8d, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x04, 0x05, 0x12, 0x04, 0x8d, 0x04, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x04, 0x01, 0x12, 0x04, 0x8d, 0x04, 0x18, 0x1f, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x04, 0x03, 0x12, 0x04, 0x8d, 0x04, 0x22, 0x23, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x37, 0x02, 0x05, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x37, 0x02, 0x05, 0x04, 0x12, 0x04, 0x8e, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x37, 0x02, 0x05, 0x05, 0x12, 0x04, 0x8e, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37,
    0x02, 0x05, 0x01, 0x12, 0x04, 0x8e, 0x04, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02,
    0x05, 0x03, 0x12, 0x04, 0x8e, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x06,
    0x12, 0x04, 0x8f, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x06, 0x04, 0x12,
    0x04, 0x8f, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x06, 0x05, 0x12, 0x04,
    0x8f, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x06, 0x01, 0x12, 0x04, 0x8f,
    0x04, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x06, 0x03, 0x12, 0x04, 0x8f, 0x04,
    0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x37, 0x02, 0x07, 0x12, 0x04, 0x90, 0x04, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x07, 0x04, 0x12, 0x04, 0x90, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x37, 0x02, 0x07, 0x05, 0x12, 0x04, 0x90, 0x04, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x37, 0x02, 0x07, 0x01, 0x12, 0x04, 0x90, 0x04, 0x18, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x37, 0x02, 0x07, 0x03, 0x12, 0x04, 0x90, 0x04, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x38, 0x12, 0x06, 0x93, 0x04, 0x00, 0x97, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x38,
    0x01, 0x12, 0x04, 0x93, 0x04, 0x08, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x38, 0x02, 0x00, 0x12,
    0x04, 0x94, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x94, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x05, 0x12, 0x04, 0x94,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x04,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x04, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x38, 0x02, 0x01, 0x12, 0x04, 0x95, 0x04, 0x08, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x01, 0x04, 0x12, 0x04, 0x95, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x38, 0x02, 0x01, 0x05, 0x12, 0x04, 0x95, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x38, 0x02, 0x01, 0x01, 0x12, 0x04, 0x95, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x38, 0x02, 0x01, 0x03, 0x12, 0x04, 0x95, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x38, 0x02, 0x02, 0x12, 0x04, 0x96, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x96, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x02,
    0x05, 0x12, 0x04, 0x96, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x02, 0x01,
    0x12, 0x04, 0x96, 0x04, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x02, 0x03, 0x12,
    0x04, 0x96, 0x04, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x02, 0x08, 0x12, 0x04,
    0x96, 0x04, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x38, 0x02, 0x02, 0x07, 0x12, 0x04, 0x96,
    0x04, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x39, 0x12, 0x06, 0x99, 0x04, 0x00, 0x9d, 0x04,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x39, 0x01, 0x12, 0x04, 0x99, 0x04, 0x08, 0x1e, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x39, 0x02, 0x00, 0x12, 0x04, 0x9a, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x39, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9a, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x39, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9a, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x9a, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x9a, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x39, 0x02, 0x01,
    0x12, 0x04, 0x9b, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x01, 0x04, 0x12,
    0x04, 0x9b, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x01, 0x05, 0x12, 0x04,
    0x9b, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9b,
    0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9b, 0x04,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x39, 0x02, 0x02, 0x12, 0x04, 0x9c, 0x04, 0x08, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9c, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x39, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9c, 0x04, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x39, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9c, 0x04, 0x18, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x39, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9c, 0x04, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x3a, 0x12, 0x06, 0x9f, 0x04, 0x00, 0xaf, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3a,
    0x01, 0x12, 0x04, 0x9f, 0x04, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x3a, 0x03, 0x00, 0x12,
    0x06, 0xa0, 0x04, 0x08, 0xa4, 0x04, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xa0, 0x04, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x00,
    0x12, 0x04, 0xa1, 0x04, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xa1, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xa1, 0x04, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xa1, 0x04, 0x21, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa1, 0x04, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3a,
    0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa2, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x3a, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa2, 0x04, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x3a, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa2, 0x04, 0x20, 0x2c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa2, 0x04, 0x2f, 0x30, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xa3, 0x04, 0x10, 0x2c, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa3, 0x04, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa3, 0x04, 0x19, 0x1e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x04, 0x1f,
    0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3a, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa3, 0x04,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x00, 0x12, 0x04, 0xa6, 0x04, 0x08, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa6, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa6, 0x04, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa6, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa6, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x3a, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xa7, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xa7, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xa7, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xa7, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x02, 0x12, 0x04,
    0xa8, 0x04, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa8,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa8, 0x04,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa8, 0x04, 0x17,
    0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa8, 0x04, 0x32, 0x33,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x03, 0x12, 0x04, 0xa9, 0x04, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3a, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa9, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3a, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa9, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3a, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa9, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3a, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa9, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a,
    0x02, 0x04, 0x12, 0x04, 0xaa, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xaa, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x04, 0x05,
    0x12, 0x04, 0xaa, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x04, 0x01, 0x12,
    0x04, 0xaa, 0x04, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x04, 0x03, 0x12, 0x04,
    0xaa, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x05, 0x12, 0x04, 0xab, 0x04,
    0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x05, 0x04, 0x12, 0x04, 0xab, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x05, 0x05, 0x12, 0x04, 0xab, 0x04, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x05, 0x01, 0x12, 0x04, 0xab, 0x04, 0x17, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x05, 0x03, 0x12, 0x04, 0xab, 0x04, 0x25, 0x26, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x3a, 0x02, 0x06, 0x12, 0x04, 0xac, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3a, 0x02, 0x06, 0x04, 0x12, 0x04, 0xac, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3a, 0x02, 0x06, 0x05, 0x12, 0x04, 0xac, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a,
    0x02, 0x06, 0x01, 0x12, 0x04, 0xac, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02,
    0x06, 0x03, 0x12, 0x04, 0xac, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x07,
    0x12, 0x04, 0xad, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x07, 0x04, 0x12,
    0x04, 0xad, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x07, 0x05, 0x12, 0x04,
    0xad, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x07, 0x01, 0x12, 0x04, 0xad,
    0x04, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x07, 0x03, 0x12, 0x04, 0xad, 0x04,
    0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3a, 0x02, 0x08, 0x12, 0x04, 0xae, 0x04, 0x08, 0x44,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x08, 0x04, 0x12, 0x04, 0xae, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3a, 0x02, 0x08, 0x06, 0x12, 0x04, 0xae, 0x04, 0x11, 0x37, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3a, 0x02, 0x08, 0x01, 0x12, 0x04, 0xae, 0x04, 0x38, 0x3f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3a, 0x02, 0x08, 0x03, 0x12, 0x04, 0xae, 0x04, 0x42, 0x43, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x3b, 0x12, 0x06, 0xb1, 0x04, 0x00, 0xb4, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3b,
    0x01, 0x12, 0x04, 0xb1, 0x04, 0x08, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3b, 0x02, 0x00, 0x12,
    0x04, 0xb2, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xb2, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb2,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb2, 0x04,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb2, 0x04, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3b, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x04, 0x08, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb3, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb3, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb3, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb3, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x3c, 0x12, 0x06, 0xb6, 0x04, 0x00, 0xba, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3c, 0x01,
    0x12, 0x04, 0xb6, 0x04, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3c, 0x02, 0x00, 0x12, 0x04,
    0xb7, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb7,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb7, 0x04,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x04, 0x18,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x04, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3c, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x04, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb8, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3c, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb8, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb8, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb8, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3c,
    0x02, 0x02, 0x12, 0x04, 0xb9, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xb9, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xb9, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xb9, 0x04, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xb9, 0x04, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x02, 0x08, 0x12, 0x04, 0xb9,
    0x04, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3c, 0x02, 0x02, 0x07, 0x12, 0x04, 0xb9, 0x04,
    0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3d, 0x12, 0x06, 0xbc, 0x04, 0x00, 0xc9, 0x04, 0x01,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3d, 0x01, 0x12, 0x04, 0xbc, 0x04, 0x08, 0x21, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x3d, 0x03, 0x00, 0x12, 0x06, 0xbd, 0x04, 0x08, 0xc2, 0x04, 0x09, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3d, 0x03, 0x00, 0x01, 0x12, 0x04, 0xbd, 0x04, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x3d, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xbe, 0x04, 0x10, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x3d, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbe, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbe, 0x04, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbe, 0x04, 0x20, 0x23, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbe, 0x04, 0x26, 0x27,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xbf, 0x04, 0x10, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbf, 0x04, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbf, 0x04,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbf,
    0x04, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xbf, 0x04, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04,
    0xc0, 0x04, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xc0, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xc0, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xc0, 0x04, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xc0, 0x04, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3d, 0x03, 0x00,
    0x02, 0x03, 0x12, 0x04, 0xc1, 0x04, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03, 0x00,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xc1, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d, 0x03,
    0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc1, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3d,
    0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc1, 0x04, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x3d, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc1, 0x04, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x3d, 0x02, 0x00, 0x12, 0x04, 0xc4, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xc4, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xc4, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xc4, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xc4, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3d, 0x02, 0x01, 0x12, 0x04,
    0xc5, 0x04, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc5,
    0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc5, 0x04,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc5, 0x04, 0x17,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc5, 0x04, 0x2f, 0x30,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3d, 0x02, 0x02, 0x12, 0x04, 0xc6, 0x04, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3d, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc6, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3d, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc6, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc6, 0x04, 0x18, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc6, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3d,
    0x02, 0x03, 0x12, 0x04, 0xc7, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xc7, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xc7, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xc7, 0x04, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xc7, 0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3d, 0x02, 0x04, 0x12, 0x04, 0xc8, 0x04,
    0x08, 0x3f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x04, 0x04, 0x12, 0x04, 0xc8, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x04, 0x06, 0x12, 0x04, 0xc8, 0x04, 0x11, 0x32,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x04, 0x01, 0x12, 0x04, 0xc8, 0x04, 0x33, 0x3a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3d, 0x02, 0x04, 0x03, 0x12, 0x04, 0xc8, 0x04, 0x3d, 0x3e, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x3e, 0x12, 0x06, 0xcb, 0x04, 0x00, 0xda, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x3e, 0x01, 0x12, 0x04, 0xcb, 0x04, 0x08, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x3e, 0x03,
    0x00, 0x12, 0x06, 0xcc, 0x04, 0x08, 0xd5, 0x04, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x03,
    0x00, 0x01, 0x12, 0x04, 0xcc, 0x04, 0x10, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3e, 0x03, 0x00,
    0x02, 0x00, 0x12, 0x04, 0xcd, 0x04, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xcd, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcd, 0x04, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcd, 0x04, 0x21, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x3e, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcd, 0x04, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x3e, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xce, 0x04, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x3e, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xce, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xce, 0x04, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xce, 0x04, 0x1f, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xce, 0x04, 0x2d, 0x2e,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xcf, 0x04, 0x10, 0x2e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcf, 0x04, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xcf, 0x04,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcf,
    0x04, 0x1f, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xcf, 0x04, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04,
    0xd0, 0x04, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xd0, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xd0, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xd0, 0x04, 0x1f, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xd0, 0x04, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3e, 0x03, 0x00,
    0x02, 0x04, 0x12, 0x04, 0xd1, 0x04, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00,
    0x02, 0x04, 0x04, 0x12, 0x04, 0xd1, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03,
    0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xd1, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e,
    0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd1, 0x04, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x3e, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd1, 0x04, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x3e, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0xd2, 0x04, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x3e, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0xd2, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd2, 0x04, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd2, 0x04, 0x1f, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd2, 0x04, 0x2d, 0x2e,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0xd3, 0x04, 0x10, 0x2c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xd3, 0x04, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xd3, 0x04,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd3,
    0x04, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04,
    0xd3, 0x04, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x07, 0x12, 0x04,
    0xd4, 0x04, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12,
    0x04, 0xd4, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x07, 0x05,
    0x12, 0x04, 0xd4, 0x04, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02, 0x07,
    0x01, 0x12, 0x04, 0xd4, 0x04, 0x1f, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x3e, 0x03, 0x00, 0x02,
    0x07, 0x03, 0x12, 0x04, 0xd4, 0x04, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3e, 0x02, 0x00,
    0x12, 0x04, 0xd7, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xd7, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xd7, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd7,
    0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd7, 0x04,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3e, 0x02, 0x01, 0x12, 0x04, 0xd8, 0x04, 0x08, 0x31,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8, 0x04, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x04, 0x11, 0x16, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3e, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd8, 0x04, 0x17, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd8, 0x04, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3e, 0x02, 0x01, 0x08, 0x12, 0x04, 0xd8, 0x04, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3e, 0x02, 0x01, 0x07, 0x12, 0x04, 0xd8, 0x04, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3e,
    0x02, 0x02, 0x12, 0x04, 0xd9, 0x04, 0x08, 0x46, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xd9, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x02, 0x06,
    0x12, 0x04, 0xd9, 0x04, 0x11, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xd9, 0x04, 0x3a, 0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3e, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xd9, 0x04, 0x44, 0x45, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x3f, 0x12, 0x06, 0xdc, 0x04, 0x00, 0xe4,
    0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x3f, 0x01, 0x12, 0x04, 0xdc, 0x04, 0x08, 0x21, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x3f, 0x02, 0x00, 0x12, 0x04, 0xdd, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdd, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdd, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdd, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xdd, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3f, 0x02,
    0x01, 0x12, 0x04, 0xde, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xde, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xde, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xde, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xde,
    0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3f, 0x02, 0x02, 0x12, 0x04, 0xdf, 0x04, 0x08,
    0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdf, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x02, 0x05, 0x12, 0x04, 0xdf, 0x04, 0x11, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xdf, 0x04, 0x19, 0x28, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3f, 0x02, 0x02, 0x03, 0x12, 0x04, 0xdf, 0x04, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x3f, 0x02, 0x03, 0x12, 0x04, 0xe0, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x3f, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe0, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xe0, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xe0, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xe0, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3f, 0x02, 0x04, 0x12,
    0x04, 0xe1, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xe1, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe1,
    0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe1, 0x04,
    0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe1, 0x04, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x3f, 0x02, 0x05, 0x12, 0x04, 0xe2, 0x04, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x05, 0x04, 0x12, 0x04, 0xe2, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x3f, 0x02, 0x05, 0x05, 0x12, 0x04, 0xe2, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x3f, 0x02, 0x05, 0x01, 0x12, 0x04, 0xe2, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x3f, 0x02, 0x05, 0x03, 0x12, 0x04, 0xe2, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x3f, 0x02, 0x06, 0x12, 0x04, 0xe3, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xe3, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x06,
    0x05, 0x12, 0x04, 0xe3, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x06, 0x01,
    0x12, 0x04, 0xe3, 0x04, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x3f, 0x02, 0x06, 0x03, 0x12,
    0x04, 0xe3, 0x04, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x40, 0x12, 0x06, 0xe6, 0x04, 0x00,
    0xea, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x40, 0x01, 0x12, 0x04, 0xe6, 0x04, 0x08, 0x29,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x40, 0x02, 0x00, 0x12, 0x04, 0xe7, 0x04, 0x08, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x40, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe7, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x40, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe7, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x40, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe7, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x40, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe7, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x40,
    0x02, 0x01, 0x12, 0x04, 0xe8, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xe8, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xe8, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xe8, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xe8, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x40, 0x02, 0x02, 0x12, 0x04, 0xe9, 0x04,
    0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe9, 0x04, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe9, 0x04, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x04, 0x17, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x40, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe9, 0x04, 0x21, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x40, 0x02, 0x02, 0x08, 0x12, 0x04, 0xe9, 0x04, 0x23, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x40, 0x02, 0x02, 0x07, 0x12, 0x04, 0xe9, 0x04, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x41, 0x12, 0x06, 0xec, 0x04, 0x00, 0xef, 0x04, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x41,
    0x01, 0x12, 0x04, 0xec, 0x04, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x41, 0x02, 0x00, 0x12,
    0x04, 0xed, 0x04, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xed, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x05, 0x12, 0x04, 0xed,
    0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x01, 0x12, 0x04, 0xed, 0x04,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x00, 0x03, 0x12, 0x04, 0xed, 0x04, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x41, 0x02, 0x01, 0x12, 0x04, 0xee, 0x04, 0x08, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x41, 0x02, 0x01, 0x04, 0x12, 0x04, 0xee, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x41, 0x02, 0x01, 0x05, 0x12, 0x04, 0xee, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x41, 0x02, 0x01, 0x01, 0x12, 0x04, 0xee, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x41, 0x02, 0x01, 0x03, 0x12, 0x04, 0xee, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x42, 0x12, 0x06, 0xf1, 0x04, 0x00, 0x82, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x42, 0x01,
    0x12, 0x04, 0xf1, 0x04, 0x08, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x42, 0x03, 0x00, 0x12, 0x06,
    0xf2, 0x04, 0x08, 0xf6, 0x04, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x03, 0x00, 0x01, 0x12,
    0x04, 0xf2, 0x04, 0x10, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x42, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xf3, 0x04, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xf3, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xf3, 0x04, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xf3, 0x04, 0x21, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xf3, 0x04, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x42, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xf4, 0x04, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf4, 0x04, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf4, 0x04, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x42, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf4, 0x04, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x42, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf4, 0x04, 0x2f, 0x30, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x42, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf5, 0x04, 0x10, 0x2c, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x42, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf5, 0x04, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x42, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf5, 0x04, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf5, 0x04, 0x1f, 0x27,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x42, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf5, 0x04, 0x2a,
    0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x00, 0x12, 0x04, 0xf8, 0x04, 0x08, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf8, 0x04, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x42, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf8, 0x04, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x42, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf8, 0x04, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x42, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf8, 0x04, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x42, 0x02, 0x01, 0x12, 0x04, 0xf9, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xf9, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xf9, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xf9, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xf9, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x02, 0x12, 0x04, 0xfa,
    0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x04, 0x12, 0x04, 0xfa, 0x04,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x05, 0x12, 0x04, 0xfa, 0x04, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x01, 0x12, 0x04, 0xfa, 0x04, 0x17, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x02, 0x03, 0x12, 0x04, 0xfa, 0x04, 0x25, 0x26, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x03, 0x12, 0x04, 0xfb, 0x04, 0x08, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x42, 0x02, 0x03, 0x04, 0x12, 0x04, 0xfb, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x42, 0x02, 0x03, 0x05, 0x12, 0x04, 0xfb, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x42, 0x02, 0x03, 0x01, 0x12, 0x04, 0xfb, 0x04, 0x17, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xfb, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02,
    0x04, 0x12, 0x04, 0xfc, 0x04, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xfc, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xfc, 0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xfc, 0x04, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x04, 0x03, 0x12, 0x04, 0xfc,
    0x04, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x05, 0x12, 0x04, 0xfd, 0x04, 0x08,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x05, 0x04, 0x12, 0x04, 0xfd, 0x04, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x05, 0x05, 0x12, 0x04, 0xfd, 0x04, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x05, 0x01, 0x12, 0x04, 0xfd, 0x04, 0x17, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x42, 0x02, 0x05, 0x03, 0x12, 0x04, 0xfd, 0x04, 0x25, 0x26, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x42, 0x02, 0x06, 0x12, 0x04, 0xfe, 0x04, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x42, 0x02, 0x06, 0x04, 0x12, 0x04, 0xfe, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xfe, 0x04, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xfe, 0x04, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xfe, 0x04, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x07, 0x12,
    0x04, 0xff, 0x04, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x07, 0x04, 0x12, 0x04,
    0xff, 0x04, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x07, 0x05, 0x12, 0x04, 0xff,
    0x04, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x07, 0x01, 0x12, 0x04, 0xff, 0x04,
    0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x07, 0x03, 0x12, 0x04, 0xff, 0x04, 0x22,
    0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x42, 0x02, 0x08, 0x12, 0x04, 0x80, 0x05, 0x08, 0x3c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x08, 0x04, 0x12, 0x04, 0x80, 0x05, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x42, 0x02, 0x08, 0x06, 0x12, 0x04, 0x80, 0x05, 0x11, 0x2f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x42, 0x02, 0x08, 0x01, 0x12, 0x04, 0x80, 0x05, 0x30, 0x37, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x42, 0x02, 0x08, 0x03, 0x12, 0x04, 0x80, 0x05, 0x3a, 0x3b, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x42, 0x02, 0x09, 0x12, 0x04, 0x81, 0x05, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02,
    0x09, 0x04, 0x12, 0x04, 0x81, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x09,
    0x05, 0x12, 0x04, 0x81, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x09, 0x01,
    0x12, 0x04, 0x81, 0x05, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x42, 0x02, 0x09, 0x03, 0x12,
    0x04, 0x81, 0x05, 0x27, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x43, 0x12, 0x06, 0x84, 0x05, 0x00,
    0x89, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x43, 0x01, 0x12, 0x04, 0x84, 0x05, 0x08, 0x25,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x43, 0x02, 0x00, 0x12, 0x04, 0x85, 0x05, 0x08, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x43, 0x02, 0x00, 0x04, 0x12, 0x04, 0x85, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x43, 0x02, 0x00, 0x05, 0x12, 0x04, 0x85, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x43, 0x02, 0x00, 0x01, 0x12, 0x04, 0x85, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x43, 0x02, 0x00, 0x03, 0x12, 0x04, 0x85, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x43,
    0x02, 0x01, 0x12, 0x04, 0x86, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01,
    0x04, 0x12, 0x04, 0x86, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x05,
    0x12, 0x04, 0x86, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x01, 0x12,
    0x04, 0x86, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x01, 0x03, 0x12, 0x04,
    0x86, 0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x43, 0x02, 0x02, 0x12, 0x04, 0x87, 0x05,
    0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x02, 0x04, 0x12, 0x04, 0x87, 0x05, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x02, 0x05, 0x12, 0x04, 0x87, 0x05, 0x11, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x02, 0x01, 0x12, 0x04, 0x87, 0x05, 0x19, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02, 0x02, 0x03, 0x12, 0x04, 0x87, 0x05, 0x2b, 0x2c, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x43, 0x02, 0x03, 0x12, 0x04, 0x88, 0x05, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x43, 0x02, 0x03, 0x04, 0x12, 0x04, 0x88, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x43, 0x02, 0x03, 0x05, 0x12, 0x04, 0x88, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43,
    0x02, 0x03, 0x01, 0x12, 0x04, 0x88, 0x05, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x43, 0x02,
    0x03, 0x03, 0x12, 0x04, 0x88, 0x05, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x44, 0x12, 0x06,
    0x8b, 0x05, 0x00, 0x90, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x44, 0x01, 0x12, 0x04, 0x8b,
    0x05, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x44, 0x02, 0x00, 0x12, 0x04, 0x8c, 0x05, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8c, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8c, 0x05, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8c, 0x05, 0x18, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x44, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8c, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x44, 0x02, 0x01, 0x12, 0x04, 0x8d, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x44, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8d, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x8d, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02,
    0x01, 0x01, 0x12, 0x04, 0x8d, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x01,
    0x03, 0x12, 0x04, 0x8d, 0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x44, 0x02, 0x02, 0x12,
    0x04, 0x8e, 0x05, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x02, 0x04, 0x12, 0x04,
    0x8e, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8e,
    0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8e, 0x05,
    0x19, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x02, 0x03, 0x12, 0x04, 0x8e, 0x05, 0x2b,
    0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x44, 0x02, 0x03, 0x12, 0x04, 0x8f, 0x05, 0x08, 0x29, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x44, 0x02, 0x03, 0x04, 0x12, 0x04, 0x8f, 0x05, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x44, 0x02, 0x03, 0x05, 0x12, 0x04, 0x8f, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x44, 0x02, 0x03, 0x01, 0x12, 0x04, 0x8f, 0x05, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x44, 0x02, 0x03, 0x03, 0x12, 0x04, 0x8f, 0x05, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x45, 0x12, 0x06, 0x92, 0x05, 0x00, 0x96, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x45, 0x01,
    0x12, 0x04, 0x92, 0x05, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x00, 0x12, 0x04,
    0x93, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x00, 0x04, 0x12, 0x04, 0x93,
    0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x00, 0x05, 0x12, 0x04, 0x93, 0x05,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x00, 0x01, 0x12, 0x04, 0x93, 0x05, 0x18,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x00, 0x03, 0x12, 0x04, 0x93, 0x05, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45, 0x02, 0x01, 0x12, 0x04, 0x94, 0x05, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x45, 0x02, 0x01, 0x04, 0x12, 0x04, 0x94, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x45, 0x02, 0x01, 0x05, 0x12, 0x04, 0x94, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x45, 0x02, 0x01, 0x01, 0x12, 0x04, 0x94, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x45, 0x02, 0x01, 0x03, 0x12, 0x04, 0x94, 0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x45,
    0x02, 0x02, 0x12, 0x04, 0x95, 0x05, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x95, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x95, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x95, 0x05, 0x19, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x45, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x95, 0x05, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x46, 0x12, 0x06, 0x98, 0x05, 0x00, 0x9c,
    0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x46, 0x01, 0x12, 0x04, 0x98, 0x05, 0x08, 0x2a, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x46, 0x02, 0x00, 0x12, 0x04, 0x99, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x46, 0x02, 0x00, 0x04, 0x12, 0x04, 0x99, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x46, 0x02, 0x00, 0x05, 0x12, 0x04, 0x99, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x46, 0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x99, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x46, 0x02,
    0x01, 0x12, 0x04, 0x9a, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x9a, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x05, 0x12,
    0x04, 0x9a, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x9a, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9a,
    0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x46, 0x02, 0x02, 0x12, 0x04, 0x9b, 0x05, 0x08,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9b, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9b, 0x05, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9b, 0x05, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x46, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9b, 0x05, 0x21, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x46, 0x02, 0x02, 0x08, 0x12, 0x04, 0x9b, 0x05, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x46, 0x02, 0x02, 0x07, 0x12, 0x04, 0x9b, 0x05, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x47, 0x12, 0x06, 0x9e, 0x05, 0x00, 0xa2, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x47, 0x01,
    0x12, 0x04, 0x9e, 0x05, 0x08, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x47, 0x02, 0x00, 0x12, 0x04,
    0x9f, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9f,
    0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9f, 0x05,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9f, 0x05, 0x18,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9f, 0x05, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x47, 0x02, 0x01, 0x12, 0x04, 0xa0, 0x05, 0x08, 0x2c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x47, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa0, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x47, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa0, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x47, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa0, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x47, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa0, 0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x47,
    0x02, 0x02, 0x12, 0x04, 0xa1, 0x05, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02,
    0x04, 0x12, 0x04, 0xa1, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xa1, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xa1, 0x05, 0x19, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x47, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xa1, 0x05, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x48, 0x12, 0x06, 0xa4, 0x05, 0x00, 0xaa,
    0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x48, 0x01, 0x12, 0x04, 0xa4, 0x05, 0x08, 0x27, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x00, 0x12, 0x04, 0xa5, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x48, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa5, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x48, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa5, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x48, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa5, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa5, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02,
    0x01, 0x12, 0x04, 0xa6, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xa6, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xa6, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xa6, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa6,
    0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x02, 0x12, 0x04, 0xa7, 0x05, 0x08,
    0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa7, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa7, 0x05, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x05, 0x18, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x48, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa7, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x48, 0x02, 0x03, 0x12, 0x04, 0xa8, 0x05, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x48, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa8, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xa8, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xa8, 0x05, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xa8, 0x05, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x48, 0x02, 0x04, 0x12,
    0x04, 0xa9, 0x05, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xa9, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x04, 0x05, 0x12, 0x04, 0xa9,
    0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x04, 0x01, 0x12, 0x04, 0xa9, 0x05,
    0x19, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x48, 0x02, 0x04, 0x03, 0x12, 0x04, 0xa9, 0x05, 0x30,
    0x31, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x49, 0x12, 0x06, 0xac, 0x05, 0x00, 0xb2, 0x05, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x49, 0x01, 0x12, 0x04, 0xac, 0x05, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x49, 0x02, 0x00, 0x12, 0x04, 0xad, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xad, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xad, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xad, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xad, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49, 0x02, 0x01, 0x12, 0x04,
    0xae, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x04, 0x12, 0x04, 0xae,
    0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x05, 0x12, 0x04, 0xae, 0x05,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x01, 0x12, 0x04, 0xae, 0x05, 0x19,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x01, 0x03, 0x12, 0x04, 0xae, 0x05, 0x2a, 0x2b,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49, 0x02, 0x02, 0x12, 0x04, 0xaf, 0x05, 0x08, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x49, 0x02, 0x02, 0x04, 0x12, 0x04, 0xaf, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x49, 0x02, 0x02, 0x05, 0x12, 0x04, 0xaf, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x49, 0x02, 0x02, 0x01, 0x12, 0x04, 0xaf, 0x05, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x49, 0x02, 0x02, 0x03, 0x12, 0x04, 0xaf, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49,
    0x02, 0x03, 0x12, 0x04, 0xb0, 0x05, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xb0, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xb0, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xb0, 0x05, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xb0, 0x05, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x49, 0x02, 0x04, 0x12, 0x04, 0xb1, 0x05,
    0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb1, 0x05, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb1, 0x05, 0x11, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb1, 0x05, 0x19, 0x2d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x49, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb1, 0x05, 0x30, 0x31, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x4a, 0x12, 0x06, 0xb4, 0x05, 0x00, 0xb9, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x4a, 0x01, 0x12, 0x04, 0xb4, 0x05, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4a, 0x02,
    0x00, 0x12, 0x04, 0xb5, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xb5, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xb5, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xb5, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb5,
    0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4a, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x05, 0x08,
    0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb6, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb6, 0x05, 0x11, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb6, 0x05, 0x19, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb6, 0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x4a, 0x02, 0x02, 0x12, 0x04, 0xb7, 0x05, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb7, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xb7, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02,
    0x02, 0x01, 0x12, 0x04, 0xb7, 0x05, 0x19, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x02,
    0x03, 0x12, 0x04, 0xb7, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4a, 0x02, 0x03, 0x12,
    0x04, 0xb8, 0x05, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xb8, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb8,
    0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb8, 0x05,
    0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4a, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb8, 0x05, 0x27,
    0x28, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4b, 0x12, 0x06, 0xbb, 0x05, 0x00, 0xc0, 0x05, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x4b, 0x01, 0x12, 0x04, 0xbb, 0x05, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x4b, 0x02, 0x00, 0x12, 0x04, 0xbc, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xbc, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xbc, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbc, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xbc, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4b, 0x02, 0x01, 0x12, 0x04,
    0xbd, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbd,
    0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbd, 0x05,
    0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbd, 0x05, 0x19,
    0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbd, 0x05, 0x2a, 0x2b,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4b, 0x02, 0x02, 0x12, 0x04, 0xbe, 0x05, 0x08, 0x2b, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4b, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbe, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4b, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbe, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4b, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbe, 0x05, 0x19, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4b, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbe, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4b,
    0x02, 0x03, 0x12, 0x04, 0xbf, 0x05, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xbf, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xbf, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xbf, 0x05, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4b, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xbf, 0x05, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4c, 0x12, 0x06, 0xc2, 0x05, 0x00, 0xc6,
    0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4c, 0x01, 0x12, 0x04, 0xc2, 0x05, 0x08, 0x22, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x4c, 0x02, 0x00, 0x12, 0x04, 0xc3, 0x05, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4c, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc3, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4c, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc3, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc3, 0x05, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xc3, 0x05, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4c, 0x02,
    0x01, 0x12, 0x04, 0xc4, 0x05, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xc4, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xc4, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xc4, 0x05, 0x19, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc4,
    0x05, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4c, 0x02, 0x02, 0x12, 0x04, 0xc5, 0x05, 0x08,
    0x33, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc5, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc5, 0x05, 0x11, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x4c, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc5, 0x05, 0x19, 0x2e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4c, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc5, 0x05, 0x31, 0x32, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x4d, 0x12, 0x06, 0xc8, 0x05, 0x00, 0xcc, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x4d, 0x01, 0x12, 0x04, 0xc8, 0x05, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4d, 0x02, 0x00,
    0x12, 0x04, 0xc9, 0x05, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xc9, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xc9, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc9,
    0x05, 0x19, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc9, 0x05,
    0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4d, 0x02, 0x01, 0x12, 0x04, 0xca, 0x05, 0x08, 0x2a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xca, 0x05, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xca, 0x05, 0x11, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4d, 0x02, 0x01, 0x01, 0x12, 0x04, 0xca, 0x05, 0x19, 0x25, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4d, 0x02, 0x01, 0x03, 0x12, 0x04, 0xca, 0x05, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x4d, 0x02, 0x02, 0x12, 0x04, 0xcb, 0x05, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xcb, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xcb, 0x05, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xcb, 0x05, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4d, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xcb, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4e, 0x12, 0x06, 0xce, 0x05,
    0x00, 0xd6, 0x05, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4e, 0x01, 0x12, 0x04, 0xce, 0x05, 0x08,
    0x1c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4e, 0x02, 0x00, 0x12, 0x04, 0xcf, 0x05, 0x08, 0x2e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcf, 0x05, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcf, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcf, 0x05, 0x19, 0x29, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4e, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcf, 0x05, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x4e, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x05, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd0, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xd0, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xd0, 0x05, 0x19, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xd0, 0x05, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4e, 0x02, 0x02, 0x12, 0x04, 0xd1,
    0x05, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd1, 0x05,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd1, 0x05, 0x11,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x05, 0x19, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd1, 0x05, 0x2b, 0x2c, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x4e, 0x02, 0x03, 0x12, 0x04, 0xd2, 0x05, 0x08, 0x29, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4e, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd2, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4e, 0x02, 0x03, 0x05, 0x12, 0x04, 0xd2, 0x05, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4e, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd2, 0x05, 0x17, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xd2, 0x05, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4e, 0x02,
    0x04, 0x12, 0x04, 0xd3, 0x05, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x04, 0x04,
    0x12, 0x04, 0xd3, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x04, 0x05, 0x12,
    0x04, 0xd3, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xd3, 0x05, 0x19, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd3,
    0x05, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4e, 0x02, 0x05, 0x12, 0x04, 0xd4, 0x05, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x05, 0x04, 0x12, 0x04, 0xd4, 0x05, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x05, 0x05, 0x12, 0x04, 0xd4, 0x05, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd4, 0x05, 0x18, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x4e, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd4, 0x05, 0x24, 0x25, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x4e, 0x02, 0x06, 0x12, 0x04, 0xd5, 0x05, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4e, 0x02, 0x06, 0x04, 0x12, 0x04, 0xd5, 0x05, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xd5, 0x05, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02,
    0x06, 0x01, 0x12, 0x04, 0xd5, 0x05, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4e, 0x02, 0x06,
    0x03, 0x12, 0x04, 0xd5, 0x05, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x4f, 0x12, 0x06, 0xd8,
    0x05, 0x00, 0x84, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x4f, 0x01, 0x12, 0x04, 0xd8, 0x05,
    0x08, 0x21, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x4f, 0x03, 0x00, 0x12, 0x06, 0xd9, 0x05, 0x08, 0xe1,
    0x05, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x03, 0x00, 0x01, 0x12, 0x04, 0xd9, 0x05, 0x10,
    0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xda, 0x05, 0x10,
    0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xda, 0x05,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xda,
    0x05, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xda, 0x05, 0x1f, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xda, 0x05, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x01, 0x12,
    0x04, 0xdb, 0x05, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xdb, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xdb, 0x05, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xdb, 0x05, 0x1f, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xdb, 0x05, 0x33, 0x34, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03,
    0x00, 0x02, 0x02, 0x12, 0x04, 0xdc, 0x05, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xdc, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xdc, 0x05, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xdc, 0x05, 0x1f, 0x2f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xdc, 0x05, 0x32, 0x33, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xdd, 0x05, 0x10, 0x37, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xdd, 0x05, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xdd, 0x05, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xdd, 0x05, 0x1f, 0x32,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xdd, 0x05, 0x35,
    0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xde, 0x05, 0x10,
    0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xde, 0x05,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xde,
    0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xde, 0x05, 0x20, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12,
    0x04, 0xde, 0x05, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x05, 0x12,
    0x04, 0xdf, 0x05, 0x10, 0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x05, 0x04,
    0x12, 0x04, 0xdf, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02, 0x05,
    0x05, 0x12, 0x04, 0xdf, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x04, 0xdf, 0x05, 0x20, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x00,
    0x02, 0x05, 0x03, 0x12, 0x04, 0xdf, 0x05, 0x37, 0x38, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03,
    0x00, 0x02, 0x06, 0x12, 0x04, 0xe0, 0x05, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xe0, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xe0, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xe0, 0x05, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xe0, 0x05, 0x30, 0x31, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x4f, 0x03, 0x01, 0x12, 0x06, 0xe3, 0x05, 0x08, 0xe9, 0x05, 0x09, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4f, 0x03, 0x01, 0x01, 0x12, 0x04, 0xe3, 0x05, 0x10, 0x19, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x4f, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xe4, 0x05, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe4, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe4, 0x05, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe4, 0x05, 0x20, 0x29, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe4, 0x05, 0x2c, 0x2d,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xe5, 0x05, 0x10, 0x2f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe5, 0x05, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe5, 0x05,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe5,
    0x05, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xe5, 0x05, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04,
    0xe6, 0x05, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xe6, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xe6, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xe6, 0x05, 0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xe6, 0x05, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x01,
    0x02, 0x03, 0x12, 0x04, 0xe7, 0x05, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xe7, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x01, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe7, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe7, 0x05, 0x20, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe7, 0x05, 0x31, 0x32, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x4f, 0x03, 0x01, 0x02, 0x04, 0x12, 0x04, 0xe8, 0x05, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x01, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe8, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe8, 0x05, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe8, 0x05, 0x20, 0x2a, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x01, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe8, 0x05, 0x2d, 0x2e,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x4f, 0x03, 0x02, 0x12, 0x06, 0xeb, 0x05, 0x08, 0x80, 0x06, 0x09,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x03, 0x02, 0x01, 0x12, 0x04, 0xeb, 0x05, 0x10, 0x1b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x00, 0x12, 0x04, 0xec, 0x05, 0x10, 0x34, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x00, 0x04, 0x12, 0x04, 0xec, 0x05, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x00, 0x05, 0x12, 0x04, 0xec, 0x05, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xec, 0x05,
    0x20, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xec,
    0x05, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0xed,
    0x05, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xed, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xed, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xed, 0x05, 0x20, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xed, 0x05, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x02, 0x12, 0x04, 0xee, 0x05, 0x10, 0x4c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xee, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02,
    0x02, 0x02, 0x06, 0x12, 0x04, 0xee, 0x05, 0x19, 0x3d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x02, 0x02, 0x02, 0x01, 0x12, 0x04, 0xee, 0x05, 0x3e, 0x47, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x02, 0x02, 0x02, 0x03, 0x12, 0x04, 0xee, 0x05, 0x4a, 0x4b, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0xef, 0x05, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x03, 0x04, 0x12, 0x04, 0xef, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x02, 0x02, 0x03, 0x05, 0x12, 0x04, 0xef, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x03, 0x01, 0x12, 0x04, 0xef, 0x05, 0x20, 0x2e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x03, 0x03, 0x12, 0x04, 0xef, 0x05, 0x31, 0x32, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf0, 0x05, 0x10, 0x36, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf0, 0x05, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x04, 0x05, 0x12, 0x04, 0xf0, 0x05, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf0, 0x05,
    0x20, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf0,
    0x05, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf1,
    0x05, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x05, 0x04, 0x12, 0x04,
    0xf1, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x05, 0x05, 0x12,
    0x04, 0xf1, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xf1, 0x05, 0x20, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xf1, 0x05, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x06, 0x12, 0x04, 0xf2, 0x05, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xf2, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02,
    0x02, 0x06, 0x05, 0x12, 0x04, 0xf2, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x02, 0x02, 0x06, 0x01, 0x12, 0x04, 0xf2, 0x05, 0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x02, 0x02, 0x06, 0x03, 0x12, 0x04, 0xf2, 0x05, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x07, 0x12, 0x04, 0xf3, 0x05, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x07, 0x04, 0x12, 0x04, 0xf3, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x02, 0x02, 0x07, 0x05, 0x12, 0x04, 0xf3, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x07, 0x01, 0x12, 0x04, 0xf3, 0x05, 0x20, 0x30, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x07, 0x03, 0x12, 0x04, 0xf3, 0x05, 0x33, 0x34, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x08, 0x12, 0x04, 0xf4, 0x05, 0x10, 0x2e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x08, 0x04, 0x12, 0x04, 0xf4, 0x05, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x08, 0x05, 0x12, 0x04, 0xf4, 0x05, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x08, 0x01, 0x12, 0x04, 0xf4, 0x05,
    0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x08, 0x03, 0x12, 0x04, 0xf4,
    0x05, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x09, 0x12, 0x04, 0xf5,
    0x05, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x09, 0x04, 0x12, 0x04,
    0xf5, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x09, 0x05, 0x12,
    0x04, 0xf5, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x09, 0x01,
    0x12, 0x04, 0xf5, 0x05, 0x20, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x09,
    0x03, 0x12, 0x04, 0xf5, 0x05, 0x31, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x0a, 0x12, 0x04, 0xf6, 0x05, 0x10, 0x34, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x0a, 0x04, 0x12, 0x04, 0xf6, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02,
    0x02, 0x0a, 0x05, 0x12, 0x04, 0xf6, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x02, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xf6, 0x05, 0x20, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x02, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xf6, 0x05, 0x31, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x0b, 0x12, 0x04, 0xf7, 0x05, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x0b, 0x04, 0x12, 0x04, 0xf7, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x02, 0x02, 0x0b, 0x05, 0x12, 0x04, 0xf7, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0b, 0x01, 0x12, 0x04, 0xf7, 0x05, 0x20, 0x2d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0b, 0x03, 0x12, 0x04, 0xf7, 0x05, 0x30, 0x32, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0c, 0x12, 0x04, 0xf8, 0x05, 0x10, 0x3c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xf8, 0x05, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xf8, 0x05, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xf8, 0x05,
    0x20, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xf8,
    0x05, 0x39, 0x3b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0d, 0x12, 0x04, 0xf9,
    0x05, 0x10, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0d, 0x04, 0x12, 0x04,
    0xf9, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0d, 0x05, 0x12,
    0x04, 0xf9, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0d, 0x01,
    0x12, 0x04, 0xf9, 0x05, 0x20, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0d,
    0x03, 0x12, 0x04, 0xf9, 0x05, 0x33, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x0e, 0x12, 0x04, 0xfa, 0x05, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x0e, 0x04, 0x12, 0x04, 0xfa, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02,
    0x02, 0x0e, 0x05, 0x12, 0x04, 0xfa, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x02, 0x02, 0x0e, 0x01, 0x12, 0x04, 0xfa, 0x05, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x02, 0x02, 0x0e, 0x03, 0x12, 0x04, 0xfa, 0x05, 0x30, 0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x0f, 0x12, 0x04, 0xfb, 0x05, 0x10, 0x3f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x0f, 0x04, 0x12, 0x04, 0xfb, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x02, 0x02, 0x0f, 0x05, 0x12, 0x04, 0xfb, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0f, 0x01, 0x12, 0x04, 0xfb, 0x05, 0x20, 0x39, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x0f, 0x03, 0x12, 0x04, 0xfb, 0x05, 0x3c, 0x3e, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x10, 0x12, 0x04, 0xfc, 0x05, 0x10, 0x3b, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x10, 0x04, 0x12, 0x04, 0xfc, 0x05, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x10, 0x05, 0x12, 0x04, 0xfc, 0x05, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x10, 0x01, 0x12, 0x04, 0xfc, 0x05,
    0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x10, 0x03, 0x12, 0x04, 0xfc,
    0x05, 0x38, 0x3a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x11, 0x12, 0x04, 0xfd,
    0x05, 0x10, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x11, 0x04, 0x12, 0x04,
    0xfd, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x11, 0x05, 0x12,
    0x04, 0xfd, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x11, 0x01,
    0x12, 0x04, 0xfd, 0x05, 0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x11,
    0x03, 0x12, 0x04, 0xfd, 0x05, 0x38, 0x3a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x12, 0x12, 0x04, 0xfe, 0x05, 0x10, 0x3b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02,
    0x12, 0x04, 0x12, 0x04, 0xfe, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02,
    0x02, 0x12, 0x05, 0x12, 0x04, 0xfe, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f, 0x03,
    0x02, 0x02, 0x12, 0x01, 0x12, 0x04, 0xfe, 0x05, 0x20, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x4f,
    0x03, 0x02, 0x02, 0x12, 0x03, 0x12, 0x04, 0xfe, 0x05, 0x38, 0x3a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x13, 0x12, 0x04, 0xff, 0x05, 0x10, 0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x4f, 0x03, 0x02, 0x02, 0x13, 0x04, 0x12, 0x04, 0xff, 0x05, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x4f, 0x03, 0x02, 0x02, 0x13, 0x05, 0x12, 0x04, 0xff, 0x05, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x13, 0x01, 0x12, 0x04, 0xff, 0x05, 0x20, 0x33, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x4f, 0x03, 0x02, 0x02, 0x13, 0x03, 0x12, 0x04, 0xff, 0x05, 0x36, 0x38, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x4f, 0x02, 0x00, 0x12, 0x04, 0x82, 0x06, 0x08, 0x48, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x4f, 0x02, 0x00, 0x04, 0x12, 0x04, 0x82, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x4f, 0x02, 0x00, 0x06, 0x12, 0x04, 0x82, 0x06, 0x11, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x4f, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x06, 0x38, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x06, 0x46, 0x47, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x4f, 0x02,
    0x01, 0x12, 0x04, 0x83, 0x06, 0x08, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x83, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x01, 0x06, 0x12,
    0x04, 0x83, 0x06, 0x11, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x83, 0x06, 0x38, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x4f, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83,
    0x06, 0x46, 0x47, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x50, 0x12, 0x06, 0x86, 0x06, 0x00, 0x8e, 0x06,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x50, 0x01, 0x12, 0x04, 0x86, 0x06, 0x08, 0x22, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x50, 0x03, 0x00, 0x12, 0x06, 0x87, 0x06, 0x08, 0x8a, 0x06, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x50, 0x03, 0x00, 0x01, 0x12, 0x04, 0x87, 0x06, 0x10, 0x26, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x50, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x88, 0x06, 0x10, 0x2b, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x88, 0x06, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x88, 0x06, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x88, 0x06, 0x20, 0x26,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x88, 0x06, 0x29,
    0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x50, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x89, 0x06, 0x10,
    0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x89, 0x06,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x89,
    0x06, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x89, 0x06, 0x1e, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x50, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x89, 0x06, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x50, 0x02, 0x00, 0x12, 0x04, 0x8c,
    0x06, 0x08, 0x5f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x04, 0x12, 0x04, 0x8c, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8c, 0x06, 0x11,
    0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8c, 0x06, 0x44, 0x5a,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8c, 0x06, 0x5d, 0x5e, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x50, 0x02, 0x01, 0x12, 0x04, 0x8d, 0x06, 0x08, 0x3a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x50, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8d, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x50, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8d, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x50, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8d, 0x06, 0x18, 0x35, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x50,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x8d, 0x06, 0x38, 0x39, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x51, 0x12,
    0x06, 0x90, 0x06, 0x00, 0x95, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x51, 0x01, 0x12, 0x04,
    0x90, 0x06, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x51, 0x02, 0x00, 0x12, 0x04, 0x91, 0x06,
    0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x00, 0x04, 0x12, 0x04, 0x91, 0x06, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x00, 0x05, 0x12, 0x04, 0x91, 0x06, 0x11, 0x18,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x00, 0x01, 0x12, 0x04, 0x91, 0x06, 0x19, 0x20, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x00, 0x03, 0x12, 0x04, 0x91, 0x06, 0x23, 0x24, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x51, 0x02, 0x01, 0x12, 0x04, 0x92, 0x06, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x51, 0x02, 0x01, 0x04, 0x12, 0x04, 0x92, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x51, 0x02, 0x01, 0x05, 0x12, 0x04, 0x92, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x92, 0x06, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x92, 0x06, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x51, 0x02, 0x02,
    0x12, 0x04, 0x93, 0x06, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x93, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x02, 0x05, 0x12, 0x04,
    0x93, 0x06, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x02, 0x01, 0x12, 0x04, 0x93,
    0x06, 0x17, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x02, 0x03, 0x12, 0x04, 0x93, 0x06,
    0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x51, 0x02, 0x03, 0x12, 0x04, 0x94, 0x06, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x03, 0x04, 0x12, 0x04, 0x94, 0x06, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x51, 0x02, 0x03, 0x05, 0x12, 0x04, 0x94, 0x06, 0x11, 0x18, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x51, 0x02, 0x03, 0x01, 0x12, 0x04, 0x94, 0x06, 0x19, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x51, 0x02, 0x03, 0x03, 0x12, 0x04, 0x94, 0x06, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x52, 0x12, 0x06, 0x97, 0x06, 0x00, 0xa8, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x52,
    0x01, 0x12, 0x04, 0x97, 0x06, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x52, 0x03, 0x00, 0x12,
    0x06, 0x98, 0x06, 0x08, 0x9b, 0x06, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x03, 0x00, 0x01,
    0x12, 0x04, 0x98, 0x06, 0x10, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x52, 0x03, 0x00, 0x02, 0x00,
    0x12, 0x04, 0x99, 0x06, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x99, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x00, 0x02,
    0x00, 0x05, 0x12, 0x04, 0x99, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x06, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x99, 0x06, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x52,
    0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x9a, 0x06, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x52, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9a, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x52, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9a, 0x06, 0x20, 0x2a, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x52, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9a, 0x06, 0x2d, 0x2e, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x52, 0x03, 0x01, 0x12, 0x06, 0x9d, 0x06, 0x08, 0xa0, 0x06, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x52, 0x03, 0x01, 0x01, 0x12, 0x04, 0x9d, 0x06, 0x10, 0x22, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x52, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0x9e, 0x06, 0x10, 0x33, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9e, 0x06, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9e, 0x06, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9e, 0x06, 0x20, 0x2e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9e, 0x06, 0x31,
    0x32, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x52, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0x9f, 0x06, 0x10,
    0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0x9f, 0x06,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9f,
    0x06, 0x19, 0x20, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x9f, 0x06, 0x21, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x52, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x9f, 0x06, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x00, 0x12, 0x04, 0xa2,
    0x06, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa2, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa2, 0x06, 0x11,
    0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa2, 0x06, 0x19, 0x20,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2, 0x06, 0x23, 0x24, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x01, 0x12, 0x04, 0xa3, 0x06, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x52, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa3, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x52, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa3, 0x06, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x52, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa3, 0x06, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xa3, 0x06, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02,
    0x01, 0x08, 0x12, 0x04, 0xa3, 0x06, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x01,
    0x07, 0x12, 0x04, 0xa3, 0x06, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x02, 0x12,
    0x04, 0xa4, 0x06, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xa4, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa4,
    0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x06,
    0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x02, 0x03, 0x12, 0x04, 0xa4, 0x06, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x03, 0x12, 0x04, 0xa5, 0x06, 0x08, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa5, 0x06, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x52, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa5, 0x06, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x52, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa5, 0x06, 0x17, 0x1d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x52, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa5, 0x06, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x52, 0x02, 0x04, 0x12, 0x04, 0xa6, 0x06, 0x08, 0x41, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xa6, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x04,
    0x06, 0x12, 0x04, 0xa6, 0x06, 0x11, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x04, 0x01,
    0x12, 0x04, 0xa6, 0x06, 0x37, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x04, 0x03, 0x12,
    0x04, 0xa6, 0x06, 0x3f, 0x40, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x52, 0x02, 0x05, 0x12, 0x04, 0xa7,
    0x06, 0x08, 0x5b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x05, 0x04, 0x12, 0x04, 0xa7, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x05, 0x06, 0x12, 0x04, 0xa7, 0x06, 0x11,
    0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x05, 0x01, 0x12, 0x04, 0xa7, 0x06, 0x44, 0x56,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x52, 0x02, 0x05, 0x03, 0x12, 0x04, 0xa7, 0x06, 0x59, 0x5a, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x53, 0x12, 0x06, 0xaa, 0x06, 0x00, 0xb5, 0x06, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x53, 0x01, 0x12, 0x04, 0xaa, 0x06, 0x08, 0x28, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x53,
    0x03, 0x00, 0x12, 0x06, 0xab, 0x06, 0x08, 0xae, 0x06, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53,
    0x03, 0x00, 0x01, 0x12, 0x04, 0xab, 0x06, 0x10, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x53, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xac, 0x06, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x53, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xac, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x53,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xac, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x53, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xac, 0x06, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x53, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xac, 0x06, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x53, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xad, 0x06, 0x10, 0x38, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x53, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xad, 0x06, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x53, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xad, 0x06, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x53, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xad, 0x06, 0x20, 0x33,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x53, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xad, 0x06, 0x36,
    0x37, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x53, 0x02, 0x00, 0x12, 0x04, 0xb0, 0x06, 0x08, 0x25, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0, 0x06, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x53, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x53, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb0, 0x06, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x53, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb0, 0x06, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x53, 0x02, 0x01, 0x12, 0x04, 0xb1, 0x06, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xb1, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xb1, 0x06, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xb1, 0x06, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xb1, 0x06, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01, 0x08, 0x12, 0x04,
    0xb1, 0x06, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x01, 0x07, 0x12, 0x04, 0xb1,
    0x06, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x53, 0x02, 0x02, 0x12, 0x04, 0xb2, 0x06, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb2, 0x06, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb2, 0x06, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb2, 0x06, 0x18, 0x21, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x53, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb2, 0x06, 0x24, 0x25, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x53, 0x02, 0x03, 0x12, 0x04, 0xb3, 0x06, 0x08, 0x67, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x53, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb3, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53,
    0x02, 0x03, 0x06, 0x12, 0x04, 0xb3, 0x06, 0x11, 0x4a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xb3, 0x06, 0x4b, 0x62, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xb3, 0x06, 0x65, 0x66, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x53, 0x02, 0x04, 0x12,
    0x04, 0xb4, 0x06, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xb4, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb4,
    0x06, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb4, 0x06,
    0x16, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x53, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb4, 0x06, 0x2a,
    0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x54, 0x12, 0x06, 0xb7, 0x06, 0x00, 0xc3, 0x06, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x54, 0x01, 0x12, 0x04, 0xb7, 0x06, 0x08, 0x21, 0x0a, 0x0e, 0x0a, 0x04,
    0x04, 0x54, 0x03, 0x00, 0x12, 0x06, 0xb8, 0x06, 0x08, 0xbb, 0x06, 0x09, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x54, 0x03, 0x00, 0x01, 0x12, 0x04, 0xb8, 0x06, 0x10, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x54, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb9, 0x06, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x54, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb9, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x54, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb9, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x54, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb9, 0x06, 0x20, 0x27, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x54, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb9, 0x06, 0x2a, 0x2b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x54, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xba, 0x06, 0x10, 0x2f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x54, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xba, 0x06, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x54, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xba, 0x06, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x54, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xba, 0x06,
    0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x54, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xba,
    0x06, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x00, 0x12, 0x04, 0xbd, 0x06, 0x08,
    0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbd, 0x06, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbd, 0x06, 0x11, 0x18, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbd, 0x06, 0x19, 0x20, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x54, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbd, 0x06, 0x23, 0x24, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x54, 0x02, 0x01, 0x12, 0x04, 0xbe, 0x06, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x54, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbe, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xbe, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xbe, 0x06, 0x19, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xbe, 0x06, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x02, 0x12,
    0x04, 0xbf, 0x06, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xbf, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbf,
    0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbf, 0x06,
    0x19, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbf, 0x06, 0x2b,
    0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x03, 0x12, 0x04, 0xc0, 0x06, 0x08, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc0, 0x06, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x54, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc0, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x54, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc0, 0x06, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x54, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc0, 0x06, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x54, 0x02, 0x04, 0x12, 0x04, 0xc1, 0x06, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xc1, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xc1, 0x06, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04, 0x01,
    0x12, 0x04, 0xc1, 0x06, 0x16, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x04, 0x03, 0x12,
    0x04, 0xc1, 0x06, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x54, 0x02, 0x05, 0x12, 0x04, 0xc2,
    0x06, 0x08, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x05, 0x04, 0x12, 0x04, 0xc2, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x05, 0x06, 0x12, 0x04, 0xc2, 0x06, 0x11,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x05, 0x01, 0x12, 0x04, 0xc2, 0x06, 0x32, 0x37,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x54, 0x02, 0x05, 0x03, 0x12, 0x04, 0xc2, 0x06, 0x3a, 0x3b, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x55, 0x12, 0x06, 0xc5, 0x06, 0x00, 0xcf, 0x06, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x55, 0x01, 0x12, 0x04, 0xc5, 0x06, 0x08, 0x1e, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x55,
    0x03, 0x00, 0x12, 0x06, 0xc6, 0x06, 0x08, 0xc9, 0x06, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55,
    0x03, 0x00, 0x01, 0x12, 0x04, 0xc6, 0x06, 0x10, 0x1d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x55, 0x03,
    0x00, 0x02, 0x00, 0x12, 0x04, 0xc7, 0x06, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x55, 0x03,
    0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc7, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x55,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc7, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x55, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x06, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x55, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc7, 0x06, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x55, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xc8, 0x06, 0x10, 0x2f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x55, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc8, 0x06, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x55, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc8, 0x06, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x55, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc8, 0x06, 0x20, 0x2a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x55, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc8, 0x06, 0x2d,
    0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x55, 0x02, 0x00, 0x12, 0x04, 0xcb, 0x06, 0x08, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcb, 0x06, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x55, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcb, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x55, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcb, 0x06, 0x19, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x55, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcb, 0x06, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x55, 0x02, 0x01, 0x12, 0x04, 0xcc, 0x06, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xcc, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xcc, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xcc, 0x06, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xcc, 0x06, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x55, 0x02, 0x02, 0x12, 0x04, 0xcd,
    0x06, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcd, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x02, 0x05, 0x12, 0x04, 0xcd, 0x06, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x06, 0x18, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55, 0x02, 0x02, 0x03, 0x12, 0x04, 0xcd, 0x06, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x55, 0x02, 0x03, 0x12, 0x04, 0xce, 0x06, 0x08, 0x49, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x55, 0x02, 0x03, 0x04, 0x12, 0x04, 0xce, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x55, 0x02, 0x03, 0x06, 0x12, 0x04, 0xce, 0x06, 0x11, 0x36, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x55, 0x02, 0x03, 0x01, 0x12, 0x04, 0xce, 0x06, 0x37, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x55,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xce, 0x06, 0x47, 0x48, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x56, 0x12,
    0x06, 0xd1, 0x06, 0x00, 0xda, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x56, 0x01, 0x12, 0x04,
    0xd1, 0x06, 0x08, 0x20, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x56, 0x03, 0x00, 0x12, 0x06, 0xd2, 0x06,
    0x08, 0xd5, 0x06, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x03, 0x00, 0x01, 0x12, 0x04, 0xd2,
    0x06, 0x10, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x56, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd3,
    0x06, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xd3, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xd3, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xd3, 0x06, 0x20, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xd3, 0x06, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x56, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xd4, 0x06, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xd4, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xd4, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd4, 0x06, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x56,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd4, 0x06, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x56, 0x02, 0x00, 0x12, 0x04, 0xd7, 0x06, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xd7, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xd7, 0x06, 0x11, 0x18, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xd7, 0x06, 0x19, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xd7, 0x06, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x56, 0x02, 0x01, 0x12, 0x04, 0xd8,
    0x06, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x06, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd8, 0x06, 0x16, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd8, 0x06, 0x27, 0x28, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x56, 0x02, 0x02, 0x12, 0x04, 0xd9, 0x06, 0x08, 0x4d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x56, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd9, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x56, 0x02, 0x02, 0x06, 0x12, 0x04, 0xd9, 0x06, 0x11, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x56, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd9, 0x06, 0x3a, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x56,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xd9, 0x06, 0x4b, 0x4c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x57, 0x12,
    0x06, 0xdc, 0x06, 0x00, 0xdd, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x57, 0x01, 0x12, 0x04,
    0xdc, 0x06, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x58, 0x12, 0x06, 0xdf, 0x06, 0x00, 0xe1,
    0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x58, 0x01, 0x12, 0x04, 0xdf, 0x06, 0x08, 0x2c, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x58, 0x02, 0x00, 0x12, 0x04, 0xe0, 0x06, 0x08, 0x2c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x58, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe0, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x58, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe0, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x58, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe0, 0x06, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x58,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe0, 0x06, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x59, 0x12,
    0x06, 0xe3, 0x06, 0x00, 0xf2, 0x06, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x59, 0x01, 0x12, 0x04,
    0xe3, 0x06, 0x08, 0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x59, 0x03, 0x00, 0x12, 0x06, 0xe4, 0x06,
    0x08, 0xe8, 0x06, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x03, 0x00, 0x01, 0x12, 0x04, 0xe4,
    0x06, 0x10, 0x14, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x59, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xe5,
    0x06, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xe5, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xe5, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03, 0x00, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xe5, 0x06, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xe5, 0x06, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x59, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xe6, 0x06, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03, 0x00, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xe6, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03, 0x00,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xe6, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe6, 0x06, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x59,
    0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe6, 0x06, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x59, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xe7, 0x06, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x59, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe7, 0x06, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x59, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe7, 0x06, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x59, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe7, 0x06, 0x20, 0x30, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x59, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe7, 0x06, 0x33, 0x34, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02, 0x00, 0x12, 0x04, 0xea, 0x06, 0x08, 0x2c, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x59, 0x02, 0x00, 0x04, 0x12, 0x04, 0xea, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x59, 0x02, 0x00, 0x05, 0x12, 0x04, 0xea, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x59, 0x02, 0x00, 0x01, 0x12, 0x04, 0xea, 0x06, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xea, 0x06, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02,
    0x01, 0x12, 0x04, 0xeb, 0x06, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xeb, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xeb, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xeb, 0x06, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x01, 0x03, 0x12, 0x04, 0xeb,
    0x06, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02, 0x02, 0x12, 0x04, 0xec, 0x06, 0x08,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x02, 0x04, 0x12, 0x04, 0xec, 0x06, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x02, 0x05, 0x12, 0x04, 0xec, 0x06, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x02, 0x01, 0x12, 0x04, 0xec, 0x06, 0x18, 0x1a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x59, 0x02, 0x02, 0x03, 0x12, 0x04, 0xec, 0x06, 0x1d, 0x1e, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x59, 0x02, 0x03, 0x12, 0x04, 0xed, 0x06, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x59, 0x02, 0x03, 0x04, 0x12, 0x04, 0xed, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xed, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xed, 0x06, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x03,
    0x03, 0x12, 0x04, 0xed, 0x06, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02, 0x04, 0x12,
    0x04, 0xee, 0x06, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x04, 0x04, 0x12, 0x04,
    0xee, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x04, 0x05, 0x12, 0x04, 0xee,
    0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x04, 0x01, 0x12, 0x04, 0xee, 0x06,
    0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x04, 0x03, 0x12, 0x04, 0xee, 0x06, 0x24,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02, 0x05, 0x12, 0x04, 0xef, 0x06, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x05, 0x04, 0x12, 0x04, 0xef, 0x06, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x59, 0x02, 0x05, 0x05, 0x12, 0x04, 0xef, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x59, 0x02, 0x05, 0x01, 0x12, 0x04, 0xef, 0x06, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x59, 0x02, 0x05, 0x03, 0x12, 0x04, 0xef, 0x06, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x59, 0x02, 0x06, 0x12, 0x04, 0xf0, 0x06, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02,
    0x06, 0x04, 0x12, 0x04, 0xf0, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x06,
    0x05, 0x12, 0x04, 0xf0, 0x06, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x06, 0x01,
    0x12, 0x04, 0xf0, 0x06, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x06, 0x03, 0x12,
    0x04, 0xf0, 0x06, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x59, 0x02, 0x07, 0x12, 0x04, 0xf1,
    0x06, 0x08, 0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x07, 0x04, 0x12, 0x04, 0xf1, 0x06,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x07, 0x06, 0x12, 0x04, 0xf1, 0x06, 0x11,
    0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x07, 0x01, 0x12, 0x04, 0xf1, 0x06, 0x3a, 0x47,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x59, 0x02, 0x07, 0x03, 0x12, 0x04, 0xf1, 0x06, 0x4a, 0x4b, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x5a, 0x12, 0x06, 0xf4, 0x06, 0x00, 0xfa, 0x06, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x5a, 0x01, 0x12, 0x04, 0xf4, 0x06, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5a,
    0x02, 0x00, 0x12, 0x04, 0xf5, 0x06, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xf5, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xf5, 0x06, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xf5, 0x06, 0x16, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xf5, 0x06, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5a, 0x02, 0x01, 0x12, 0x04, 0xf6, 0x06,
    0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf6, 0x06, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf6, 0x06, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf6, 0x06, 0x16, 0x1b, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf6, 0x06, 0x1e, 0x1f, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x5a, 0x02, 0x02, 0x12, 0x04, 0xf7, 0x06, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf7, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x5a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf7, 0x06, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xf7, 0x06, 0x16, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xf7, 0x06, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5a, 0x02, 0x03,
    0x12, 0x04, 0xf8, 0x06, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xf8, 0x06, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xf8, 0x06, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x03, 0x01, 0x12, 0x04, 0xf8,
    0x06, 0x16, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x03, 0x03, 0x12, 0x04, 0xf8, 0x06,
    0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5a, 0x02, 0x04, 0x12, 0x04, 0xf9, 0x06, 0x08, 0x28,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x04, 0x04, 0x12, 0x04, 0xf9, 0x06, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5a, 0x02, 0x04, 0x05, 0x12, 0x04, 0xf9, 0x06, 0x11, 0x15, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5a, 0x02, 0x04, 0x01, 0x12, 0x04, 0xf9, 0x06, 0x16, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5a, 0x02, 0x04, 0x03, 0x12, 0x04, 0xf9, 0x06, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x5b, 0x12, 0x06, 0xfc, 0x06, 0x00, 0x96, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5b,
    0x01, 0x12, 0x04, 0xfc, 0x06, 0x08, 0x2a, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x5b, 0x03, 0x00, 0x12,
    0x06, 0xfd, 0x06, 0x08, 0x92, 0x07, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xfd, 0x06, 0x10, 0x13, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x03, 0x00,
    0x12, 0x06, 0xfe, 0x06, 0x10, 0x81, 0x07, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00,
    0x03, 0x00, 0x01, 0x12, 0x04, 0xfe, 0x06, 0x18, 0x1b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x5b, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xff, 0x06, 0x18, 0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xff, 0x06, 0x18, 0x20, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xff, 0x06, 0x21,
    0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xff, 0x06, 0x28, 0x2d, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xff, 0x06, 0x30, 0x31, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x5b, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0x80, 0x07, 0x18, 0x34, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x5b, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x80, 0x07, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x80, 0x07, 0x21, 0x25, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x80, 0x07,
    0x26, 0x2f, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x5b, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x80, 0x07, 0x32, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0x83, 0x07, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0x83, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x83, 0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0x83, 0x07, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x83, 0x07, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0x84, 0x07, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x84, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x84, 0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x5b, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x84, 0x07, 0x20, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x5b, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x84, 0x07, 0x2b, 0x2c, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x85, 0x07, 0x10, 0x2e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x85, 0x07, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x85, 0x07, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x85, 0x07, 0x20, 0x28,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x85, 0x07, 0x2b,
    0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x86, 0x07, 0x10,
    0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0x86, 0x07,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0x86,
    0x07, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04,
    0x86, 0x07, 0x1e, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12,
    0x04, 0x86, 0x07, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x04, 0x12,
    0x04, 0x87, 0x07, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x04, 0x04,
    0x12, 0x04, 0x87, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x04,
    0x05, 0x12, 0x04, 0x87, 0x07, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02,
    0x04, 0x01, 0x12, 0x04, 0x87, 0x07, 0x1e, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00,
    0x02, 0x04, 0x03, 0x12, 0x04, 0x87, 0x07, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x05, 0x12, 0x04, 0x88, 0x07, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0x88, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b,
    0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0x88, 0x07, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x5b, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0x88, 0x07, 0x1e, 0x29, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x5b, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0x88, 0x07, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0x89, 0x07, 0x10, 0x35, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0x89, 0x07, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0x89, 0x07, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0x89, 0x07, 0x20, 0x30,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0x89, 0x07, 0x33,
    0x34, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x07, 0x12, 0x04, 0x8a, 0x07, 0x10,
    0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04, 0x8a, 0x07,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x07, 0x05, 0x12, 0x04, 0x8a,
    0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x07, 0x01, 0x12, 0x04,
    0x8a, 0x07, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x07, 0x03, 0x12,
    0x04, 0x8a, 0x07, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x08, 0x12,
    0x04, 0x8b, 0x07, 0x10, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x08, 0x04,
    0x12, 0x04, 0x8b, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x08,
    0x05, 0x12, 0x04, 0x8b, 0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02,
    0x08, 0x01, 0x12, 0x04, 0x8b, 0x07, 0x20, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00,
    0x02, 0x08, 0x03, 0x12, 0x04, 0x8b, 0x07, 0x36, 0x37, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x09, 0x12, 0x04, 0x8c, 0x07, 0x10, 0x33, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x09, 0x04, 0x12, 0x04, 0x8c, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b,
    0x03, 0x00, 0x02, 0x09, 0x05, 0x12, 0x04, 0x8c, 0x07, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x5b, 0x03, 0x00, 0x02, 0x09, 0x01, 0x12, 0x04, 0x8c, 0x07, 0x1e, 0x2d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x5b, 0x03, 0x00, 0x02, 0x09, 0x03, 0x12, 0x04, 0x8c, 0x07, 0x30, 0x32, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0a, 0x12, 0x04, 0x8d, 0x07, 0x10, 0x35, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0a, 0x04, 0x12, 0x04, 0x8d, 0x07, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0a, 0x05, 0x12, 0x04, 0x8d, 0x07, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0a, 0x01, 0x12, 0x04, 0x8d, 0x07, 0x20, 0x2f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0a, 0x03, 0x12, 0x04, 0x8d, 0x07, 0x32,
    0x34, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0b, 0x12, 0x04, 0x8e, 0x07, 0x10,
    0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0b, 0x04, 0x12, 0x04, 0x8e, 0x07,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0b, 0x05, 0x12, 0x04, 0x8e,
    0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0b, 0x01, 0x12, 0x04,
    0x8e, 0x07, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0b, 0x03, 0x12,
    0x04, 0x8e, 0x07, 0x2d, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0c, 0x12,
    0x04, 0x8f, 0x07, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0c, 0x04,
    0x12, 0x04, 0x8f, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0c,
    0x05, 0x12, 0x04, 0x8f, 0x07, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02,
    0x0c, 0x01, 0x12, 0x04, 0x8f, 0x07, 0x1e, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00,
    0x02, 0x0c, 0x03, 0x12, 0x04, 0x8f, 0x07, 0x29, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x0d, 0x12, 0x04, 0x90, 0x07, 0x10, 0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03,
    0x00, 0x02, 0x0d, 0x04, 0x12, 0x04, 0x90, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b,
    0x03, 0x00, 0x02, 0x0d, 0x05, 0x12, 0x04, 0x90, 0x07, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x5b, 0x03, 0x00, 0x02, 0x0d, 0x01, 0x12, 0x04, 0x90, 0x07, 0x1e, 0x33, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x5b, 0x03, 0x00, 0x02, 0x0d, 0x03, 0x12, 0x04, 0x90, 0x07, 0x36, 0x38, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0e, 0x12, 0x04, 0x91, 0x07, 0x10, 0x4e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0e, 0x04, 0x12, 0x04, 0x91, 0x07, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0e, 0x06, 0x12, 0x04, 0x91, 0x07, 0x19, 0x44, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0e, 0x01, 0x12, 0x04, 0x91, 0x07, 0x45, 0x49,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x5b, 0x03, 0x00, 0x02, 0x0e, 0x03, 0x12, 0x04, 0x91, 0x07, 0x4c,
    0x4d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5b, 0x02, 0x00, 0x12, 0x04, 0x94, 0x07, 0x08, 0x42, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x00, 0x04, 0x12, 0x04, 0x94, 0x07, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5b, 0x02, 0x00, 0x06, 0x12, 0x04, 0x94, 0x07, 0x11, 0x38, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5b, 0x02, 0x00, 0x01, 0x12, 0x04, 0x94, 0x07, 0x39, 0x3d, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5b, 0x02, 0x00, 0x03, 0x12, 0x04, 0x94, 0x07, 0x40, 0x41, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x5b, 0x02, 0x01, 0x12, 0x04, 0x95, 0x07, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02,
    0x01, 0x04, 0x12, 0x04, 0x95, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01,
    0x05, 0x12, 0x04, 0x95, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x95, 0x07, 0x18, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5b, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x95, 0x07, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x5c, 0x12, 0x06, 0x98, 0x07, 0x00,
    0x9a, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5c, 0x01, 0x12, 0x04, 0x98, 0x07, 0x08, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5c, 0x02, 0x00, 0x12, 0x04, 0x99, 0x07, 0x08, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x5c, 0x02, 0x00, 0x04, 0x12, 0x04, 0x99, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5c, 0x02, 0x00, 0x05, 0x12, 0x04, 0x99, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x07, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x5c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x99, 0x07, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x5d,
    0x12, 0x06, 0x9c, 0x07, 0x00, 0x9e, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5d, 0x01, 0x12,
    0x04, 0x9c, 0x07, 0x08, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5d, 0x02, 0x00, 0x12, 0x04, 0x9d,
    0x07, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x04, 0x12, 0x04, 0x9d, 0x07,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x05, 0x12, 0x04, 0x9d, 0x07, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x01, 0x12, 0x04, 0x9d, 0x07, 0x18, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5d, 0x02, 0x00, 0x03, 0x12, 0x04, 0x9d, 0x07, 0x21, 0x22, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x5e, 0x12, 0x06, 0xa0, 0x07, 0x00, 0xa2, 0x07, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x5e, 0x01, 0x12, 0x04, 0xa0, 0x07, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x5e,
    0x02, 0x00, 0x12, 0x04, 0xa1, 0x07, 0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xa1, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xa1, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa1, 0x07, 0x18, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5e, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xa1, 0x07, 0x20, 0x21, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x5f, 0x12, 0x06, 0xa4, 0x07, 0x00, 0xa6,
    0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x5f, 0x01, 0x12, 0x04, 0xa4, 0x07, 0x08, 0x2c, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x5f, 0x02, 0x00, 0x12, 0x04, 0xa5, 0x07, 0x08, 0x23, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x5f, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa5, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x5f, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa5, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x5f, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa5, 0x07, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x5f,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xa5, 0x07, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x60, 0x12,
    0x06, 0xa8, 0x07, 0x00, 0xab, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x60, 0x01, 0x12, 0x04,
    0xa8, 0x07, 0x08, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x60, 0x02, 0x00, 0x12, 0x04, 0xa9, 0x07,
    0x08, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa9, 0x07, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa9, 0x07, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa9, 0x07, 0x18, 0x1d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa9, 0x07, 0x20, 0x21, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x60, 0x02, 0x01, 0x12, 0x04, 0xaa, 0x07, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x60, 0x02, 0x01, 0x04, 0x12, 0x04, 0xaa, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x60, 0x02, 0x01, 0x05, 0x12, 0x04, 0xaa, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xaa, 0x07, 0x16, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x60, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xaa, 0x07, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x61, 0x12, 0x06,
    0xad, 0x07, 0x00, 0xaf, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x61, 0x01, 0x12, 0x04, 0xad,
    0x07, 0x08, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x61, 0x02, 0x00, 0x12, 0x04, 0xae, 0x07, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x61, 0x02, 0x00, 0x04, 0x12, 0x04, 0xae, 0x07, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x61, 0x02, 0x00, 0x05, 0x12, 0x04, 0xae, 0x07, 0x11, 0x17, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x61, 0x02, 0x00, 0x01, 0x12, 0x04, 0xae, 0x07, 0x18, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x61, 0x02, 0x00, 0x03, 0x12, 0x04, 0xae, 0x07, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x62, 0x12, 0x06, 0xb1, 0x07, 0x00, 0xbc, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x62, 0x01, 0x12, 0x04, 0xb1, 0x07, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x00,
    0x12, 0x04, 0xb2, 0x07, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xb2, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00, 0x05, 0x12, 0x04,
    0xb2, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb2,
    0x07, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb2, 0x07,
    0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x01, 0x12, 0x04, 0xb3, 0x07, 0x08, 0x26,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb3, 0x07, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb3, 0x07, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x62, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb3, 0x07, 0x18, 0x21, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x62, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb3, 0x07, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x62, 0x02, 0x02, 0x12, 0x04, 0xb4, 0x07, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xb4, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xb4, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xb4, 0x07, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xb4, 0x07, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x03, 0x12, 0x04,
    0xb5, 0x07, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb5,
    0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb5, 0x07,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb5, 0x07, 0x17,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb5, 0x07, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x04, 0x12, 0x04, 0xb6, 0x07, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x62, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb6, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x62, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb6, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x62, 0x02, 0x04, 0x01, 0x12, 0x04, 0xb6, 0x07, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x62, 0x02, 0x04, 0x03, 0x12, 0x04, 0xb6, 0x07, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62,
    0x02, 0x05, 0x12, 0x04, 0xb7, 0x07, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x05,
    0x04, 0x12, 0x04, 0xb7, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x05, 0x05,
    0x12, 0x04, 0xb7, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x05, 0x01, 0x12,
    0x04, 0xb7, 0x07, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x05, 0x03, 0x12, 0x04,
    0xb7, 0x07, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x06, 0x12, 0x04, 0xb8, 0x07,
    0x08, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb8, 0x07, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x06, 0x05, 0x12, 0x04, 0xb8, 0x07, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb8, 0x07, 0x18, 0x34, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb8, 0x07, 0x37, 0x38, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x62, 0x02, 0x07, 0x12, 0x04, 0xb9, 0x07, 0x08, 0x45, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x62, 0x02, 0x07, 0x04, 0x12, 0x04, 0xb9, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x62, 0x02, 0x07, 0x05, 0x12, 0x04, 0xb9, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62,
    0x02, 0x07, 0x01, 0x12, 0x04, 0xb9, 0x07, 0x18, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02,
    0x07, 0x03, 0x12, 0x04, 0xb9, 0x07, 0x2c, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x07,
    0x08, 0x12, 0x04, 0xb9, 0x07, 0x2e, 0x44, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x07, 0x07,
    0x12, 0x04, 0xb9, 0x07, 0x39, 0x43, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x08, 0x12, 0x04,
    0xba, 0x07, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x08, 0x04, 0x12, 0x04, 0xba,
    0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x08, 0x05, 0x12, 0x04, 0xba, 0x07,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x08, 0x01, 0x12, 0x04, 0xba, 0x07, 0x18,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x62, 0x02, 0x08, 0x03, 0x12, 0x04, 0xba, 0x07, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x62, 0x02, 0x09, 0x12, 0x04, 0xbb, 0x07, 0x08, 0x27, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x62, 0x02, 0x09, 0x04, 0x12, 0x04, 0xbb, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x62, 0x02, 0x09, 0x05, 0x12, 0x04, 0xbb, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x62, 0x02, 0x09, 0x01, 0x12, 0x04, 0xbb, 0x07, 0x16, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x62, 0x02, 0x09, 0x03, 0x12, 0x04, 0xbb, 0x07, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x63,
    0x12, 0x06, 0xbe, 0x07, 0x00, 0xc7, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x63, 0x01, 0x12,
    0x04, 0xbe, 0x07, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x63, 0x02, 0x00, 0x12, 0x04, 0xbf,
    0x07, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbf, 0x07,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbf, 0x07, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x00, 0x01, 0x12, 0x04, 0xbf, 0x07, 0x17, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x00, 0x03, 0x12, 0x04, 0xbf, 0x07, 0x21, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x00, 0x08, 0x12, 0x04, 0xbf, 0x07, 0x23, 0x30, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x63, 0x02, 0x00, 0x07, 0x12, 0x04, 0xbf, 0x07, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x63, 0x02, 0x01, 0x12, 0x04, 0xc0, 0x07, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x63, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc0, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63,
    0x02, 0x01, 0x05, 0x12, 0x04, 0xc0, 0x07, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xc0, 0x07, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xc0, 0x07, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x63, 0x02, 0x02, 0x12,
    0x04, 0xc1, 0x07, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xc1, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc1,
    0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc1, 0x07,
    0x16, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc1, 0x07, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x63, 0x02, 0x03, 0x12, 0x04, 0xc2, 0x07, 0x08, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc2, 0x07, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x63, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc2, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x63, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc2, 0x07, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x63, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc2, 0x07, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x63, 0x02, 0x04, 0x12, 0x04, 0xc3, 0x07, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xc3, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xc3, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x04, 0x01,
    0x12, 0x04, 0xc3, 0x07, 0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x04, 0x03, 0x12,
    0x04, 0xc3, 0x07, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x63, 0x02, 0x05, 0x12, 0x04, 0xc4,
    0x07, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x05, 0x04, 0x12, 0x04, 0xc4, 0x07,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x05, 0x05, 0x12, 0x04, 0xc4, 0x07, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x05, 0x01, 0x12, 0x04, 0xc4, 0x07, 0x17, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x05, 0x03, 0x12, 0x04, 0xc4, 0x07, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x63, 0x02, 0x06, 0x12, 0x04, 0xc5, 0x07, 0x08, 0x24, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x63, 0x02, 0x06, 0x04, 0x12, 0x04, 0xc5, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x63, 0x02, 0x06, 0x05, 0x12, 0x04, 0xc5, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x63, 0x02, 0x06, 0x01, 0x12, 0x04, 0xc5, 0x07, 0x16, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63,
    0x02, 0x06, 0x03, 0x12, 0x04, 0xc5, 0x07, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x63, 0x02,
    0x07, 0x12, 0x04, 0xc6, 0x07, 0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x07, 0x04,
    0x12, 0x04, 0xc6, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x07, 0x05, 0x12,
    0x04, 0xc6, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x07, 0x01, 0x12, 0x04,
    0xc6, 0x07, 0x16, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x63, 0x02, 0x07, 0x03, 0x12, 0x04, 0xc6,
    0x07, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x64, 0x12, 0x06, 0xc9, 0x07, 0x00, 0xd3, 0x07,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x64, 0x01, 0x12, 0x04, 0xc9, 0x07, 0x08, 0x21, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x64, 0x03, 0x00, 0x12, 0x06, 0xca, 0x07, 0x08, 0xd0, 0x07, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x64, 0x03, 0x00, 0x01, 0x12, 0x04, 0xca, 0x07, 0x10, 0x14, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xcb, 0x07, 0x10, 0x39, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcb, 0x07, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcb, 0x07, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcb, 0x07, 0x1f, 0x26,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xcb, 0x07, 0x29,
    0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x08, 0x12, 0x04, 0xcb, 0x07,
    0x2b, 0x38, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x00, 0x07, 0x12, 0x04, 0xcb,
    0x07, 0x36, 0x37, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x64, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xcc,
    0x07, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xcc, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xcc, 0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xcc, 0x07, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xcc, 0x07, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x64, 0x03, 0x00, 0x02,
    0x02, 0x12, 0x04, 0xcd, 0x07, 0x10, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xcd, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xcd, 0x07, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03,
    0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcd, 0x07, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64,
    0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xcd, 0x07, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x64, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xce, 0x07, 0x10, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x64, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xce, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x64, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xce, 0x07, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xce, 0x07, 0x20, 0x28, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xce, 0x07, 0x2b, 0x2c, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x64, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xcf, 0x07, 0x10, 0x2e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xcf, 0x07, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xcf, 0x07, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0xcf, 0x07,
    0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x64, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0xcf,
    0x07, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x64, 0x02, 0x00, 0x12, 0x04, 0xd2, 0x07, 0x08,
    0x3b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x64, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd2, 0x07, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x64, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd2, 0x07, 0x11, 0x30, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x64, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x07, 0x31, 0x36, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x64, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd2, 0x07, 0x39, 0x3a, 0x0a, 0x0c, 0x0a,
    0x02, 0x04, 0x65, 0x12, 0x06, 0xd5, 0x07, 0x00, 0xdd, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04,
    0x65, 0x01, 0x12, 0x04, 0xd5, 0x07, 0x08, 0x29, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x65, 0x03, 0x00,
    0x12, 0x06, 0xd6, 0x07, 0x08, 0xda, 0x07, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x65, 0x03, 0x00,
    0x01, 0x12, 0x04, 0xd6, 0x07, 0x10, 0x14, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x65, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0xd7, 0x07, 0x10, 0x39, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xd7, 0x07, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xd7, 0x07, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd7, 0x07, 0x1f, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65,
    0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd7, 0x07, 0x29, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x65, 0x03, 0x00, 0x02, 0x00, 0x08, 0x12, 0x04, 0xd7, 0x07, 0x2b, 0x38, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x65, 0x03, 0x00, 0x02, 0x00, 0x07, 0x12, 0x04, 0xd7, 0x07, 0x36, 0x37, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x65, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xd8, 0x07, 0x10, 0x2b, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd8, 0x07, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd8, 0x07, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd8, 0x07, 0x20, 0x26,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd8, 0x07, 0x29,
    0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x65, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xd9, 0x07, 0x10,
    0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd9, 0x07,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd9,
    0x07, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04,
    0xd9, 0x07, 0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x65, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xd9, 0x07, 0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x65, 0x02, 0x00, 0x12, 0x04, 0xdc,
    0x07, 0x08, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x65, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x07,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x65, 0x02, 0x00, 0x06, 0x12, 0x04, 0xdc, 0x07, 0x11,
    0x38, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x65, 0x02, 0x00, 0x01, 0x12, 0x04, 0xdc, 0x07, 0x39, 0x3e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x65, 0x02, 0x00, 0x03, 0x12, 0x04, 0xdc, 0x07, 0x41, 0x42, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x66, 0x12, 0x06, 0xdf, 0x07, 0x00, 0xe3, 0x07, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x66, 0x01, 0x12, 0x04, 0xdf, 0x07, 0x08, 0x1e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x66,
    0x02, 0x00, 0x12, 0x04, 0xe0, 0x07, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xe0, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xe0, 0x07, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xe0, 0x07, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xe0, 0x07, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x66, 0x02, 0x01, 0x12, 0x04, 0xe1, 0x07,
    0x08, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe1, 0x07, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe1, 0x07, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe1, 0x07, 0x18, 0x22, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe1, 0x07, 0x25, 0x26, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x66, 0x02, 0x02, 0x12, 0x04, 0xe2, 0x07, 0x08, 0x20, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x66, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe2, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x66, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe2, 0x07, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x07, 0x17, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x66, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xe2, 0x07, 0x1e, 0x1f, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x67, 0x12, 0x06,
    0xe5, 0x07, 0x00, 0xe6, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x67, 0x01, 0x12, 0x04, 0xe5,
    0x07, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x68, 0x12, 0x06, 0xe8, 0x07, 0x00, 0xeb, 0x07,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x68, 0x01, 0x12, 0x04, 0xe8, 0x07, 0x08, 0x27, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x68, 0x02, 0x00, 0x12, 0x04, 0xe9, 0x07, 0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x68, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe9, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x68, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe9, 0x07, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xe9, 0x07, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe9, 0x07, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x00,
    0x08, 0x12, 0x04, 0xe9, 0x07, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x00, 0x07,
    0x12, 0x04, 0xe9, 0x07, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x68, 0x02, 0x01, 0x12, 0x04,
    0xea, 0x07, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01, 0x04, 0x12, 0x04, 0xea,
    0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01, 0x05, 0x12, 0x04, 0xea, 0x07,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01, 0x01, 0x12, 0x04, 0xea, 0x07, 0x17,
    0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x68, 0x02, 0x01, 0x03, 0x12, 0x04, 0xea, 0x07, 0x22, 0x23,
    0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x69, 0x12, 0x06, 0xed, 0x07, 0x00, 0xf1, 0x07, 0x01, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x69, 0x01, 0x12, 0x04, 0xed, 0x07, 0x08, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x69, 0x02, 0x00, 0x12, 0x04, 0xee, 0x07, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xee, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xee, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xee, 0x07, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xee, 0x07, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x69, 0x02, 0x01, 0x12, 0x04, 0xef,
    0x07, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x01, 0x04, 0x12, 0x04, 0xef, 0x07,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x01, 0x05, 0x12, 0x04, 0xef, 0x07, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x01, 0x01, 0x12, 0x04, 0xef, 0x07, 0x18, 0x21,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69, 0x02, 0x01, 0x03, 0x12, 0x04, 0xef, 0x07, 0x24, 0x25, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x69, 0x02, 0x02, 0x12, 0x04, 0xf0, 0x07, 0x08, 0x2d, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x69, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf0, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x69, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf0, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x69, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x07, 0x16, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x69,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xf0, 0x07, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6a, 0x12,
    0x06, 0xf3, 0x07, 0x00, 0xf6, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6a, 0x01, 0x12, 0x04,
    0xf3, 0x07, 0x08, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6a, 0x02, 0x00, 0x12, 0x04, 0xf4, 0x07,
    0x08, 0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf4, 0x07, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf4, 0x07, 0x11, 0x16,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf4, 0x07, 0x17, 0x1e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf4, 0x07, 0x21, 0x22, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6a, 0x02, 0x00, 0x08, 0x12, 0x04, 0xf4, 0x07, 0x23, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6a, 0x02, 0x00, 0x07, 0x12, 0x04, 0xf4, 0x07, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x6a, 0x02, 0x01, 0x12, 0x04, 0xf5, 0x07, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xf5, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xf5, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xf5, 0x07, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6a, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xf5, 0x07, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6b, 0x12, 0x06, 0xf8, 0x07,
    0x00, 0xfb, 0x07, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6b, 0x01, 0x12, 0x04, 0xf8, 0x07, 0x08,
    0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6b, 0x02, 0x00, 0x12, 0x04, 0xf9, 0x07, 0x08, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf9, 0x07, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6b, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf9, 0x07, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6b, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf9, 0x07, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6b, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf9, 0x07, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x6b, 0x02, 0x01, 0x12, 0x04, 0xfa, 0x07, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xfa, 0x07, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xfa, 0x07, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xfa, 0x07, 0x16, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6b, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xfa, 0x07, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6c, 0x12, 0x06, 0xfd, 0x07, 0x00,
    0x8d, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6c, 0x01, 0x12, 0x04, 0xfd, 0x07, 0x08, 0x2e,
    0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6c, 0x07, 0x12, 0x04, 0xfe, 0x07, 0x08, 0x28, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xfe, 0x07, 0x08, 0x28, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xfe, 0x07, 0x0f, 0x23, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xfe, 0x07, 0x0f, 0x23,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfe,
    0x07, 0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x00, 0x04, 0x12, 0x04,
    0xfe, 0x07, 0x26, 0x27, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6c, 0x07, 0x12, 0x04, 0xff, 0x07, 0x08,
    0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x01, 0x12, 0x04, 0xff, 0x07, 0x08,
    0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x04, 0xff, 0x07,
    0x0f, 0x23, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xff, 0x07, 0x0f, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x6c, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xff, 0x07, 0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x07, 0xe7, 0x07,
    0x01, 0x04, 0x12, 0x04, 0xff, 0x07, 0x26, 0x28, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x6c, 0x03, 0x00,
    0x12, 0x06, 0x80, 0x08, 0x08, 0x89, 0x08, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6c, 0x03, 0x00,
    0x01, 0x12, 0x04, 0x80, 0x08, 0x10, 0x14, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0x81, 0x08, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02,
    0x00, 0x04, 0x12, 0x04, 0x81, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00,
    0x02, 0x00, 0x05, 0x12, 0x04, 0x81, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03,
    0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x81, 0x08, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c,
    0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x81, 0x08, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x6c, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x82, 0x08, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x6c, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x82, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x6c, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x82, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x82, 0x08, 0x20, 0x29, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x82, 0x08, 0x2c, 0x2d, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x83, 0x08, 0x10, 0x2c, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x83, 0x08, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x83, 0x08, 0x19,
    0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x83, 0x08,
    0x1f, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x83,
    0x08, 0x2a, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0x84,
    0x08, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04,
    0x84, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12,
    0x04, 0x84, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x03, 0x01,
    0x12, 0x04, 0x84, 0x08, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x03,
    0x03, 0x12, 0x04, 0x84, 0x08, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x02,
    0x04, 0x12, 0x04, 0x85, 0x08, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02,
    0x04, 0x04, 0x12, 0x04, 0x85, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00,
    0x02, 0x04, 0x05, 0x12, 0x04, 0x85, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03,
    0x00, 0x02, 0x04, 0x01, 0x12, 0x04, 0x85, 0x08, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c,
    0x03, 0x00, 0x02, 0x04, 0x03, 0x12, 0x04, 0x85, 0x08, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x6c, 0x03, 0x00, 0x02, 0x05, 0x12, 0x04, 0x86, 0x08, 0x10, 0x35, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x6c, 0x03, 0x00, 0x02, 0x05, 0x04, 0x12, 0x04, 0x86, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x6c, 0x03, 0x00, 0x02, 0x05, 0x05, 0x12, 0x04, 0x86, 0x08, 0x19, 0x1d, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x05, 0x01, 0x12, 0x04, 0x86, 0x08, 0x1e, 0x30, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x05, 0x03, 0x12, 0x04, 0x86, 0x08, 0x33, 0x34, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x06, 0x12, 0x04, 0x87, 0x08, 0x10, 0x36, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0x87, 0x08, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0x87, 0x08, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0x87, 0x08,
    0x20, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0x87,
    0x08, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x07, 0x12, 0x04, 0x88,
    0x08, 0x10, 0x36, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x07, 0x04, 0x12, 0x04,
    0x88, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x07, 0x05, 0x12,
    0x04, 0x88, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x07, 0x01,
    0x12, 0x04, 0x88, 0x08, 0x20, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x6c, 0x03, 0x00, 0x02, 0x07,
    0x03, 0x12, 0x04, 0x88, 0x08, 0x34, 0x35, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6c, 0x02, 0x00, 0x12,
    0x04, 0x8b, 0x08, 0x08, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6c, 0x02, 0x00, 0x04, 0x12, 0x04,
    0x8b, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6c, 0x02, 0x00, 0x06, 0x12, 0x04, 0x8b,
    0x08, 0x11, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6c, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8b, 0x08,
    0x3e, 0x43, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6c, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8b, 0x08, 0x46,
    0x47, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6c, 0x02, 0x01, 0x12, 0x04, 0x8c, 0x08, 0x08, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6c, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8c, 0x08, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6c, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8c, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6c, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8c, 0x08, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6c, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8c, 0x08, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x6d, 0x12, 0x06, 0x8f, 0x08, 0x00, 0x93, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6d, 0x01,
    0x12, 0x04, 0x8f, 0x08, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6d, 0x02, 0x00, 0x12, 0x04,
    0x90, 0x08, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x04, 0x12, 0x04, 0x90,
    0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x05, 0x12, 0x04, 0x90, 0x08,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x01, 0x12, 0x04, 0x90, 0x08, 0x18,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x00, 0x03, 0x12, 0x04, 0x90, 0x08, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6d, 0x02, 0x01, 0x12, 0x04, 0x91, 0x08, 0x08, 0x26, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6d, 0x02, 0x01, 0x04, 0x12, 0x04, 0x91, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6d, 0x02, 0x01, 0x05, 0x12, 0x04, 0x91, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6d, 0x02, 0x01, 0x01, 0x12, 0x04, 0x91, 0x08, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6d, 0x02, 0x01, 0x03, 0x12, 0x04, 0x91, 0x08, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6d,
    0x02, 0x02, 0x12, 0x04, 0x92, 0x08, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02,
    0x04, 0x12, 0x04, 0x92, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x05,
    0x12, 0x04, 0x92, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x01, 0x12,
    0x04, 0x92, 0x08, 0x16, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6d, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x92, 0x08, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x6e, 0x12, 0x06, 0x95, 0x08, 0x00, 0xa3,
    0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x6e, 0x01, 0x12, 0x04, 0x95, 0x08, 0x08, 0x25, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x00, 0x12, 0x04, 0x96, 0x08, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6e, 0x02, 0x00, 0x04, 0x12, 0x04, 0x96, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6e, 0x02, 0x00, 0x05, 0x12, 0x04, 0x96, 0x08, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6e, 0x02, 0x00, 0x01, 0x12, 0x04, 0x96, 0x08, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e,
    0x02, 0x00, 0x03, 0x12, 0x04, 0x96, 0x08, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02,
    0x00, 0x08, 0x12, 0x04, 0x96, 0x08, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x00,
    0x07, 0x12, 0x04, 0x96, 0x08, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x01, 0x12,
    0x04, 0x97, 0x08, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x01, 0x04, 0x12, 0x04,
    0x97, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x01, 0x05, 0x12, 0x04, 0x97,
    0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x01, 0x01, 0x12, 0x04, 0x97, 0x08,
    0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x01, 0x03, 0x12, 0x04, 0x97, 0x08, 0x21,
    0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x02, 0x12, 0x04, 0x98, 0x08, 0x08, 0x26, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x02, 0x04, 0x12, 0x04, 0x98, 0x08, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6e, 0x02, 0x02, 0x05, 0x12, 0x04, 0x98, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6e, 0x02, 0x02, 0x01, 0x12, 0x04, 0x98, 0x08, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6e, 0x02, 0x02, 0x03, 0x12, 0x04, 0x98, 0x08, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x6e, 0x02, 0x03, 0x12, 0x04, 0x99, 0x08, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02,
    0x03, 0x04, 0x12, 0x04, 0x99, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x03,
    0x05, 0x12, 0x04, 0x99, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x03, 0x01,
    0x12, 0x04, 0x99, 0x08, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x03, 0x03, 0x12,
    0x04, 0x99, 0x08, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x04, 0x12, 0x04, 0x9a,
    0x08, 0x08, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x04, 0x04, 0x12, 0x04, 0x9a, 0x08,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x04, 0x05, 0x12, 0x04, 0x9a, 0x08, 0x11,
    0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x04, 0x01, 0x12, 0x04, 0x9a, 0x08, 0x17, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x04, 0x03, 0x12, 0x04, 0x9a, 0x08, 0x22, 0x23, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x05, 0x12, 0x04, 0x9b, 0x08, 0x08, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6e, 0x02, 0x05, 0x04, 0x12, 0x04, 0x9b, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6e, 0x02, 0x05, 0x05, 0x12, 0x04, 0x9b, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6e, 0x02, 0x05, 0x01, 0x12, 0x04, 0x9b, 0x08, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e,
    0x02, 0x05, 0x03, 0x12, 0x04, 0x9b, 0x08, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02,
    0x06, 0x12, 0x04, 0x9c, 0x08, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x06, 0x04,
    0x12, 0x04, 0x9c, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x06, 0x05, 0x12,
    0x04, 0x9c, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x06, 0x01, 0x12, 0x04,
    0x9c, 0x08, 0x16, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x06, 0x03, 0x12, 0x04, 0x9c,
    0x08, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x07, 0x12, 0x04, 0x9d, 0x08, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x07, 0x04, 0x12, 0x04, 0x9d, 0x08, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x07, 0x05, 0x12, 0x04, 0x9d, 0x08, 0x11, 0x15, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x07, 0x01, 0x12, 0x04, 0x9d, 0x08, 0x16, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6e, 0x02, 0x07, 0x03, 0x12, 0x04, 0x9d, 0x08, 0x21, 0x22, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x6e, 0x02, 0x08, 0x12, 0x04, 0x9e, 0x08, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6e, 0x02, 0x08, 0x04, 0x12, 0x04, 0x9e, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e,
    0x02, 0x08, 0x05, 0x12, 0x04, 0x9e, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02,
    0x08, 0x01, 0x12, 0x04, 0x9e, 0x08, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x08,
    0x03, 0x12, 0x04, 0x9e, 0x08, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x09, 0x12,
    0x04, 0x9f, 0x08, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x09, 0x04, 0x12, 0x04,
    0x9f, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x09, 0x05, 0x12, 0x04, 0x9f,
    0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x09, 0x01, 0x12, 0x04, 0x9f, 0x08,
    0x18, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x09, 0x03, 0x12, 0x04, 0x9f, 0x08, 0x23,
    0x25, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x0a, 0x12, 0x04, 0xa0, 0x08, 0x08, 0x27, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0a, 0x04, 0x12, 0x04, 0xa0, 0x08, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0a, 0x05, 0x12, 0x04, 0xa0, 0x08, 0x11, 0x16, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x6e, 0x02, 0x0a, 0x01, 0x12, 0x04, 0xa0, 0x08, 0x17, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6e, 0x02, 0x0a, 0x03, 0x12, 0x04, 0xa0, 0x08, 0x24, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x6e, 0x02, 0x0b, 0x12, 0x04, 0xa1, 0x08, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02,
    0x0b, 0x04, 0x12, 0x04, 0xa1, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0b,
    0x05, 0x12, 0x04, 0xa1, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0b, 0x01,
    0x12, 0x04, 0xa1, 0x08, 0x16, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0b, 0x03, 0x12,
    0x04, 0xa1, 0x08, 0x22, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6e, 0x02, 0x0c, 0x12, 0x04, 0xa2,
    0x08, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0c, 0x04, 0x12, 0x04, 0xa2, 0x08,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0c, 0x05, 0x12, 0x04, 0xa2, 0x08, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0c, 0x01, 0x12, 0x04, 0xa2, 0x08, 0x16, 0x1f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6e, 0x02, 0x0c, 0x03, 0x12, 0x04, 0xa2, 0x08, 0x22, 0x24, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x6f, 0x12, 0x06, 0xa5, 0x08, 0x00, 0xa9, 0x08, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x6f, 0x01, 0x12, 0x04, 0xa5, 0x08, 0x08, 0x21, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6f,
    0x02, 0x00, 0x12, 0x04, 0xa6, 0x08, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xa6, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xa6, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xa6, 0x08, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xa6, 0x08, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x6f, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x08,
    0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa7, 0x08, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x01, 0x05, 0x12, 0x04, 0xa7, 0x08, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa7, 0x08, 0x18, 0x28, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa7, 0x08, 0x2b, 0x2c, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x6f, 0x02, 0x02, 0x12, 0x04, 0xa8, 0x08, 0x08, 0x21, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x6f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xa8, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x6f, 0x02, 0x02, 0x05, 0x12, 0x04, 0xa8, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xa8, 0x08, 0x18, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x6f, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xa8, 0x08, 0x1f, 0x20, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x70, 0x12, 0x06,
    0xab, 0x08, 0x00, 0xad, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x70, 0x01, 0x12, 0x04, 0xab,
    0x08, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x70, 0x02, 0x00, 0x12, 0x04, 0xac, 0x08, 0x08,
    0x31, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x70, 0x02, 0x00, 0x04, 0x12, 0x04, 0xac, 0x08, 0x08, 0x10,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x70, 0x02, 0x00, 0x05, 0x12, 0x04, 0xac, 0x08, 0x11, 0x16, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x70, 0x02, 0x00, 0x01, 0x12, 0x04, 0xac, 0x08, 0x17, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x70, 0x02, 0x00, 0x03, 0x12, 0x04, 0xac, 0x08, 0x21, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x70, 0x02, 0x00, 0x08, 0x12, 0x04, 0xac, 0x08, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x70, 0x02, 0x00, 0x07, 0x12, 0x04, 0xac, 0x08, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x02, 0x04,
    0x71, 0x12, 0x06, 0xaf, 0x08, 0x00, 0xb2, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x71, 0x01,
    0x12, 0x04, 0xaf, 0x08, 0x08, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x71, 0x02, 0x00, 0x12, 0x04,
    0xb0, 0x08, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0,
    0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0, 0x08,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb0, 0x08, 0x18,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x71, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb0, 0x08, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x71, 0x02, 0x01, 0x12, 0x04, 0xb1, 0x08, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x71, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb1, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x71, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb1, 0x08, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x71, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb1, 0x08, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x71, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb1, 0x08, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x72,
    0x12, 0x06, 0xb4, 0x08, 0x00, 0xb8, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x72, 0x01, 0x12,
    0x04, 0xb4, 0x08, 0x08, 0x33, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x72, 0x02, 0x00, 0x12, 0x04, 0xb5,
    0x08, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb5, 0x08,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb5, 0x08, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb5, 0x08, 0x18, 0x1e,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb5, 0x08, 0x21, 0x22, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x72, 0x02, 0x01, 0x12, 0x04, 0xb6, 0x08, 0x08, 0x31, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x72, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb6, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x72, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb6, 0x08, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x72, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb6, 0x08, 0x17, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xb6, 0x08, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02,
    0x01, 0x08, 0x12, 0x04, 0xb6, 0x08, 0x23, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x01,
    0x07, 0x12, 0x04, 0xb6, 0x08, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x72, 0x02, 0x02, 0x12,
    0x04, 0xb7, 0x08, 0x08, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x02, 0x04, 0x12, 0x04,
    0xb7, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb7,
    0x08, 0x11, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb7, 0x08,
    0x25, 0x39, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x72, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb7, 0x08, 0x3c,
    0x3d, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x73, 0x12, 0x06, 0xba, 0x08, 0x00, 0xbf, 0x08, 0x01, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x73, 0x01, 0x12, 0x04, 0xba, 0x08, 0x08, 0x22, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x73, 0x02, 0x00, 0x12, 0x04, 0xbb, 0x08, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xbb, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xbb, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xbb, 0x08, 0x16, 0x20, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xbb, 0x08, 0x23, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73, 0x02, 0x01, 0x12, 0x04,
    0xbc, 0x08, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbc,
    0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbc, 0x08,
    0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbc, 0x08, 0x17,
    0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbc, 0x08, 0x21, 0x22,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73, 0x02, 0x02, 0x12, 0x04, 0xbd, 0x08, 0x08, 0x24, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x73, 0x02, 0x02, 0x04, 0x12, 0x04, 0xbd, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x73, 0x02, 0x02, 0x05, 0x12, 0x04, 0xbd, 0x08, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x73, 0x02, 0x02, 0x01, 0x12, 0x04, 0xbd, 0x08, 0x17, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x73, 0x02, 0x02, 0x03, 0x12, 0x04, 0xbd, 0x08, 0x22, 0x23, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x73,
    0x02, 0x03, 0x12, 0x04, 0xbe, 0x08, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xbe, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xbe, 0x08, 0x11, 0x16, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xbe, 0x08, 0x17, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x73, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xbe, 0x08, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x74, 0x12, 0x06, 0xc1, 0x08, 0x00, 0xc4,
    0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x74, 0x01, 0x12, 0x04, 0xc1, 0x08, 0x08, 0x1f, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x74, 0x02, 0x00, 0x12, 0x04, 0xc2, 0x08, 0x08, 0x2e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x74, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc2, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x74, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc2, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x74, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc2, 0x08, 0x18, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x74,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xc2, 0x08, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x74, 0x02,
    0x01, 0x12, 0x04, 0xc3, 0x08, 0x08, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x74, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xc3, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x74, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xc3, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x74, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xc3, 0x08, 0x16, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x74, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc3,
    0x08, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x75, 0x12, 0x06, 0xc6, 0x08, 0x00, 0xca, 0x08,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x75, 0x01, 0x12, 0x04, 0xc6, 0x08, 0x08, 0x20, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x75, 0x02, 0x00, 0x12, 0x04, 0xc7, 0x08, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x75, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc7, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x75, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc7, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xc7, 0x08, 0x18, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xc7, 0x08, 0x30, 0x31, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x75, 0x02, 0x01,
    0x12, 0x04, 0xc8, 0x08, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x01, 0x04, 0x12,
    0x04, 0xc8, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x01, 0x05, 0x12, 0x04,
    0xc8, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc8,
    0x08, 0x16, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc8, 0x08,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x75, 0x02, 0x02, 0x12, 0x04, 0xc9, 0x08, 0x08, 0x23,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x02, 0x04, 0x12, 0x04, 0xc9, 0x08, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x75, 0x02, 0x02, 0x05, 0x12, 0x04, 0xc9, 0x08, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x75, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc9, 0x08, 0x18, 0x1e, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x75, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc9, 0x08, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02,
    0x04, 0x76, 0x12, 0x06, 0xcc, 0x08, 0x00, 0xd5, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x76,
    0x01, 0x12, 0x04, 0xcc, 0x08, 0x08, 0x20, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x76, 0x03, 0x00, 0x12,
    0x06, 0xcd, 0x08, 0x08, 0xd1, 0x08, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xcd, 0x08, 0x10, 0x13, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x76, 0x03, 0x00, 0x02, 0x00,
    0x12, 0x04, 0xce, 0x08, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xce, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03, 0x00, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xce, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03, 0x00,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xce, 0x08, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03,
    0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xce, 0x08, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x76,
    0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xcf, 0x08, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76,
    0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xcf, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x76, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xcf, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x76, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xcf, 0x08, 0x20, 0x2d, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x76, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xcf, 0x08, 0x30, 0x31, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x76, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xd0, 0x08, 0x10, 0x30, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x76, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd0, 0x08, 0x10, 0x18, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd0, 0x08, 0x19, 0x1f,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd0, 0x08, 0x20,
    0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x76, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd0, 0x08,
    0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x76, 0x02, 0x00, 0x12, 0x04, 0xd3, 0x08, 0x08, 0x38,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd3, 0x08, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x00, 0x06, 0x12, 0x04, 0xd3, 0x08, 0x11, 0x2e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x76, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd3, 0x08, 0x2f, 0x33, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x76, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd3, 0x08, 0x36, 0x37, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x76, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x08, 0x08, 0x3d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xd4, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xd4, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xd4, 0x08, 0x16, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xd4, 0x08, 0x29, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x01, 0x08, 0x12,
    0x04, 0xd4, 0x08, 0x2b, 0x3c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x76, 0x02, 0x01, 0x07, 0x12, 0x04,
    0xd4, 0x08, 0x36, 0x3b, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x77, 0x12, 0x06, 0xd7, 0x08, 0x00, 0xe8,
    0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x77, 0x01, 0x12, 0x04, 0xd7, 0x08, 0x08, 0x21, 0x0a,
    0x0b, 0x0a, 0x03, 0x04, 0x77, 0x07, 0x12, 0x04, 0xd8, 0x08, 0x08, 0x28, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x77, 0x07, 0xe7, 0x07, 0x00, 0x12, 0x04, 0xd8, 0x08, 0x08, 0x28, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x77, 0x07, 0xe7, 0x07, 0x00, 0x02, 0x12, 0x04, 0xd8, 0x08, 0x0f, 0x23, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd8, 0x08, 0x0f, 0x23, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd8, 0x08,
    0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x00, 0x04, 0x12, 0x04, 0xd8,
    0x08, 0x26, 0x27, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x77, 0x07, 0x12, 0x04, 0xd9, 0x08, 0x08, 0x28,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x01, 0x12, 0x04, 0xd9, 0x08, 0x08, 0x28,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x04, 0xd9, 0x08, 0x0f,
    0x23, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x04, 0xd9,
    0x08, 0x0f, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01,
    0x12, 0x04, 0xd9, 0x08, 0x10, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x07, 0xe7, 0x07, 0x01,
    0x04, 0x12, 0x04, 0xd9, 0x08, 0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x77, 0x03, 0x00, 0x12,
    0x06, 0xda, 0x08, 0x08, 0xe3, 0x08, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x03, 0x00, 0x01,
    0x12, 0x04, 0xda, 0x08, 0x10, 0x13, 0x0a, 0x10, 0x0a, 0x06, 0x04, 0x77, 0x03, 0x00, 0x03, 0x00,
    0x12, 0x06, 0xdb, 0x08, 0x10, 0xde, 0x08, 0x11, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00,
    0x03, 0x00, 0x01, 0x12, 0x04, 0xdb, 0x08, 0x18, 0x1f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x77, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xdc, 0x08, 0x18, 0x37, 0x0a, 0x11, 0x0a, 0x09, 0x04,
    0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x08, 0x18, 0x20, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xdc, 0x08, 0x21,
    0x27, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xdc, 0x08, 0x28, 0x32, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xdc, 0x08, 0x35, 0x36, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x77, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xdd, 0x08, 0x18, 0x36, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x77, 0x03,
    0x00, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdd, 0x08, 0x18, 0x20, 0x0a, 0x11, 0x0a, 0x09,
    0x04, 0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdd, 0x08, 0x21, 0x26, 0x0a,
    0x11, 0x0a, 0x09, 0x04, 0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdd, 0x08,
    0x27, 0x31, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x77, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xdd, 0x08, 0x34, 0x35, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x77, 0x03, 0x00, 0x02, 0x00, 0x12,
    0x04, 0xe0, 0x08, 0x10, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00, 0x02, 0x00, 0x04,
    0x12, 0x04, 0xe0, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xe0, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe0, 0x08, 0x20, 0x26, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xe0, 0x08, 0x29, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x77, 0x03,
    0x00, 0x02, 0x01, 0x12, 0x04, 0xe1, 0x08, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe1, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe1, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x77, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe1, 0x08, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x77, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe1, 0x08, 0x30, 0x31, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x77, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xe2, 0x08, 0x10, 0x4d, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x77, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe2, 0x08, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x77, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xe2, 0x08, 0x19, 0x3f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x08, 0x40, 0x48,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x77, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe2, 0x08, 0x4b,
    0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x77, 0x02, 0x00, 0x12, 0x04, 0xe5, 0x08, 0x08, 0x39, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe5, 0x08, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x77, 0x02, 0x00, 0x06, 0x12, 0x04, 0xe5, 0x08, 0x11, 0x2f, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x77, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe5, 0x08, 0x30, 0x34, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x77, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe5, 0x08, 0x37, 0x38, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x77, 0x02, 0x01, 0x12, 0x04, 0xe6, 0x08, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xe6, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xe6, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xe6, 0x08, 0x18, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xe6, 0x08, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x77, 0x02, 0x02, 0x12, 0x04, 0xe7,
    0x08, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe7, 0x08,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe7, 0x08, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe7, 0x08, 0x18, 0x24,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x77, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe7, 0x08, 0x27, 0x28, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x78, 0x12, 0x06, 0xea, 0x08, 0x00, 0xed, 0x08, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x78, 0x01, 0x12, 0x04, 0xea, 0x08, 0x08, 0x24, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x78,
    0x02, 0x00, 0x12, 0x04, 0xeb, 0x08, 0x08, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xeb, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xeb, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x00, 0x01, 0x12,
    0x04, 0xeb, 0x08, 0x18, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xeb, 0x08, 0x26, 0x27, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x78, 0x02, 0x01, 0x12, 0x04, 0xec, 0x08,
    0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x01, 0x04, 0x12, 0x04, 0xec, 0x08, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x01, 0x05, 0x12, 0x04, 0xec, 0x08, 0x11, 0x15,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x01, 0x01, 0x12, 0x04, 0xec, 0x08, 0x16, 0x24, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x78, 0x02, 0x01, 0x03, 0x12, 0x04, 0xec, 0x08, 0x27, 0x28, 0x0a, 0x0c,
    0x0a, 0x02, 0x04, 0x79, 0x12, 0x06, 0xef, 0x08, 0x00, 0xfa, 0x08, 0x01, 0x0a, 0x0b, 0x0a, 0x03,
    0x04, 0x79, 0x01, 0x12, 0x04, 0xef, 0x08, 0x08, 0x25, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x79, 0x03,
    0x00, 0x12, 0x06, 0xf0, 0x08, 0x08, 0xf5, 0x08, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x03,
    0x00, 0x01, 0x12, 0x04, 0xf0, 0x08, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x79, 0x03, 0x00,
    0x02, 0x00, 0x12, 0x04, 0xf1, 0x08, 0x10, 0x2f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xf1, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03,
    0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf1, 0x08, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79,
    0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf1, 0x08, 0x20, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x79, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf1, 0x08, 0x2d, 0x2e, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x79, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xf2, 0x08, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x79, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf2, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf2, 0x08, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf2, 0x08, 0x20, 0x2d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf2, 0x08, 0x30, 0x31,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x79, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xf3, 0x08, 0x10, 0x27,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf3, 0x08, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf3, 0x08,
    0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf3,
    0x08, 0x1f, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04,
    0xf3, 0x08, 0x25, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x79, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04,
    0xf4, 0x08, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12,
    0x04, 0xf4, 0x08, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xf4, 0x08, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xf4, 0x08, 0x1f, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x79, 0x03, 0x00, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xf4, 0x08, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x79, 0x02, 0x00,
    0x12, 0x04, 0xf7, 0x08, 0x08, 0x45, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xf7, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xf7, 0x08, 0x11, 0x37, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf7,
    0x08, 0x38, 0x40, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf7, 0x08,
    0x43, 0x44, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x79, 0x02, 0x01, 0x12, 0x04, 0xf8, 0x08, 0x08, 0x2d,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf8, 0x08, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf8, 0x08, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x79, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf8, 0x08, 0x18, 0x28, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x79, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf8, 0x08, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x79, 0x02, 0x02, 0x12, 0x04, 0xf9, 0x08, 0x08, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xf9, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02,
    0x02, 0x05, 0x12, 0x04, 0xf9, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xf9, 0x08, 0x18, 0x28, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x79, 0x02, 0x02, 0x03,
    0x12, 0x04, 0xf9, 0x08, 0x2b, 0x2c, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7a, 0x12, 0x06, 0xfc, 0x08,
    0x00, 0x82, 0x09, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7a, 0x01, 0x12, 0x04, 0xfc, 0x08, 0x08,
    0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7a, 0x02, 0x00, 0x12, 0x04, 0xfd, 0x08, 0x08, 0x30, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x00, 0x04, 0x12, 0x04, 0xfd, 0x08, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7a, 0x02, 0x00, 0x05, 0x12, 0x04, 0xfd, 0x08, 0x11, 0x17, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7a, 0x02, 0x00, 0x01, 0x12, 0x04, 0xfd, 0x08, 0x18, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7a, 0x02, 0x00, 0x03, 0x12, 0x04, 0xfd, 0x08, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x7a, 0x02, 0x01, 0x12, 0x04, 0xfe, 0x08, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xfe, 0x08, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xfe, 0x08, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xfe, 0x08, 0x16, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xfe, 0x08, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7a, 0x02, 0x02, 0x12, 0x04, 0xff,
    0x08, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x02, 0x04, 0x12, 0x04, 0xff, 0x08,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x02, 0x05, 0x12, 0x04, 0xff, 0x08, 0x11,
    0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x02, 0x01, 0x12, 0x04, 0xff, 0x08, 0x16, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x02, 0x03, 0x12, 0x04, 0xff, 0x08, 0x32, 0x33, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x7a, 0x02, 0x03, 0x12, 0x04, 0x80, 0x09, 0x08, 0x30, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7a, 0x02, 0x03, 0x04, 0x12, 0x04, 0x80, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7a, 0x02, 0x03, 0x05, 0x12, 0x04, 0x80, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7a, 0x02, 0x03, 0x01, 0x12, 0x04, 0x80, 0x09, 0x18, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a,
    0x02, 0x03, 0x03, 0x12, 0x04, 0x80, 0x09, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7a, 0x02,
    0x04, 0x12, 0x04, 0x81, 0x09, 0x08, 0x34, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x04, 0x04,
    0x12, 0x04, 0x81, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x04, 0x05, 0x12,
    0x04, 0x81, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x04, 0x01, 0x12, 0x04,
    0x81, 0x09, 0x18, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7a, 0x02, 0x04, 0x03, 0x12, 0x04, 0x81,
    0x09, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7b, 0x12, 0x06, 0x84, 0x09, 0x00, 0x98, 0x09,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7b, 0x01, 0x12, 0x04, 0x84, 0x09, 0x08, 0x2a, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x7b, 0x03, 0x00, 0x12, 0x06, 0x85, 0x09, 0x08, 0x89, 0x09, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7b, 0x03, 0x00, 0x01, 0x12, 0x04, 0x85, 0x09, 0x10, 0x1d, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0x86, 0x09, 0x10, 0x2e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0x86, 0x09, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0x86, 0x09, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0x86, 0x09, 0x20, 0x29,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0x86, 0x09, 0x2c,
    0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0x87, 0x09, 0x10,
    0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0x87, 0x09,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x87,
    0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0x87, 0x09, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0x87, 0x09, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x02, 0x12,
    0x04, 0x88, 0x09, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x02, 0x04,
    0x12, 0x04, 0x88, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02, 0x02,
    0x05, 0x12, 0x04, 0x88, 0x09, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x88, 0x09, 0x1e, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x00,
    0x02, 0x02, 0x03, 0x12, 0x04, 0x88, 0x09, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x7b, 0x03,
    0x01, 0x12, 0x06, 0x8b, 0x09, 0x08, 0x8f, 0x09, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x03,
    0x01, 0x01, 0x12, 0x04, 0x8b, 0x09, 0x10, 0x19, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7b, 0x03, 0x01,
    0x02, 0x00, 0x12, 0x04, 0x8c, 0x09, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01,
    0x02, 0x00, 0x04, 0x12, 0x04, 0x8c, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03,
    0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x8c, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b,
    0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x8c, 0x09, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7b, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x8c, 0x09, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x7b, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0x8d, 0x09, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x7b, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0x8d, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0x8d, 0x09, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x8d, 0x09, 0x20, 0x2d, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x8d, 0x09, 0x30, 0x31,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0x8e, 0x09, 0x10, 0x2e,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0x8e, 0x09, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0x8e, 0x09,
    0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0x8e,
    0x09, 0x1e, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7b, 0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04,
    0x8e, 0x09, 0x2c, 0x2d, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7b, 0x02, 0x00, 0x12, 0x04, 0x91, 0x09,
    0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x00, 0x04, 0x12, 0x04, 0x91, 0x09, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x00, 0x05, 0x12, 0x04, 0x91, 0x09, 0x11, 0x17,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x00, 0x01, 0x12, 0x04, 0x91, 0x09, 0x18, 0x2d, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x00, 0x03, 0x12, 0x04, 0x91, 0x09, 0x30, 0x31, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x7b, 0x02, 0x01, 0x12, 0x04, 0x92, 0x09, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7b, 0x02, 0x01, 0x04, 0x12, 0x04, 0x92, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7b, 0x02, 0x01, 0x05, 0x12, 0x04, 0x92, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x92, 0x09, 0x18, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02,
    0x01, 0x03, 0x12, 0x04, 0x92, 0x09, 0x2e, 0x2f, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7b, 0x02, 0x02,
    0x12, 0x04, 0x93, 0x09, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x02, 0x04, 0x12,
    0x04, 0x93, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x02, 0x05, 0x12, 0x04,
    0x93, 0x09, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x02, 0x01, 0x12, 0x04, 0x93,
    0x09, 0x16, 0x27, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x02, 0x03, 0x12, 0x04, 0x93, 0x09,
    0x2a, 0x2b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7b, 0x02, 0x03, 0x12, 0x04, 0x94, 0x09, 0x08, 0x57,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x03, 0x04, 0x12, 0x04, 0x94, 0x09, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x03, 0x06, 0x12, 0x04, 0x94, 0x09, 0x11, 0x42, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7b, 0x02, 0x03, 0x01, 0x12, 0x04, 0x94, 0x09, 0x43, 0x52, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7b, 0x02, 0x03, 0x03, 0x12, 0x04, 0x94, 0x09, 0x55, 0x56, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x7b, 0x02, 0x04, 0x12, 0x04, 0x95, 0x09, 0x08, 0x4f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b,
    0x02, 0x04, 0x04, 0x12, 0x04, 0x95, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02,
    0x04, 0x06, 0x12, 0x04, 0x95, 0x09, 0x11, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x04,
    0x01, 0x12, 0x04, 0x95, 0x09, 0x3f, 0x4a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x04, 0x03,
    0x12, 0x04, 0x95, 0x09, 0x4d, 0x4e, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7b, 0x02, 0x05, 0x12, 0x04,
    0x96, 0x09, 0x08, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x05, 0x04, 0x12, 0x04, 0x96,
    0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x05, 0x05, 0x12, 0x04, 0x96, 0x09,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x05, 0x01, 0x12, 0x04, 0x96, 0x09, 0x16,
    0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7b, 0x02, 0x05, 0x03, 0x12, 0x04, 0x96, 0x09, 0x2e, 0x2f,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7b, 0x02, 0x06, 0x12, 0x04, 0x97, 0x09, 0x08, 0x34, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7b, 0x02, 0x06, 0x04, 0x12, 0x04, 0x97, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7b, 0x02, 0x06, 0x05, 0x12, 0x04, 0x97, 0x09, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7b, 0x02, 0x06, 0x01, 0x12, 0x04, 0x97, 0x09, 0x16, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7b, 0x02, 0x06, 0x03, 0x12, 0x04, 0x97, 0x09, 0x32, 0x33, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7c,
    0x12, 0x06, 0x9a, 0x09, 0x00, 0xaa, 0x09, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7c, 0x01, 0x12,
    0x04, 0x9a, 0x09, 0x08, 0x28, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x7c, 0x03, 0x00, 0x12, 0x06, 0x9b,
    0x09, 0x08, 0x9f, 0x09, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x03, 0x00, 0x01, 0x12, 0x04,
    0x9b, 0x09, 0x10, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04,
    0x9c, 0x09, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12,
    0x04, 0x9c, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x00, 0x05,
    0x12, 0x04, 0x9c, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x9c, 0x09, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00, 0x02,
    0x00, 0x03, 0x12, 0x04, 0x9c, 0x09, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7c, 0x03, 0x00,
    0x02, 0x01, 0x12, 0x04, 0x9d, 0x09, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x9d, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03,
    0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0x9d, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c,
    0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0x9d, 0x09, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7c, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0x9d, 0x09, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x7c, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0x9e, 0x09, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x7c, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0x9e, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0x9e, 0x09, 0x19, 0x1d, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0x9e, 0x09, 0x1e, 0x29, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0x9e, 0x09, 0x2c, 0x2d,
    0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x7c, 0x03, 0x01, 0x12, 0x06, 0xa1, 0x09, 0x08, 0xa4, 0x09, 0x09,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x03, 0x01, 0x01, 0x12, 0x04, 0xa1, 0x09, 0x10, 0x1b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xa2, 0x09, 0x10, 0x2e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa2, 0x09, 0x10, 0x18,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa2, 0x09, 0x19,
    0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa2, 0x09,
    0x20, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa2,
    0x09, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xa3,
    0x09, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04,
    0xa3, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xa3, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xa3, 0x09, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7c, 0x03, 0x01, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xa3, 0x09, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7c, 0x02, 0x00, 0x12,
    0x04, 0xa6, 0x09, 0x08, 0x4c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xa6, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x00, 0x06, 0x12, 0x04, 0xa6,
    0x09, 0x11, 0x3e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa6, 0x09,
    0x3f, 0x47, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa6, 0x09, 0x4a,
    0x4b, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7c, 0x02, 0x01, 0x12, 0x04, 0xa7, 0x09, 0x08, 0x44, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa7, 0x09, 0x08, 0x10, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7c, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa7, 0x09, 0x11, 0x3a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7c, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa7, 0x09, 0x3b, 0x3f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7c, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa7, 0x09, 0x42, 0x43, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x7c, 0x02, 0x02, 0x12, 0x04, 0xa8, 0x09, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02,
    0x02, 0x04, 0x12, 0x04, 0xa8, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xa8, 0x09, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x02, 0x01,
    0x12, 0x04, 0xa8, 0x09, 0x16, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xa8, 0x09, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7c, 0x02, 0x03, 0x12, 0x04, 0xa9,
    0x09, 0x08, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x03, 0x04, 0x12, 0x04, 0xa9, 0x09,
    0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x03, 0x05, 0x12, 0x04, 0xa9, 0x09, 0x11,
    0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x03, 0x01, 0x12, 0x04, 0xa9, 0x09, 0x18, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7c, 0x02, 0x03, 0x03, 0x12, 0x04, 0xa9, 0x09, 0x2a, 0x2b, 0x0a,
    0x0c, 0x0a, 0x02, 0x04, 0x7d, 0x12, 0x06, 0xac, 0x09, 0x00, 0xca, 0x09, 0x01, 0x0a, 0x0b, 0x0a,
    0x03, 0x04, 0x7d, 0x01, 0x12, 0x04, 0xac, 0x09, 0x08, 0x29, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7d,
    0x07, 0x12, 0x04, 0xad, 0x09, 0x08, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x07, 0xe7, 0x07,
    0x00, 0x12, 0x04, 0xad, 0x09, 0x08, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x07, 0xe7, 0x07,
    0x00, 0x02, 0x12, 0x04, 0xad, 0x09, 0x0f, 0x23, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x7d, 0x07, 0xe7,
    0x07, 0x00, 0x02, 0x00, 0x12, 0x04, 0xad, 0x09, 0x0f, 0x23, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x7d,
    0x07, 0xe7, 0x07, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xad, 0x09, 0x10, 0x22, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7d, 0x07, 0xe7, 0x07, 0x00, 0x04, 0x12, 0x04, 0xad, 0x09, 0x26, 0x27, 0x0a, 0x0b,
    0x0a, 0x03, 0x04, 0x7d, 0x07, 0x12, 0x04, 0xae, 0x09, 0x08, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x7d, 0x07, 0xe7, 0x07, 0x01, 0x12, 0x04, 0xae, 0x09, 0x08, 0x28, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7d, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x12, 0x04, 0xae, 0x09, 0x0f, 0x23, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x7d, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x12, 0x04, 0xae, 0x09, 0x0f, 0x23, 0x0a, 0x11,
    0x0a, 0x09, 0x04, 0x7d, 0x07, 0xe7, 0x07, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xae, 0x09, 0x10,
    0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x07, 0xe7, 0x07, 0x01, 0x04, 0x12, 0x04, 0xae, 0x09,
    0x26, 0x27, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x7d, 0x03, 0x00, 0x12, 0x06, 0xaf, 0x09, 0x08, 0xb7,
    0x09, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x03, 0x00, 0x01, 0x12, 0x04, 0xaf, 0x09, 0x10,
    0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xb0, 0x09, 0x10,
    0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb0, 0x09,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb0,
    0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xb0, 0x09, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12,
    0x04, 0xb0, 0x09, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x01, 0x12,
    0x04, 0xb1, 0x09, 0x10, 0x32, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xb1, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xb1, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xb1, 0x09, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00,
    0x02, 0x01, 0x03, 0x12, 0x04, 0xb1, 0x09, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03,
    0x00, 0x02, 0x02, 0x12, 0x04, 0xb2, 0x09, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03,
    0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb2, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d,
    0x03, 0x00, 0x02, 0x02, 0x05, 0x12, 0x04, 0xb2, 0x09, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7d, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb2, 0x09, 0x1e, 0x2b, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x7d, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12, 0x04, 0xb2, 0x09, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x03, 0x12, 0x04, 0xb3, 0x09, 0x10, 0x27, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x03, 0x04, 0x12, 0x04, 0xb3, 0x09, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x03, 0x05, 0x12, 0x04, 0xb3, 0x09, 0x19, 0x1e, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x03, 0x01, 0x12, 0x04, 0xb3, 0x09, 0x1f, 0x22,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x03, 0x03, 0x12, 0x04, 0xb3, 0x09, 0x25,
    0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x04, 0x12, 0x04, 0xb4, 0x09, 0x10,
    0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x04, 0x04, 0x12, 0x04, 0xb4, 0x09,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x04, 0x05, 0x12, 0x04, 0xb4,
    0x09, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x04, 0x01, 0x12, 0x04,
    0xb4, 0x09, 0x1f, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x04, 0x03, 0x12,
    0x04, 0xb4, 0x09, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x05, 0x12,
    0x04, 0xb5, 0x09, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x05, 0x04,
    0x12, 0x04, 0xb5, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02, 0x05,
    0x05, 0x12, 0x04, 0xb5, 0x09, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00, 0x02,
    0x05, 0x01, 0x12, 0x04, 0xb5, 0x09, 0x1e, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x00,
    0x02, 0x05, 0x03, 0x12, 0x04, 0xb5, 0x09, 0x2c, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03,
    0x00, 0x02, 0x06, 0x12, 0x04, 0xb6, 0x09, 0x10, 0x29, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03,
    0x00, 0x02, 0x06, 0x04, 0x12, 0x04, 0xb6, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d,
    0x03, 0x00, 0x02, 0x06, 0x05, 0x12, 0x04, 0xb6, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7d, 0x03, 0x00, 0x02, 0x06, 0x01, 0x12, 0x04, 0xb6, 0x09, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x7d, 0x03, 0x00, 0x02, 0x06, 0x03, 0x12, 0x04, 0xb6, 0x09, 0x27, 0x28, 0x0a, 0x0e, 0x0a,
    0x04, 0x04, 0x7d, 0x03, 0x01, 0x12, 0x06, 0xb9, 0x09, 0x08, 0xc0, 0x09, 0x09, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7d, 0x03, 0x01, 0x01, 0x12, 0x04, 0xb9, 0x09, 0x10, 0x1b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x7d, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xba, 0x09, 0x10, 0x2e, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x7d, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xba, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xba, 0x09, 0x19, 0x1f, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xba, 0x09, 0x20, 0x29, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xba, 0x09, 0x2c, 0x2d,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xbb, 0x09, 0x10, 0x32,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xbb, 0x09, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbb, 0x09,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbb,
    0x09, 0x20, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04,
    0xbb, 0x09, 0x30, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04,
    0xbc, 0x09, 0x10, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xbc, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x02, 0x05,
    0x12, 0x04, 0xbc, 0x09, 0x19, 0x1d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x02,
    0x01, 0x12, 0x04, 0xbc, 0x09, 0x1e, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02,
    0x02, 0x03, 0x12, 0x04, 0xbc, 0x09, 0x2e, 0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x01,
    0x02, 0x03, 0x12, 0x04, 0xbd, 0x09, 0x10, 0x27, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xbd, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03,
    0x01, 0x02, 0x03, 0x05, 0x12, 0x04, 0xbd, 0x09, 0x19, 0x1e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d,
    0x03, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xbd, 0x09, 0x1f, 0x22, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7d, 0x03, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04, 0xbd, 0x09, 0x25, 0x26, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x7d, 0x03, 0x01, 0x02, 0x04, 0x12, 0x04, 0xbe, 0x09, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x7d, 0x03, 0x01, 0x02, 0x04, 0x04, 0x12, 0x04, 0xbe, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x04, 0x05, 0x12, 0x04, 0xbe, 0x09, 0x19, 0x1e, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xbe, 0x09, 0x1f, 0x25, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x04, 0x03, 0x12, 0x04, 0xbe, 0x09, 0x28, 0x29,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x05, 0x12, 0x04, 0xbf, 0x09, 0x10, 0x29,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x05, 0x04, 0x12, 0x04, 0xbf, 0x09, 0x10,
    0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x05, 0x05, 0x12, 0x04, 0xbf, 0x09,
    0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xbf,
    0x09, 0x20, 0x24, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7d, 0x03, 0x01, 0x02, 0x05, 0x03, 0x12, 0x04,
    0xbf, 0x09, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7d, 0x02, 0x00, 0x12, 0x04, 0xc2, 0x09,
    0x08, 0x45, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc2, 0x09, 0x08,
    0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x00, 0x06, 0x12, 0x04, 0xc2, 0x09, 0x11, 0x3b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc2, 0x09, 0x3c, 0x40, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc2, 0x09, 0x43, 0x44, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x7d, 0x02, 0x01, 0x12, 0x04, 0xc3, 0x09, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7d, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc3, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7d, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc3, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d,
    0x02, 0x01, 0x01, 0x12, 0x04, 0xc3, 0x09, 0x18, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xc3, 0x09, 0x29, 0x2a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7d, 0x02, 0x02,
    0x12, 0x04, 0xc4, 0x09, 0x08, 0x4d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xc4, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x02, 0x06, 0x12, 0x04,
    0xc4, 0x09, 0x11, 0x3f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x02, 0x01, 0x12, 0x04, 0xc4,
    0x09, 0x40, 0x48, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc4, 0x09,
    0x4b, 0x4c, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7d, 0x02, 0x03, 0x12, 0x04, 0xc5, 0x09, 0x08, 0x2f,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc5, 0x09, 0x08, 0x10, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc5, 0x09, 0x11, 0x17, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7d, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc5, 0x09, 0x18, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7d, 0x02, 0x03, 0x03, 0x12, 0x04, 0xc5, 0x09, 0x2d, 0x2e, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x7d, 0x02, 0x04, 0x12, 0x04, 0xc6, 0x09, 0x08, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d,
    0x02, 0x04, 0x04, 0x12, 0x04, 0xc6, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02,
    0x04, 0x05, 0x12, 0x04, 0xc6, 0x09, 0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x04,
    0x01, 0x12, 0x04, 0xc6, 0x09, 0x16, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x04, 0x03,
    0x12, 0x04, 0xc6, 0x09, 0x27, 0x28, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7d, 0x02, 0x05, 0x12, 0x04,
    0xc7, 0x09, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x05, 0x04, 0x12, 0x04, 0xc7,
    0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x05, 0x05, 0x12, 0x04, 0xc7, 0x09,
    0x11, 0x15, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x05, 0x01, 0x12, 0x04, 0xc7, 0x09, 0x16,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x05, 0x03, 0x12, 0x04, 0xc7, 0x09, 0x29, 0x2a,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7d, 0x02, 0x06, 0x12, 0x04, 0xc8, 0x09, 0x08, 0x2a, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7d, 0x02, 0x06, 0x04, 0x12, 0x04, 0xc8, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7d, 0x02, 0x06, 0x05, 0x12, 0x04, 0xc8, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7d, 0x02, 0x06, 0x01, 0x12, 0x04, 0xc8, 0x09, 0x18, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7d, 0x02, 0x06, 0x03, 0x12, 0x04, 0xc8, 0x09, 0x28, 0x29, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7d,
    0x02, 0x07, 0x12, 0x04, 0xc9, 0x09, 0x08, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x07,
    0x04, 0x12, 0x04, 0xc9, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x07, 0x05,
    0x12, 0x04, 0xc9, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x07, 0x01, 0x12,
    0x04, 0xc9, 0x09, 0x18, 0x21, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7d, 0x02, 0x07, 0x03, 0x12, 0x04,
    0xc9, 0x09, 0x24, 0x25, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7e, 0x12, 0x06, 0xcc, 0x09, 0x00, 0xcf,
    0x09, 0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7e, 0x01, 0x12, 0x04, 0xcc, 0x09, 0x08, 0x28, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x7e, 0x02, 0x00, 0x12, 0x04, 0xcd, 0x09, 0x08, 0x27, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7e, 0x02, 0x00, 0x04, 0x12, 0x04, 0xcd, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7e, 0x02, 0x00, 0x05, 0x12, 0x04, 0xcd, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7e, 0x02, 0x00, 0x01, 0x12, 0x04, 0xcd, 0x09, 0x18, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xcd, 0x09, 0x25, 0x26, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7e, 0x02,
    0x01, 0x12, 0x04, 0xce, 0x09, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xce, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x01, 0x05, 0x12,
    0x04, 0xce, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xce, 0x09, 0x18, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7e, 0x02, 0x01, 0x03, 0x12, 0x04, 0xce,
    0x09, 0x21, 0x22, 0x0a, 0x0c, 0x0a, 0x02, 0x04, 0x7f, 0x12, 0x06, 0xd1, 0x09, 0x00, 0xe0, 0x09,
    0x01, 0x0a, 0x0b, 0x0a, 0x03, 0x04, 0x7f, 0x01, 0x12, 0x04, 0xd1, 0x09, 0x08, 0x29, 0x0a, 0x0e,
    0x0a, 0x04, 0x04, 0x7f, 0x03, 0x00, 0x12, 0x06, 0xd2, 0x09, 0x08, 0xd5, 0x09, 0x09, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7f, 0x03, 0x00, 0x01, 0x12, 0x04, 0xd2, 0x09, 0x10, 0x1c, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xd3, 0x09, 0x10, 0x2e, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd3, 0x09, 0x10, 0x18, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd3, 0x09, 0x19, 0x1f, 0x0a,
    0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd3, 0x09, 0x20, 0x29,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd3, 0x09, 0x2c,
    0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04, 0xd4, 0x09, 0x10,
    0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd4, 0x09,
    0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd4,
    0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04,
    0xd4, 0x09, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12,
    0x04, 0xd4, 0x09, 0x2f, 0x30, 0x0a, 0x0e, 0x0a, 0x04, 0x04, 0x7f, 0x03, 0x01, 0x12, 0x06, 0xd7,
    0x09, 0x08, 0xda, 0x09, 0x09, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x03, 0x01, 0x01, 0x12, 0x04,
    0xd7, 0x09, 0x10, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7f, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xd8, 0x09, 0x10, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12,
    0x04, 0xd8, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x01, 0x02, 0x00, 0x05,
    0x12, 0x04, 0xd8, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xd8, 0x09, 0x20, 0x25, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x01, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xd8, 0x09, 0x28, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x7f, 0x03, 0x01,
    0x02, 0x01, 0x12, 0x04, 0xd9, 0x09, 0x10, 0x31, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xd9, 0x09, 0x10, 0x18, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f, 0x03,
    0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd9, 0x09, 0x19, 0x1f, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x7f,
    0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd9, 0x09, 0x20, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x7f, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd9, 0x09, 0x2f, 0x30, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x7f, 0x02, 0x00, 0x12, 0x04, 0xdc, 0x09, 0x08, 0x5b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xdc, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02,
    0x00, 0x06, 0x12, 0x04, 0xdc, 0x09, 0x11, 0x40, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xdc, 0x09, 0x41, 0x56, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xdc, 0x09, 0x59, 0x5a, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7f, 0x02, 0x01, 0x12, 0x04,
    0xdd, 0x09, 0x08, 0x32, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x04, 0x12, 0x04, 0xdd,
    0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x05, 0x12, 0x04, 0xdd, 0x09,
    0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x01, 0x12, 0x04, 0xdd, 0x09, 0x18,
    0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x01, 0x03, 0x12, 0x04, 0xdd, 0x09, 0x30, 0x31,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7f, 0x02, 0x02, 0x12, 0x04, 0xde, 0x09, 0x08, 0x53, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x7f, 0x02, 0x02, 0x04, 0x12, 0x04, 0xde, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x7f, 0x02, 0x02, 0x06, 0x12, 0x04, 0xde, 0x09, 0x11, 0x3c, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x7f, 0x02, 0x02, 0x01, 0x12, 0x04, 0xde, 0x09, 0x3d, 0x4e, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x7f, 0x02, 0x02, 0x03, 0x12, 0x04, 0xde, 0x09, 0x51, 0x52, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x7f,
    0x02, 0x03, 0x12, 0x04, 0xdf, 0x09, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x03,
    0x04, 0x12, 0x04, 0xdf, 0x09, 0x08, 0x10, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x03, 0x05,
    0x12, 0x04, 0xdf, 0x09, 0x11, 0x17, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x03, 0x01, 0x12,
    0x04, 0xdf, 0x09, 0x18, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x7f, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xdf, 0x09, 0x2c, 0x2d, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x80, 0x01, 0x12, 0x06, 0xe2, 0x09, 0x00,
    0xe4, 0x09, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x80, 0x01, 0x01, 0x12, 0x04, 0xe2, 0x09, 0x08,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x80, 0x01, 0x02, 0x00, 0x12, 0x04, 0xe3, 0x09, 0x08, 0x47,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe3, 0x09, 0x08, 0x10,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe3, 0x09, 0x11, 0x18,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe3, 0x09, 0x19, 0x21,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe3, 0x09, 0x24, 0x25,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0xe3, 0x09, 0x26, 0x46,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x80, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0xe3, 0x09, 0x31, 0x45,
    0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x81, 0x01, 0x12, 0x06, 0xe6, 0x09, 0x00, 0xf0, 0x09, 0x01, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x81, 0x01, 0x01, 0x12, 0x04, 0xe6, 0x09, 0x08, 0x2a, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x81, 0x01, 0x02, 0x00, 0x12, 0x04, 0xe7, 0x09, 0x08, 0x31, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x81, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe7, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x81, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe7, 0x09, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x81, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe7, 0x09, 0x17, 0x1e, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x81, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe7, 0x09, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x81, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0xe7, 0x09, 0x23, 0x30, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x81, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0xe7, 0x09, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x81, 0x01, 0x02, 0x01, 0x12, 0x04, 0xe8, 0x09, 0x08, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x81, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe8, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x81, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe8, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x81, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe8, 0x09, 0x18, 0x1b, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x81, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe8, 0x09, 0x1e, 0x1f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x81, 0x01, 0x02, 0x02, 0x12, 0x04, 0xe9, 0x09, 0x08, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe9, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe9, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe9, 0x09, 0x18, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81,
    0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe9, 0x09, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81,
    0x01, 0x02, 0x03, 0x12, 0x04, 0xea, 0x09, 0x08, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x03, 0x04, 0x12, 0x04, 0xea, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x03, 0x05, 0x12, 0x04, 0xea, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x03, 0x01, 0x12, 0x04, 0xea, 0x09, 0x18, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xea, 0x09, 0x23, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81, 0x01,
    0x02, 0x04, 0x12, 0x04, 0xeb, 0x09, 0x08, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x04, 0x04, 0x12, 0x04, 0xeb, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x04, 0x05, 0x12, 0x04, 0xeb, 0x09, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x04, 0x01, 0x12, 0x04, 0xeb, 0x09, 0x19, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02,
    0x04, 0x03, 0x12, 0x04, 0xeb, 0x09, 0x2b, 0x2c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81, 0x01, 0x02,
    0x05, 0x12, 0x04, 0xec, 0x09, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x05,
    0x04, 0x12, 0x04, 0xec, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x05,
    0x05, 0x12, 0x04, 0xec, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x05,
    0x01, 0x12, 0x04, 0xec, 0x09, 0x18, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x05,
    0x03, 0x12, 0x04, 0xec, 0x09, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81, 0x01, 0x02, 0x06,
    0x12, 0x04, 0xed, 0x09, 0x08, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x06, 0x04,
    0x12, 0x04, 0xed, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x06, 0x05,
    0x12, 0x04, 0xed, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x06, 0x01,
    0x12, 0x04, 0xed, 0x09, 0x18, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x06, 0x03,
    0x12, 0x04, 0xed, 0x09, 0x2f, 0x30, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81, 0x01, 0x02, 0x07, 0x12,
    0x04, 0xee, 0x09, 0x08, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x07, 0x04, 0x12,
    0x04, 0xee, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x07, 0x05, 0x12,
    0x04, 0xee, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x07, 0x01, 0x12,
    0x04, 0xee, 0x09, 0x18, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x07, 0x03, 0x12,
    0x04, 0xee, 0x09, 0x2a, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x81, 0x01, 0x02, 0x08, 0x12, 0x04,
    0xef, 0x09, 0x08, 0x2e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x08, 0x04, 0x12, 0x04,
    0xef, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x08, 0x05, 0x12, 0x04,
    0xef, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x08, 0x01, 0x12, 0x04,
    0xef, 0x09, 0x18, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x81, 0x01, 0x02, 0x08, 0x03, 0x12, 0x04,
    0xef, 0x09, 0x2c, 0x2d, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x82, 0x01, 0x12, 0x06, 0xf2, 0x09, 0x00,
    0xf5, 0x09, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x82, 0x01, 0x01, 0x12, 0x04, 0xf2, 0x09, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x82, 0x01, 0x02, 0x00, 0x12, 0x04, 0xf3, 0x09, 0x08, 0x23,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf3, 0x09, 0x08, 0x10,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf3, 0x09, 0x11, 0x17,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf3, 0x09, 0x18, 0x1e,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf3, 0x09, 0x21, 0x22,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x82, 0x01, 0x02, 0x01, 0x12, 0x04, 0xf4, 0x09, 0x08, 0x26, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf4, 0x09, 0x08, 0x10, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf4, 0x09, 0x11, 0x17, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf4, 0x09, 0x18, 0x21, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x82, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf4, 0x09, 0x24, 0x25, 0x0a,
    0x0d, 0x0a, 0x03, 0x04, 0x83, 0x01, 0x12, 0x06, 0xf7, 0x09, 0x00, 0xff, 0x09, 0x01, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x83, 0x01, 0x01, 0x12, 0x04, 0xf7, 0x09, 0x08, 0x2e, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x83, 0x01, 0x02, 0x00, 0x12, 0x04, 0xf8, 0x09, 0x08, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x83, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf8, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x83, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf8, 0x09, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x83, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf8, 0x09, 0x17, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x83, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf8, 0x09, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x83, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0xf8, 0x09, 0x23, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x83, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0xf8, 0x09, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x83, 0x01, 0x02, 0x01, 0x12, 0x04, 0xf9, 0x09, 0x08, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83,
    0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xf9, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83,
    0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xf9, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83,
    0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xf9, 0x09, 0x18, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83,
    0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xf9, 0x09, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x83,
    0x01, 0x02, 0x02, 0x12, 0x04, 0xfa, 0x09, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01,
    0x02, 0x02, 0x04, 0x12, 0x04, 0xfa, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01,
    0x02, 0x02, 0x05, 0x12, 0x04, 0xfa, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xfa, 0x09, 0x18, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01,
    0x02, 0x02, 0x03, 0x12, 0x04, 0xfa, 0x09, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x83, 0x01,
    0x02, 0x03, 0x12, 0x04, 0xfb, 0x09, 0x08, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02,
    0x03, 0x04, 0x12, 0x04, 0xfb, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02,
    0x03, 0x05, 0x12, 0x04, 0xfb, 0x09, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02,
    0x03, 0x01, 0x12, 0x04, 0xfb, 0x09, 0x17, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02,
    0x03, 0x03, 0x12, 0x04, 0xfb, 0x09, 0x22, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x83, 0x01, 0x02,
    0x04, 0x12, 0x04, 0xfc, 0x09, 0x08, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x04,
    0x04, 0x12, 0x04, 0xfc, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x04,
    0x05, 0x12, 0x04, 0xfc, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x04,
    0x01, 0x12, 0x04, 0xfc, 0x09, 0x18, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x04,
    0x03, 0x12, 0x04, 0xfc, 0x09, 0x25, 0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x83, 0x01, 0x02, 0x05,
    0x12, 0x04, 0xfd, 0x09, 0x08, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x05, 0x04,
    0x12, 0x04, 0xfd, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x05, 0x05,
    0x12, 0x04, 0xfd, 0x09, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x05, 0x01,
    0x12, 0x04, 0xfd, 0x09, 0x18, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x05, 0x03,
    0x12, 0x04, 0xfd, 0x09, 0x28, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x83, 0x01, 0x02, 0x06, 0x12,
    0x04, 0xfe, 0x09, 0x08, 0x2d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x06, 0x04, 0x12,
    0x04, 0xfe, 0x09, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x06, 0x05, 0x12,
    0x04, 0xfe, 0x09, 0x11, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x06, 0x01, 0x12,
    0x04, 0xfe, 0x09, 0x16, 0x28, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x83, 0x01, 0x02, 0x06, 0x03, 0x12,
    0x04, 0xfe, 0x09, 0x2b, 0x2c, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x84, 0x01, 0x12, 0x06, 0x81, 0x0a,
    0x00, 0x84, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x84, 0x01, 0x01, 0x12, 0x04, 0x81, 0x0a,
    0x08, 0x1e, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x84, 0x01, 0x02, 0x00, 0x12, 0x04, 0x82, 0x0a, 0x08,
    0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x82, 0x0a, 0x08,
    0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x82, 0x0a, 0x11,
    0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x82, 0x0a, 0x18,
    0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x82, 0x0a, 0x21,
    0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x84, 0x01, 0x02, 0x01, 0x12, 0x04, 0x83, 0x0a, 0x08, 0x26,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0x83, 0x0a, 0x08, 0x10,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0x83, 0x0a, 0x11, 0x17,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x83, 0x0a, 0x18, 0x21,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x84, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x83, 0x0a, 0x24, 0x25,
    0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x85, 0x01, 0x12, 0x06, 0x86, 0x0a, 0x00, 0x89, 0x0a, 0x01, 0x0a,
    0x0c, 0x0a, 0x04, 0x04, 0x85, 0x01, 0x01, 0x12, 0x04, 0x86, 0x0a, 0x08, 0x26, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x85, 0x01, 0x02, 0x00, 0x12, 0x04, 0x87, 0x0a, 0x08, 0x31, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x87, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x87, 0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x87, 0x0a, 0x17, 0x1e, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x87, 0x0a, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0x87, 0x0a, 0x23, 0x30, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x85, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0x87, 0x0a, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x85, 0x01, 0x02, 0x01, 0x12, 0x04, 0x88, 0x0a, 0x08, 0x47, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0x88, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0x88, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0x88, 0x0a, 0x19, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0x88, 0x0a, 0x24, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x01, 0x08, 0x12, 0x04, 0x88, 0x0a, 0x26, 0x46, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x85, 0x01, 0x02, 0x01, 0x07, 0x12, 0x04, 0x88, 0x0a, 0x31, 0x45, 0x0a, 0x0d, 0x0a, 0x03, 0x04,
    0x86, 0x01, 0x12, 0x06, 0x8b, 0x0a, 0x00, 0x8e, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x86,
    0x01, 0x01, 0x12, 0x04, 0x8b, 0x0a, 0x08, 0x1d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x86, 0x01, 0x02,
    0x00, 0x12, 0x04, 0x8c, 0x0a, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x00,
    0x04, 0x12, 0x04, 0x8c, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x00,
    0x05, 0x12, 0x04, 0x8c, 0x0a, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0x8c, 0x0a, 0x18, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x00,
    0x03, 0x12, 0x04, 0x8c, 0x0a, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x86, 0x01, 0x02, 0x01,
    0x12, 0x04, 0x8d, 0x0a, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x01, 0x04,
    0x12, 0x04, 0x8d, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x01, 0x05,
    0x12, 0x04, 0x8d, 0x0a, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x01, 0x01,
    0x12, 0x04, 0x8d, 0x0a, 0x18, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x86, 0x01, 0x02, 0x01, 0x03,
    0x12, 0x04, 0x8d, 0x0a, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x87, 0x01, 0x12, 0x06, 0x90,
    0x0a, 0x00, 0x92, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x87, 0x01, 0x01, 0x12, 0x04, 0x90,
    0x0a, 0x08, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x87, 0x01, 0x02, 0x00, 0x12, 0x04, 0x91, 0x0a,
    0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x91, 0x0a,
    0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x91, 0x0a,
    0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x91, 0x0a,
    0x18, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x87, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x91, 0x0a,
    0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x88, 0x01, 0x12, 0x06, 0x94, 0x0a, 0x00, 0x96, 0x0a,
    0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x88, 0x01, 0x01, 0x12, 0x04, 0x94, 0x0a, 0x08, 0x23, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x88, 0x01, 0x02, 0x00, 0x12, 0x04, 0x95, 0x0a, 0x08, 0x2a, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x88, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x95, 0x0a, 0x08, 0x10, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x88, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x95, 0x0a, 0x11, 0x18, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x88, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x95, 0x0a, 0x19, 0x25, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x88, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x95, 0x0a, 0x28, 0x29, 0x0a, 0x0d,
    0x0a, 0x03, 0x04, 0x89, 0x01, 0x12, 0x06, 0x98, 0x0a, 0x00, 0x9c, 0x0a, 0x01, 0x0a, 0x0c, 0x0a,
    0x04, 0x04, 0x89, 0x01, 0x01, 0x12, 0x04, 0x98, 0x0a, 0x08, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04,
    0x89, 0x01, 0x02, 0x00, 0x12, 0x04, 0x99, 0x0a, 0x08, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89,
    0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0x99, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89,
    0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0x99, 0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89,
    0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0x99, 0x0a, 0x17, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89,
    0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0x99, 0x0a, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89,
    0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0x99, 0x0a, 0x23, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89,
    0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0x99, 0x0a, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x89,
    0x01, 0x02, 0x01, 0x12, 0x04, 0x9a, 0x0a, 0x08, 0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01,
    0x02, 0x01, 0x04, 0x12, 0x04, 0x9a, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01,
    0x02, 0x01, 0x05, 0x12, 0x04, 0x9a, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01,
    0x02, 0x01, 0x01, 0x12, 0x04, 0x9a, 0x0a, 0x19, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01,
    0x02, 0x01, 0x03, 0x12, 0x04, 0x9a, 0x0a, 0x28, 0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x89, 0x01,
    0x02, 0x02, 0x12, 0x04, 0x9b, 0x0a, 0x08, 0x29, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01, 0x02,
    0x02, 0x04, 0x12, 0x04, 0x9b, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01, 0x02,
    0x02, 0x05, 0x12, 0x04, 0x9b, 0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01, 0x02,
    0x02, 0x01, 0x12, 0x04, 0x9b, 0x0a, 0x17, 0x24, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x89, 0x01, 0x02,
    0x02, 0x03, 0x12, 0x04, 0x9b, 0x0a, 0x27, 0x28, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x8a, 0x01, 0x12,
    0x06, 0x9e, 0x0a, 0x00, 0xa5, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8a, 0x01, 0x01, 0x12,
    0x04, 0x9e, 0x0a, 0x08, 0x29, 0x0a, 0x0f, 0x0a, 0x05, 0x04, 0x8a, 0x01, 0x03, 0x00, 0x12, 0x06,
    0x9f, 0x0a, 0x08, 0xa1, 0x0a, 0x09, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8a, 0x01, 0x03, 0x00, 0x01,
    0x12, 0x04, 0x9f, 0x0a, 0x10, 0x1a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8a, 0x01, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0xa0, 0x0a, 0x10, 0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8a, 0x01, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xa0, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8a, 0x01,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa0, 0x0a, 0x19, 0x20, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x8a, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa0, 0x0a, 0x21, 0x28, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x8a, 0x01, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa0, 0x0a, 0x2b, 0x2c, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x8a, 0x01, 0x02, 0x00, 0x12, 0x04, 0xa3, 0x0a, 0x08, 0x24, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8a, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xa3, 0x0a, 0x08, 0x10, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8a, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xa3, 0x0a, 0x11, 0x16, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8a, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xa3, 0x0a, 0x17, 0x1f, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8a, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xa3, 0x0a, 0x22, 0x23, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x8a, 0x01, 0x02, 0x01, 0x12, 0x04, 0xa4, 0x0a, 0x08, 0x47, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8a, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xa4, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8a, 0x01, 0x02, 0x01, 0x06, 0x12, 0x04, 0xa4, 0x0a, 0x11, 0x3e, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8a, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xa4, 0x0a, 0x3f, 0x42, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8a, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xa4, 0x0a, 0x45, 0x46, 0x0a, 0x0d, 0x0a,
    0x03, 0x04, 0x8b, 0x01, 0x12, 0x06, 0xa7, 0x0a, 0x00, 0xb4, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x8b, 0x01, 0x01, 0x12, 0x04, 0xa7, 0x0a, 0x08, 0x31, 0x0a, 0x0f, 0x0a, 0x05, 0x04, 0x8b,
    0x01, 0x03, 0x00, 0x12, 0x06, 0xa8, 0x0a, 0x08, 0xb1, 0x0a, 0x09, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8b, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0xa8, 0x0a, 0x10, 0x21, 0x0a, 0x11, 0x0a, 0x07, 0x04,
    0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x12, 0x06, 0xa9, 0x0a, 0x10, 0xac, 0x0a, 0x11, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x01, 0x12, 0x04, 0xa9, 0x0a, 0x18, 0x24,
    0x0a, 0x11, 0x0a, 0x09, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xaa,
    0x0a, 0x18, 0x38, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xaa, 0x0a, 0x18, 0x20, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x8b, 0x01, 0x03, 0x00,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xaa, 0x0a, 0x21, 0x28, 0x0a, 0x12, 0x0a, 0x0a, 0x04,
    0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xaa, 0x0a, 0x29, 0x33, 0x0a,
    0x12, 0x0a, 0x0a, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xaa,
    0x0a, 0x36, 0x37, 0x0a, 0x11, 0x0a, 0x09, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01,
    0x12, 0x04, 0xab, 0x0a, 0x18, 0x31, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03,
    0x00, 0x02, 0x01, 0x04, 0x12, 0x04, 0xab, 0x0a, 0x18, 0x20, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x8b,
    0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xab, 0x0a, 0x21, 0x27, 0x0a, 0x12,
    0x0a, 0x0a, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xab, 0x0a,
    0x28, 0x2c, 0x0a, 0x12, 0x0a, 0x0a, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x03, 0x00, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xab, 0x0a, 0x2f, 0x30, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02,
    0x00, 0x12, 0x04, 0xae, 0x0a, 0x10, 0x39, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xae, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01,
    0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xae, 0x0a, 0x19, 0x1e, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x8b, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04, 0xae, 0x0a, 0x1f, 0x26, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x00, 0x03, 0x12, 0x04, 0xae, 0x0a, 0x29, 0x2a, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x00, 0x08, 0x12, 0x04, 0xae, 0x0a, 0x2b,
    0x38, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x00, 0x07, 0x12, 0x04, 0xae,
    0x0a, 0x36, 0x37, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x01, 0x12, 0x04,
    0xaf, 0x0a, 0x10, 0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xaf, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xaf, 0x0a, 0x19, 0x20, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03,
    0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xaf, 0x0a, 0x21, 0x28, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b,
    0x01, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xaf, 0x0a, 0x2b, 0x2c, 0x0a, 0x0f, 0x0a, 0x07,
    0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x02, 0x12, 0x04, 0xb0, 0x0a, 0x10, 0x6d, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x02, 0x04, 0x12, 0x04, 0xb0, 0x0a, 0x10, 0x18, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x02, 0x06, 0x12, 0x04, 0xb0, 0x0a, 0x19,
    0x62, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x02, 0x01, 0x12, 0x04, 0xb0,
    0x0a, 0x63, 0x68, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8b, 0x01, 0x03, 0x00, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xb0, 0x0a, 0x6b, 0x6c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8b, 0x01, 0x02, 0x00, 0x12, 0x04,
    0xb3, 0x0a, 0x08, 0x5c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8b, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04,
    0xb3, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8b, 0x01, 0x02, 0x00, 0x06, 0x12, 0x04,
    0xb3, 0x0a, 0x11, 0x4d, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8b, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xb3, 0x0a, 0x4e, 0x57, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8b, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04,
    0xb3, 0x0a, 0x5a, 0x5b, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x8c, 0x01, 0x12, 0x06, 0xb6, 0x0a, 0x00,
    0xb9, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8c, 0x01, 0x01, 0x12, 0x04, 0xb6, 0x0a, 0x08,
    0x26, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x12, 0x04, 0xb7, 0x0a, 0x08, 0x28,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xb7, 0x0a, 0x08, 0x10,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xb7, 0x0a, 0x11, 0x17,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xb7, 0x0a, 0x18, 0x23,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xb7, 0x0a, 0x26, 0x27,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8c, 0x01, 0x02, 0x01, 0x12, 0x04, 0xb8, 0x0a, 0x08, 0x23, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xb8, 0x0a, 0x08, 0x10, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xb8, 0x0a, 0x11, 0x17, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xb8, 0x0a, 0x18, 0x1e, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8c, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xb8, 0x0a, 0x21, 0x22, 0x0a,
    0x0d, 0x0a, 0x03, 0x04, 0x8d, 0x01, 0x12, 0x06, 0xbb, 0x0a, 0x00, 0xd7, 0x0a, 0x01, 0x0a, 0x0c,
    0x0a, 0x04, 0x04, 0x8d, 0x01, 0x01, 0x12, 0x04, 0xbb, 0x0a, 0x08, 0x1b, 0x0a, 0x0f, 0x0a, 0x05,
    0x04, 0x8d, 0x01, 0x03, 0x00, 0x12, 0x06, 0xbc, 0x0a, 0x08, 0xbf, 0x0a, 0x09, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x01, 0x12, 0x04, 0xbc, 0x0a, 0x10, 0x18, 0x0a, 0x0f, 0x0a,
    0x07, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02, 0x00, 0x12, 0x04, 0xbd, 0x0a, 0x10, 0x2e, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02, 0x00, 0x04, 0x12, 0x04, 0xbd, 0x0a, 0x10, 0x18,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02, 0x00, 0x05, 0x12, 0x04, 0xbd, 0x0a,
    0x19, 0x1f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02, 0x00, 0x01, 0x12, 0x04,
    0xbd, 0x0a, 0x20, 0x29, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02, 0x00, 0x03,
    0x12, 0x04, 0xbd, 0x0a, 0x2c, 0x2d, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02,
    0x01, 0x12, 0x04, 0xbe, 0x0a, 0x10, 0x2e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x00,
    0x02, 0x01, 0x04, 0x12, 0x04, 0xbe, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01,
    0x03, 0x00, 0x02, 0x01, 0x05, 0x12, 0x04, 0xbe, 0x0a, 0x19, 0x1e, 0x0a, 0x10, 0x0a, 0x08, 0x04,
    0x8d, 0x01, 0x03, 0x00, 0x02, 0x01, 0x01, 0x12, 0x04, 0xbe, 0x0a, 0x1f, 0x29, 0x0a, 0x10, 0x0a,
    0x08, 0x04, 0x8d, 0x01, 0x03, 0x00, 0x02, 0x01, 0x03, 0x12, 0x04, 0xbe, 0x0a, 0x2c, 0x2d, 0x0a,
    0x0f, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x12, 0x06, 0xc1, 0x0a, 0x08, 0xc6, 0x0a, 0x09,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x01, 0x12, 0x04, 0xc1, 0x0a, 0x10, 0x1a,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x00, 0x12, 0x04, 0xc2, 0x0a, 0x10,
    0x2c, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xc2,
    0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x00, 0x05, 0x12,
    0x04, 0xc2, 0x0a, 0x19, 0x1f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xc2, 0x0a, 0x20, 0x27, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xc2, 0x0a, 0x2a, 0x2b, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01,
    0x03, 0x01, 0x02, 0x01, 0x12, 0x04, 0xc3, 0x0a, 0x10, 0x2b, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d,
    0x01, 0x03, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xc3, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xc3, 0x0a, 0x19, 0x1f, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xc3, 0x0a, 0x20, 0x26,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xc3, 0x0a,
    0x29, 0x2a, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x02, 0x12, 0x04, 0xc4,
    0x0a, 0x10, 0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xc4, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x02,
    0x05, 0x12, 0x04, 0xc4, 0x0a, 0x19, 0x1f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01,
    0x02, 0x02, 0x01, 0x12, 0x04, 0xc4, 0x0a, 0x20, 0x28, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01,
    0x03, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xc4, 0x0a, 0x2b, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04,
    0x8d, 0x01, 0x03, 0x01, 0x02, 0x03, 0x12, 0x04, 0xc5, 0x0a, 0x10, 0x2c, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x03, 0x04, 0x12, 0x04, 0xc5, 0x0a, 0x10, 0x18, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x03, 0x05, 0x12, 0x04, 0xc5, 0x0a, 0x19, 0x1f,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xc5, 0x0a,
    0x20, 0x27, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xc5, 0x0a, 0x2a, 0x2b, 0x0a, 0x0f, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x12, 0x06, 0xc8,
    0x0a, 0x08, 0xce, 0x0a, 0x09, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x01, 0x12,
    0x04, 0xc8, 0x0a, 0x10, 0x15, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x00,
    0x12, 0x04, 0xc9, 0x0a, 0x10, 0x29, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xc9, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03,
    0x02, 0x02, 0x00, 0x05, 0x12, 0x04, 0xc9, 0x0a, 0x19, 0x20, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d,
    0x01, 0x03, 0x02, 0x02, 0x00, 0x01, 0x12, 0x04, 0xc9, 0x0a, 0x21, 0x24, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x00, 0x03, 0x12, 0x04, 0xc9, 0x0a, 0x27, 0x28, 0x0a, 0x0f,
    0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x01, 0x12, 0x04, 0xca, 0x0a, 0x10, 0x2f, 0x0a,
    0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x01, 0x04, 0x12, 0x04, 0xca, 0x0a, 0x10,
    0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x01, 0x05, 0x12, 0x04, 0xca,
    0x0a, 0x19, 0x1f, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x01, 0x01, 0x12,
    0x04, 0xca, 0x0a, 0x20, 0x2a, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xca, 0x0a, 0x2d, 0x2e, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x02,
    0x02, 0x02, 0x12, 0x04, 0xcb, 0x0a, 0x10, 0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03,
    0x02, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcb, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d,
    0x01, 0x03, 0x02, 0x02, 0x02, 0x05, 0x12, 0x04, 0xcb, 0x0a, 0x19, 0x1f, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x02, 0x01, 0x12, 0x04, 0xcb, 0x0a, 0x20, 0x28, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x02, 0x03, 0x12, 0x04, 0xcb, 0x0a, 0x2b, 0x2c,
    0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x03, 0x12, 0x04, 0xcc, 0x0a, 0x10,
    0x2d, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x03, 0x04, 0x12, 0x04, 0xcc,
    0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x03, 0x05, 0x12,
    0x04, 0xcc, 0x0a, 0x19, 0x20, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x03,
    0x01, 0x12, 0x04, 0xcc, 0x0a, 0x21, 0x28, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02,
    0x02, 0x03, 0x03, 0x12, 0x04, 0xcc, 0x0a, 0x2b, 0x2c, 0x0a, 0x0f, 0x0a, 0x07, 0x04, 0x8d, 0x01,
    0x03, 0x02, 0x02, 0x04, 0x12, 0x04, 0xcd, 0x0a, 0x10, 0x2e, 0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d,
    0x01, 0x03, 0x02, 0x02, 0x04, 0x04, 0x12, 0x04, 0xcd, 0x0a, 0x10, 0x18, 0x0a, 0x10, 0x0a, 0x08,
    0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x04, 0x05, 0x12, 0x04, 0xcd, 0x0a, 0x19, 0x1d, 0x0a, 0x10,
    0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x04, 0x01, 0x12, 0x04, 0xcd, 0x0a, 0x1e, 0x29,
    0x0a, 0x10, 0x0a, 0x08, 0x04, 0x8d, 0x01, 0x03, 0x02, 0x02, 0x04, 0x03, 0x12, 0x04, 0xcd, 0x0a,
    0x2c, 0x2d, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x12, 0x04, 0xd0, 0x0a, 0x08,
    0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xd0, 0x0a, 0x08,
    0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xd0, 0x0a, 0x11,
    0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xd0, 0x0a, 0x19,
    0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xd0, 0x0a, 0x28,
    0x29, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x02, 0x01, 0x12, 0x04, 0xd1, 0x0a, 0x08, 0x2c,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xd1, 0x0a, 0x08, 0x10,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xd1, 0x0a, 0x11, 0x17,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xd1, 0x0a, 0x18, 0x27,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xd1, 0x0a, 0x2a, 0x2b,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x02, 0x02, 0x12, 0x04, 0xd2, 0x0a, 0x08, 0x2f, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xd2, 0x0a, 0x08, 0x10, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0xd2, 0x0a, 0x11, 0x17, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xd2, 0x0a, 0x18, 0x2a, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xd2, 0x0a, 0x2d, 0x2e, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x8d, 0x01, 0x02, 0x03, 0x12, 0x04, 0xd3, 0x0a, 0x08, 0x3d, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x03, 0x04, 0x12, 0x04, 0xd3, 0x0a, 0x08, 0x10, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x03, 0x06, 0x12, 0x04, 0xd3, 0x0a, 0x11, 0x2e, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xd3, 0x0a, 0x2f, 0x38, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8d, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04, 0xd3, 0x0a, 0x3b, 0x3c, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x8d, 0x01, 0x02, 0x04, 0x12, 0x04, 0xd4, 0x0a, 0x08, 0x41, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8d, 0x01, 0x02, 0x04, 0x04, 0x12, 0x04, 0xd4, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8d, 0x01, 0x02, 0x04, 0x06, 0x12, 0x04, 0xd4, 0x0a, 0x11, 0x30, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8d, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xd4, 0x0a, 0x31, 0x3c, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8d, 0x01, 0x02, 0x04, 0x03, 0x12, 0x04, 0xd4, 0x0a, 0x3f, 0x40, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x8d, 0x01, 0x02, 0x05, 0x12, 0x04, 0xd5, 0x0a, 0x08, 0x37, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8d, 0x01, 0x02, 0x05, 0x04, 0x12, 0x04, 0xd5, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8d, 0x01, 0x02, 0x05, 0x06, 0x12, 0x04, 0xd5, 0x0a, 0x11, 0x2b, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8d, 0x01, 0x02, 0x05, 0x01, 0x12, 0x04, 0xd5, 0x0a, 0x2c, 0x32, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8d, 0x01, 0x02, 0x05, 0x03, 0x12, 0x04, 0xd5, 0x0a, 0x35, 0x36, 0x0a, 0x0d, 0x0a, 0x05,
    0x04, 0x8d, 0x01, 0x02, 0x06, 0x12, 0x04, 0xd6, 0x0a, 0x08, 0x3e, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8d, 0x01, 0x02, 0x06, 0x04, 0x12, 0x04, 0xd6, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8d, 0x01, 0x02, 0x06, 0x06, 0x12, 0x04, 0xd6, 0x0a, 0x11, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8d, 0x01, 0x02, 0x06, 0x01, 0x12, 0x04, 0xd6, 0x0a, 0x2c, 0x39, 0x0a, 0x0e, 0x0a, 0x06, 0x04,
    0x8d, 0x01, 0x02, 0x06, 0x03, 0x12, 0x04, 0xd6, 0x0a, 0x3c, 0x3d, 0x0a, 0x0d, 0x0a, 0x03, 0x04,
    0x8e, 0x01, 0x12, 0x06, 0xd9, 0x0a, 0x00, 0xde, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8e,
    0x01, 0x01, 0x12, 0x04, 0xd9, 0x0a, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8e, 0x01, 0x02,
    0x00, 0x12, 0x04, 0xda, 0x0a, 0x08, 0x25, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x00,
    0x04, 0x12, 0x04, 0xda, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x00,
    0x05, 0x12, 0x04, 0xda, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x00,
    0x01, 0x12, 0x04, 0xda, 0x0a, 0x19, 0x20, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x00,
    0x03, 0x12, 0x04, 0xda, 0x0a, 0x23, 0x24, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8e, 0x01, 0x02, 0x01,
    0x12, 0x04, 0xdb, 0x0a, 0x08, 0x2b, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x01, 0x04,
    0x12, 0x04, 0xdb, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x01, 0x05,
    0x12, 0x04, 0xdb, 0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x01, 0x01,
    0x12, 0x04, 0xdb, 0x0a, 0x17, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x01, 0x03,
    0x12, 0x04, 0xdb, 0x0a, 0x29, 0x2a, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8e, 0x01, 0x02, 0x02, 0x12,
    0x04, 0xdc, 0x0a, 0x08, 0x23, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x02, 0x04, 0x12,
    0x04, 0xdc, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x02, 0x05, 0x12,
    0x04, 0xdc, 0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x02, 0x01, 0x12,
    0x04, 0xdc, 0x0a, 0x17, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x02, 0x03, 0x12,
    0x04, 0xdc, 0x0a, 0x21, 0x22, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8e, 0x01, 0x02, 0x03, 0x12, 0x04,
    0xdd, 0x0a, 0x08, 0x36, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x03, 0x04, 0x12, 0x04,
    0xdd, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x03, 0x05, 0x12, 0x04,
    0xdd, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04,
    0xdd, 0x0a, 0x19, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8e, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04,
    0xdd, 0x0a, 0x34, 0x35, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x8f, 0x01, 0x12, 0x06, 0xe0, 0x0a, 0x00,
    0xe6, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x8f, 0x01, 0x01, 0x12, 0x04, 0xe0, 0x0a, 0x08,
    0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8f, 0x01, 0x02, 0x00, 0x12, 0x04, 0xe1, 0x0a, 0x08, 0x2a,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xe1, 0x0a, 0x08, 0x10,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xe1, 0x0a, 0x11, 0x18,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xe1, 0x0a, 0x19, 0x25,
    0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xe1, 0x0a, 0x28, 0x29,
    0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x8f, 0x01, 0x02, 0x01, 0x12, 0x04, 0xe2, 0x0a, 0x08, 0x2b, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xe2, 0x0a, 0x08, 0x10, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xe2, 0x0a, 0x11, 0x16, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xe2, 0x0a, 0x17, 0x26, 0x0a,
    0x0e, 0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xe2, 0x0a, 0x29, 0x2a, 0x0a,
    0x0d, 0x0a, 0x05, 0x04, 0x8f, 0x01, 0x02, 0x02, 0x12, 0x04, 0xe3, 0x0a, 0x08, 0x2f, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xe3, 0x0a, 0x08, 0x10, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0xe3, 0x0a, 0x11, 0x15, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xe3, 0x0a, 0x16, 0x2a, 0x0a, 0x0e,
    0x0a, 0x06, 0x04, 0x8f, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xe3, 0x0a, 0x2d, 0x2e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x8f, 0x01, 0x02, 0x03, 0x12, 0x04, 0xe4, 0x0a, 0x08, 0x23, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8f, 0x01, 0x02, 0x03, 0x04, 0x12, 0x04, 0xe4, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8f, 0x01, 0x02, 0x03, 0x05, 0x12, 0x04, 0xe4, 0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8f, 0x01, 0x02, 0x03, 0x01, 0x12, 0x04, 0xe4, 0x0a, 0x17, 0x1e, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x8f, 0x01, 0x02, 0x03, 0x03, 0x12, 0x04, 0xe4, 0x0a, 0x21, 0x22, 0x0a, 0x0d, 0x0a,
    0x05, 0x04, 0x8f, 0x01, 0x02, 0x04, 0x12, 0x04, 0xe5, 0x0a, 0x08, 0x36, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8f, 0x01, 0x02, 0x04, 0x04, 0x12, 0x04, 0xe5, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8f, 0x01, 0x02, 0x04, 0x05, 0x12, 0x04, 0xe5, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8f, 0x01, 0x02, 0x04, 0x01, 0x12, 0x04, 0xe5, 0x0a, 0x19, 0x31, 0x0a, 0x0e, 0x0a, 0x06,
    0x04, 0x8f, 0x01, 0x02, 0x04, 0x03, 0x12, 0x04, 0xe5, 0x0a, 0x34, 0x35, 0x0a, 0x0d, 0x0a, 0x03,
    0x04, 0x90, 0x01, 0x12, 0x06, 0xe8, 0x0a, 0x00, 0xeb, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04,
    0x90, 0x01, 0x01, 0x12, 0x04, 0xe8, 0x0a, 0x08, 0x1b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x90, 0x01,
    0x02, 0x00, 0x12, 0x04, 0xe9, 0x0a, 0x08, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02,
    0x00, 0x04, 0x12, 0x04, 0xe9, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02,
    0x00, 0x05, 0x12, 0x04, 0xe9, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02,
    0x00, 0x01, 0x12, 0x04, 0xe9, 0x0a, 0x19, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02,
    0x00, 0x03, 0x12, 0x04, 0xe9, 0x0a, 0x2a, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x90, 0x01, 0x02,
    0x01, 0x12, 0x04, 0xea, 0x0a, 0x08, 0x38, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02, 0x01,
    0x04, 0x12, 0x04, 0xea, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02, 0x01,
    0x05, 0x12, 0x04, 0xea, 0x0a, 0x11, 0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02, 0x01,
    0x01, 0x12, 0x04, 0xea, 0x0a, 0x18, 0x33, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x90, 0x01, 0x02, 0x01,
    0x03, 0x12, 0x04, 0xea, 0x0a, 0x36, 0x37, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x91, 0x01, 0x12, 0x06,
    0xed, 0x0a, 0x00, 0xf1, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x91, 0x01, 0x01, 0x12, 0x04,
    0xed, 0x0a, 0x08, 0x23, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x91, 0x01, 0x02, 0x00, 0x12, 0x04, 0xee,
    0x0a, 0x08, 0x31, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xee,
    0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xee,
    0x0a, 0x11, 0x16, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xee,
    0x0a, 0x17, 0x1e, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xee,
    0x0a, 0x21, 0x22, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x00, 0x08, 0x12, 0x04, 0xee,
    0x0a, 0x23, 0x30, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x00, 0x07, 0x12, 0x04, 0xee,
    0x0a, 0x2e, 0x2f, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x91, 0x01, 0x02, 0x01, 0x12, 0x04, 0xef, 0x0a,
    0x08, 0x2c, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x01, 0x04, 0x12, 0x04, 0xef, 0x0a,
    0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x01, 0x05, 0x12, 0x04, 0xef, 0x0a,
    0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x01, 0x01, 0x12, 0x04, 0xef, 0x0a,
    0x19, 0x27, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x01, 0x03, 0x12, 0x04, 0xef, 0x0a,
    0x2a, 0x2b, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x91, 0x01, 0x02, 0x02, 0x12, 0x04, 0xf0, 0x0a, 0x08,
    0x2f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x02, 0x04, 0x12, 0x04, 0xf0, 0x0a, 0x08,
    0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x02, 0x05, 0x12, 0x04, 0xf0, 0x0a, 0x11,
    0x17, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x02, 0x01, 0x12, 0x04, 0xf0, 0x0a, 0x18,
    0x2a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x91, 0x01, 0x02, 0x02, 0x03, 0x12, 0x04, 0xf0, 0x0a, 0x2d,
    0x2e, 0x0a, 0x0d, 0x0a, 0x03, 0x04, 0x92, 0x01, 0x12, 0x06, 0xf3, 0x0a, 0x00, 0xf5, 0x0a, 0x01,
    0x0a, 0x0c, 0x0a, 0x04, 0x04, 0x92, 0x01, 0x01, 0x12, 0x04, 0xf3, 0x0a, 0x08, 0x1e, 0x0a, 0x0d,
    0x0a, 0x05, 0x04, 0x92, 0x01, 0x02, 0x00, 0x12, 0x04, 0xf4, 0x0a, 0x08, 0x26, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x92, 0x01, 0x02, 0x00, 0x04, 0x12, 0x04, 0xf4, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x92, 0x01, 0x02, 0x00, 0x05, 0x12, 0x04, 0xf4, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x92, 0x01, 0x02, 0x00, 0x01, 0x12, 0x04, 0xf4, 0x0a, 0x19, 0x21, 0x0a, 0x0e, 0x0a,
    0x06, 0x04, 0x92, 0x01, 0x02, 0x00, 0x03, 0x12, 0x04, 0xf4, 0x0a, 0x24, 0x25, 0x0a, 0x0d, 0x0a,
    0x03, 0x04, 0x93, 0x01, 0x12, 0x06, 0xf7, 0x0a, 0x00, 0xfa, 0x0a, 0x01, 0x0a, 0x0c, 0x0a, 0x04,
    0x04, 0x93, 0x01, 0x01, 0x12, 0x04, 0xf7, 0x0a, 0x08, 0x1c, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x93,
    0x01, 0x02, 0x00, 0x12, 0x04, 0xf8, 0x0a, 0x08, 0x26, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01,
    0x02, 0x00, 0x04, 0x12, 0x04, 0xf8, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01,
    0x02, 0x00, 0x05, 0x12, 0x04, 0xf8, 0x0a, 0x11, 0x18, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01,
    0x02, 0x00, 0x01, 0x12, 0x04, 0xf8, 0x0a, 0x19, 0x21, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01,
    0x02, 0x00, 0x03, 0x12, 0x04, 0xf8, 0x0a, 0x24, 0x25, 0x0a, 0x0d, 0x0a, 0x05, 0x04, 0x93, 0x01,
    0x02, 0x01, 0x12, 0x04, 0xf9, 0x0a, 0x08, 0x1f, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01, 0x02,
    0x01, 0x04, 0x12, 0x04, 0xf9, 0x0a, 0x08, 0x10, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01, 0x02,
    0x01, 0x05, 0x12, 0x04, 0xf9, 0x0a, 0x11, 0x15, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01, 0x02,
    0x01, 0x01, 0x12, 0x04, 0xf9, 0x0a, 0x16, 0x1a, 0x0a, 0x0e, 0x0a, 0x06, 0x04, 0x93, 0x01, 0x02,
    0x01, 0x03, 0x12, 0x04, 0xf9, 0x0a, 0x1d, 0x1e,
];

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
